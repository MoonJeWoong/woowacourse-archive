# 레벨 1 - 5주차 (23.03.06 ~ 23.03.12)

---

# 23.03.06

## chatGPT
- chat GPT를 사용할 때 답변에 대해 레퍼런스를 직접 물어보는 것도 방법이다!!!

## JVM 
[레퍼런스](https://catch-me-java.tistory.com/12)
- JVM 구성요소로는 3가지가 존재
  - 클래스 로더 시스템 (Class Loader)
  - 메모리 (JVM memory)
  - 실행엔진 (Execution Engine)

## Constant Pool

- 자바 클래스 파일 내부의 Constant Pool? 
  - [oracle 레퍼런스](https://blogs.oracle.com/javamagazine/post/java-class-file-constant-pool)
  - [string pool vs constant pool](https://stackoverflow.com/questions/23252767/string-pool-vs-constant-pool)
  - [JVM stack & frames](https://sanghoonly.tistory.com/62)
  - [오라클 JVM Frames](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)
  - [오라클 JVM Instruction set](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.dup)
  - [런타임 constant pool](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.5)
  - 특정 클래스 파일을 실행할 때가 오면 JVM은 클래스 파일을 찾아내고 load 한다. 
  - loading 프로세스는 클래스 파일 내 다양한 필드들을 Parsing 하는 것과 Parsing된 데이터들을 JVM의 Method 영역에 형식을 맞춰서 저장하는 것을 수반한다.
  - 메서드 영역은 변수, 메서드, 다른 아이템들에 대해 전 쓰레드가 공유하는 영역이다.
  - 클래스 파일 format은 자바 릴리즈 버전에 따라 계속 변화해왔다.
    - 파일 헤더 : 자바 클래스 파일이 생성된 자바 버전을 나타내는 바이트
    - 상수풀 : constant pool이라 불리는 중요한 영역
    - 추가적인 데이터 필드, 메서드, 일련의 속성들 등으로 이루어져 있다.
  - Introducing the Constant Pool
    - constant pool : 클래스 파일의 가장 중요한 영역 중 하나로 클래스에 대한 Symbol 분류표로서 제공되는 항목들의 집합이다.
    - constant pool은 참조되는 클래스들의 이름, 문자열, 숫자 상수들의 초기값, 그리고 적절한 명령 수행에 필수적인 기타 데이터들을 포함한다.
    - Constant Pool을 보기 위해서는 JDK에 포함된 javap 클래스 파일 디셈블러를 사용해라.
      - 결과 값을 보면 첫번째 index는 단순히 항목들의 entry 숫자이다.
      - 두번째 컬럼은 entry의 타입을 명시한다.
      - 세번째 컬럼은 entry의 값을 포함하고 있다. 
      - // 문자 이후 내용들은 javap가 무엇이 사용되고 있는지 표시하기 위해 얘기하고 있는 내용이다.
    - 아마도 이 결과 리스팅에 대해서 가장 충격적인 내용은 문자열 데이터들을 표시하기 위해 자바 클래스 내부에서만 사용되는 UTF-8타입의 entry 빈도수일 것이다.
    - 클래스 이름, 메서드 이름, 메서드 시그니처 등을 모두 utf-8 문자열로 저장한다.
  - 개인적인 정리
    - 자바에서 constant pool은 기본적으로 클래스 파일 내부에 존재하는 클래스 이름, **문자열 / 숫자 상수 초기값**, 그리고 기타 데이터들을 symbol 테이블로 저장한다.
    - 여기에서 문자열 리터럴들은 모두 constant pool에 utf-8로 타입으로 저장된다.
    - 정수형 리터럴 중 byte, short에 해당되는 값들은 미리 상수풀에(상수풀에 저장되는지는 아직 몰루?) 캐싱되어 있다. (자바버전 업그레이드에 따라 과거에 비해 변경된 사항임)
      - 그래서 byte, short에 해당하는 리터럴 값들은 바이트 코드에서 bipush/sipush 를 사용해 값이 operand stack에 push된다.
      - 그 이외 범위의 정수 리터럴들은 LDC를 사용해 런타임 상수풀에 저장되어 있는 리터럴 값을 operand stack에 push한다.(?몰루)
      - 40000 이라는 정수 리터럴은 미리 캐싱되어 있지 않기 때문에 컴파일 시 생성되는 constant pool에 등록된다.
      - 이후 LDC 컴파일 명령어를 통해 runtime constant pool에 저장되어 있는 40000이라는 값을 operand stack에 넣어준다.
    - runtime constant pool은 기존 클래스와 인터페이스 별 constant pool로부터 derived 된다.
    - runtime constant pool은 클래스 혹은 인터페이스의 constant pool 내 모든 symbolic reference들을 resolving하여 얻어지기 때문에
      - runtime constant pool은 정확하게 클래스 / 인터페이스의 constant pool이 가지지 않고 있는 일부 상수들도 포함하고 있다.
    - DUP 명령어는 operand stack에 최상단에 위치한 value를 복사해 다시 operand stack에 push 한다.
    - new 명령어는 새로운 객체를 생성하고 객체에 대한 레퍼런스를 operand stack에 push 한다.




# 23.03.07

## 블랙잭 미션 1차 피드백 정리

- map 객체를 사용하는데 키 값이 Enum이라면 EnumMap 사용을 고려하자. [레퍼런스](https://velog.io/@kasania/Java-EnumMap)
- Enum 안에서 map을 초기화 하는 방법 [레퍼런스](https://velog.io/@ljinsk3/Enum%EC%9D%98-%EC%9A%94%EC%86%8C%EB%A5%BC-%EC%A1%B0%ED%9A%8C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-vs-HashMap)
~~~ java
private static final Map<String, DrawCommand> inputDrawCommandMap = Collections.unmodifiableMap(Stream.of(values())
            .collect(Collectors.toMap(DrawCommand::getCommand, Function.identity())));  // 함수형 인터페이스 + 제네릭 공부를 해야하지 않을까...?
~~~

## player 내부의 isWinner 관련 리팩토링
- player와 dealer의 score 상태값을 이용하여 결과를 계산하는 GameResult 클래스를 구현 예정
- 그 전에 전체 player들의 상태와 행위를 관리하기 위한 일급 컬렉션 players를 구현하기로 결정
- player 생성의 책임을 players 내부로 이관 결정
- player 생성 시 카드를 처음부터 받지 않고 나중에 받을 수 있도록 변경 (추상클래스 user 차원에서 기능 변경)
  - user가 소유한 카드가 없을 시에 예외처리 수행해주기.
- player가 생성 시 카드를 가지고 있지 않게 되므로 score 상태 값 외부로 분리
  - User 게임의 점수를 전반적으로 관리하는 GameScore 클래스로 분리 
- 기존 cards 클래스를 사용자의 패 정보를 관리하는 클래스로 변경하고 내부에 가진 카드의 점수를 가질 수 있도록 변경
- 기존 cards 클래스가 수행하던 덱 정보 관리 기능은 Deck 클래스를 새로 생성하기
- User가 가지고 있는 카드 정보를 가지고 있는 Hands 클래스 구현
  - score 계산 기능을 hands 내부 상태값으로 변경하기?
  - user hands와 dealer hands를 이용해 score 비교 기능 추가하기
- 플레이어와 딜러의 승/패를 판단하는 referee 클래스 구현(?)
- BalckJackGame 클래스는 어떤 역할을 해야하는가?
  - 현재 게임 결과를 판단하는 기능을 분리하고 나니 유저들에게 카드를 분배하는 기능 말고는 담당하는 기능이 없다.
- 도메인에서 주고받는 메세지는 원시타입 값이 아닌 포장된 객체여야 한다. -> 이름 값이 메세지로 주고 받아질 때 string이 아닌 Name 객체로 주고 받아지도록 수정
- 게임에서 현재 덱을 관리하는 기존 Cards 클래스를 Deck 클래스로 변경
  - 테스트 코드 수정 과정에서 shuffle 기능 테스트를 위한 전략 패턴 구현

- GameResult 클래스에서 Player와 Dealer의 정보를 받아 게임 결과 계산
  - 과연 구현한 GameResult 객체를 어디에서 생성해서 사용해야 하는가?
  - 전체적으로 리팩토링해야할 부분이 너무 많아서 일단 기존 BlackJackGame 클래스에서 결과를 계산하던 기능을 이관하는 것만 진행하기로 결정.

- 게임 상에서 동명이인은 없는 것으로 결정
- 즉 같은 이름은 동일한 사람으로 취급되어야 함
  - Name 클래스 내에 equals & hashCode 오버라이딩

- 인터페이스를 정의한 이유?
  - User 클래스를 상속하는 Player와 Dealer는 각각 PlayerStatus, DealerStatus 상태 값을 이용하여 자신이 어떤 상태인지 관리하고 있습니다.
  - player와 dealer가 공통적으로 자신의 상태를 외부에서 메세지를 보냄으로써 확인할 수 있도록 하려고 했습니다.
  - 그러나 해당 기능을 User 추상 클래스에 구현하려고 보니 Player와 Dealer의 상태 값 Enum 클래스가 달라서 추상 메서드를 정의해주기가 애매했습니다.
  - 그래서 시간 관계상 깊게 고민하지 못하고 PlayerStatus와 DealerStatus가 UserStatus라는 인터페이스를 상속받게 함으로써 이를 해결해보고자 했습니다.
  - 그러나 막상 UserStatus 인터페이스에 명시할만한 기능은 존재하지 않아 이런 결과를 낳게 되었습니다.
  - 어떤 방식으로 리팩토링 해야할 지 아직 감이 잘 안 잡히는데 이런 경우라면 차라리 추상 메서드 선언을 포기하고 인터페이스를 삭제하는 방향이 좋을지 고민입니다.

안녕하세요 코즈! 히이로입니다.

1차 리뷰에 대한 리팩토링이 개인 사정으로 인해 많이 늦어졌습니다. 죄송합니다 😭

먼저 말씀드리고 싶은 부분은 처음에도 말씀드렸다시피 페어 미션 과정에서 워낙 급하게 구현하느라 이전 미션에서 배운 부분이나 이번 미션에서 주어진 요구사항들 중 지키지 못하고 놓친 부분들이 많습니다. 거기에 코즈가 1차적으로 달아주신 리뷰들을 보며 리팩토링을 어떻게 해야할지 고민하다보니 고치고 싶은 부분이 너무 많이 보이는 것 같아요.

그러나 지금 코드를 전부 엎어가며 리팩토링을 진행하기엔 저나 리뷰어인 코즈에게도 좋은 것은 아닌것처럼 느껴져서 1차적으로 리뷰 주신 부분들만 최대한 집중해서 리팩토링을 진행했습니다. 제 개인적인 의견으로는 2차 미션을 병행하면서 전반적으로 놓친 부분들을 수정하는 것이 좋아보이는데 코즈의 의견은 어떠신지 궁금합니다.

혹시 1단계에서 반드시 짚고 넘어가야할 부분이 있거나  제가 놓친 것이 있다면 알려주시면 감사하겠습니다. 🙇

## 블랙잭 미션 피드백 1
- 좋은 객체의 7가지 덕목 레퍼런스 읽어보자!
- 기본적인 요구사항 정리
- 카드 클래스가 가장 작은 엔티티라고 판단이 된다.
  - 카드를 구현하기 전에 도메인 용어를 파악하기 위해 검색해보는 것도 좋다. (suit, denomination, hand 등...)
  - 네오는 맨 처음 TDD를 하면서 create 테스트 부터 한다. 생성자로 객체를 생성하고 toString 오버라이딩을 통해 내부에 적절한 데이터가 들어있는지 확인 (assertDoesNotThrow) 네오는 toString을 무조건 구현하는 편이라고 함
    - 생각해보면 toString을 디버깅 용도로 사용하는 케이스도 여기에 해당하지 않나 생각된다.
    - 처음에 시작할 떄는 생성 테스트를 해주는 것도 좋겠다.
  - 52개 카드를 매번 생성할 필요가 있을까? -> 캐싱을 해보자!
    - concurrentHashMap 사용?? private static final 로 클래스 변수로 사용한다.
    - computeIfAbsent 메서드 사용
    - 정적 팩토리 메서드를 사용하면 기타 생성자의 접근 제어자를 private화 하는 것이 좋다. (캐싱을 해뒀는데 기본 생성자로 카드를 생성해버리면 안된다.)
- 추상 클래스와 구현 클래스를 구분하기 위해 구현 클래스에는 final 선언을 해주는 것이 좋다.
- Hand 클래스는 card 객체들을 갖는 일급 컬렉션
  - Hand 클래스의 생성자를 여러개 만드는데 이것이 과연 좋은 걸까? 이번 학습자료에 내용 나와있으니 고민해보자.
  - hand 클래스를 구현하다 보니 score 관련 기능이 많이 나온다. 값 객체 분리를 생각해볼 때!
  - 클래스 변수가 상수의 역할을 하지 않는다면 굳이 대문자 컨벤션을 지킬 필요는 없는 것 같다.
  - 네오는 primitive 타입이 아니면 전부 상수 네이밍 컨벤션을 지키지 않는다고 한다.
  - 일급 컬렉션 내부 리스트를 외부로 반환할 때도 방어적 복사를 잘 취해서 불변을 보장하도록 하는 것이 좋다.
- 두 도메인에서 공통되는 기능들을 뽑아내서 인터페이스, 추상클래스로 구현할 수 있다.

# 23.03.08

## 데이터베이스 공통 강의
- 우리가 www.naver.com을 검색하면 서버에 네이버 index.html 파일을 요청하는 것이다.
- url 에서 물음표 뒤에 오는 것들을 쿼리 스트링이라고 한다.
  - 트래킹 URL이 있다는데 뭘까나...?
- post 명령 수행 시 http 바디에 데이터를 담아 전송하게 된다.
  - 데이터가 노출되지 않는다고 하는데 사실 개발자 도구로 까보면 전부 확인할 수 있다.
  - 따라서 별도로 암호화를 챙겨줘야 한다.
- 리다이렉션
  - 301의 경우 영구이동으로 보고 이전 URL을 보여주지 않았는데
  - 302의 경우 임시이동이라 예전 URL을 띄워주는 방식으로 진행되었기에 이와 관련된 이슈도 있었다.
    - 유명 사이트의 비슷한 url을 사서 301리디렉션을 걸어버리는 것.

- 파일시스템
  - 기존 파일 시스템이 가지고 있는 단점을 해결하기 위해 등장한 것이 데이터 베이스이다.

- ERD : 현실에서 개체들 간 관계를 컴퓨터로 가져와 표현하는 방식

- 연산자에서 where title like '%해리포터%' 라고 하면 앞 뒤를 제외하고 해리포터가 포함된 제목들 데이터를 쿼리한다.

- SQL 시뮬레이션 페이지 URL : https://www.w3schools.com/sql/trysql.asp?filename=trysql_asc
- 설문 1번 문제
- 200개 이상 팔린 상품명과 그 수량을 수량 기준 내림차순으로 보여 주세요.
~~~ SQL
SELECT ProductName, SUM(Quantity)
FROM Products AS p
INNER JOIN OrderDetails AS od ON od.ProductID = p.ProductID
GROUP BY p.ProductID
HAVING SUM(Quantity) > 200
ORDER BY SUM(Quantity) DESC;
~~~

- select 문에서는 각 컬럼 값들에 대해 sum, count, min/max 등의 기능 수행이 가능하다.
- groupBy 연산이 select보다 먼저 수행되기 때문에 groupBy 이후에 사용되는 select문 내 연산들은 각 그룹별로 그룹핑된 데이터들에 각각 적용된 결과가 나온다.

- 설문 2번 문제
- 많이 주문한 순으로 고객 리스트(ID, 고객명)를 구해 주세요.
~~~ SQL
SELECT c.CustomerID, CustomerName
FROM Customers AS c
INNER JOIN Orders AS o ON o.CustomerID = c.CustomerID
GROUP BY c.CustomerID
ORDER BY SUM(OrderID);
~~~

- inner join 사용 시 중복되는 컬럼이 두 테이블에 모두 존재할 경우 select문에서 어떤 테이블의 값을 가져와서 표시할지 명시해줘야 된다.

- 설문 3번 문제
- 많은 돈을 지출한 순으로 고객 리스트를 구해 주세요.
~~~ SQL
SELECT c.CustomerID, CustomerName
FROM Products as p
INNER JOIN OrderDetails as od ON p.ProductID = od.ProductID
INNER JOIN Orders as o ON o.OrderID = od.OrderID
INNER JOIN Customers as c ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID
ORDER BY SUM(p.Price*od.Quantity) DESC;
~~~

## 리스트 미션 진행하기
- java.util.List Interface
  - List 자체는 인터페이스구나!
  - 대표적인 구현체로 ArrayList와 LinkedList가 존재
  - List는 배열에서 지원하지 않는 많은 기능들을 제공하기 때문에 배열보다는 List를 사용하는 것이 좋다.
- ArrayList와 LinkedList의 차이
  - 사용 방법은 같으나 데이터를 저장하는 방식에 차이가 있다.
- ArrayList는 내부적으로 가진 배열의 size를 1.5배씩 증가시킨다. 그리고 remove 할때는 배열 size를 따로 줄여주지는 않는다.
  - 이를 관리하기 위해 현재 가진 element의 개수대로 배열 size를 줄여주는 trimToSize 메서드가 존재하나 직접 사용해 줘야 한다. (마코의 말로는 그 정도로 개발자가 메모리를 관리해줘야 할 경우가 있을까 라고 했다.)

# 사다리 미션 마무리
안녕하세요 코다! 히이로입니다.
우선 리뷰 요청을 너무나 늦게 드리게 되어 죄송합니다...
지난 주 테코톡 발표 준비에 욕심을 부린 데다가 개인적인 사정이 겹쳐 제 시간에 리뷰 요청을 드리지 못했습니다.

코드적으로 수정한 부분은 예전에 말씀드린 대로 Name 객체가 동일한 이름을 가질 땐 같은 사람으로 판단되어야 하기에 논리적 동치성 보장을 위한
equals & hashCode 만 오버라이딩한 것 외에는 없습니다.

코다가 마지막에 남겨주셨던 리뷰들을 다시 읽어보며 생각을 정리해봤습니다.

- 이번 미션에서 position 상태 값을 player가 갖도록 했기 때문에 자연스럽게 위치 관련 게임 진행 로직 또한 players 내부로 이관되었어요.
  - 때문에 players 가 지는 책임이 굉장히 커지는 이슈가 발생했습니다.
  - 저는 예전에 이 문제가 일급 컬렉션을 잘못 사용하고 있기 때문이라는 생각에 매몰되어 있었던 것 같아요.
  - 하지만 이번 블랙잭 미션을 진행하고 다시 사다리 게임 코드를 보니 Players 일급 컬렉션 클래스 사용의 문제가 아니라 Player 객체 자체에 많은 책임이 부과된 문제가 있는게 아닌가 라는 생각이 들었습니다.
  - 여기까지 생각이 미치니 코다가 달아주신 리뷰도 새로운 관점에서 다시 이해가 되었던 것 같아요.
  - 코다의 리뷰대로 position 관련 책임이 Player에 없다고 한다면 Players가 가지는 책임이 플레이어의 이름과 게임 결과를 저장하고 반환하는 기능밖에 수행할 수 없어지기에 Players 자체를 구현하는 이유가 없어져버리게 되요.
    - 물론 전체적인 설계를 다시 생각해서 Player가 지는 책임을 다시 생각한다면 Players가 구현되어야 할 이유를 찾아볼 수는 있을 거라고 생각합니다.
    - Position을 관리하는 책임을 ladder에서 지도록 구현했던 코다가 players라는 일급컬렉션을 사용하지 않았던 이유도 같이 이해가 되었습니다.
  - 현재 블랙잭 미션을 진행하면서도 그렇고 앞으로 단일 객체에 책임이 과중하게 부과된다면 객체 간 설계를 다시 생각해보는 방식으로 다시 접근할 수 있을 것 같습니다. (물론 아직도 설계에 대한 부분은 모르는게 너무 많네요...)

- 다른 하나는 controller 에서 view와 무관한 비즈니스 로직이 노출되고 있다는 문제입니다.
  - 이 부분은 전적으로 코다의 리뷰가 옳다고 생각했어요.
  - controller 에서 playGame 메서드 부분을 LadderGame 클래스로 이관 시키면서 다음과 같은 생각이 들었습니다.
  - Players가 가진 과도한 책임을 다른 객체로 분리시켜 줘야 LadderGame이 질 수 있는 책임도 명확해질 수 있겠다고 판단했습니다.
  - 현재 LadderGame은 게임을 진행하고 단순히 Players 객체를 반환해줄 뿐입니다.
  - 이를 해결하기 위해서는 Players의 책임을 게임을 진행하는 객체, 게임 최종 결과를 관리하는 객체 등으로 분리해내는 것이 필요하다고 생각이 들었어요.
  - 다만 해당 고민은 현재 진행중인 블랙잭 미션에서도 계속 생각해야 하는 부분이기에 이 때문에 사다리 게임 미션에 더 시간을 투자하는 시기는 지났다고 스스로 판단했습니다.
  - 이러한 이유로 부족한 부분이 보임에도 리뷰 요청을 드렸습니다.

코다가 정말 리뷰를 성심성의껏 달아주셨던만큼 마무리도 잘 해보고 싶었는데 개인적으로 아쉬움이 남을 수 밖에 없는 미션이었던 것 같습니다.
다시 한 번 늦게 요청드려서 죄송합니다 코다... 코다가 이번 리뷰어였어서 공부하는 과정이 너무나 즐거웠었습니다!


# 23.03.10

다음 코수타
레벨을 지나오면서 많은 것들을 배우고 있는데 모든게 머리에 담기지는 않는 것 같아요.
이런 경우 어떤 것들을 먼저 더 챙겨서 익힐지 우선순위를 고민하게 될 것 같은데 브라운은 어떤 식으로 생각하고 학습을 하게 되실 것 같은지 궁금합니다.
공부해야할 것은 너무나 많은데 시간과 체력적 리소스는 제한되어 있다. 이런 부분은 교육과정 내 뿐만 아니라 현업을 지내면서도 계속 안고가게 될 고민인 것 같은데 어떻게 관리해 나가는 것이 좋을까



## 블랙잭 미션 피드백 1 다시보며 정리
### 좋은 객체의 7가지 덕목 정리
- [좋은 객체의 7가지 덕목](https://codingnuri.com/seven-virtues-of-good-object/) : 한 번에 이해되기에는 조금 어려운 듯... 나중에 다시 읽어보자...
- 클래스 VS 객체
  - 클래스는 새로운 객체를 생성하는 것 뿐만 아니라 더 이상 사용하지 않는 객체를 파괴하는 책임 또한 가지고 있다.
  - 클래스는 해당 클래스를 상속받은 자식 클래스들이 따라야하는 계약, 즉 어떤 상태 값과 행위를 가지는지 알고 있다.
  - 클래스를 객체 템플릿으로 정의하는 관점도 있는데 이는 클래스를 굉장히 수동적인 위치에 있는 것으로 생각하는 것이다.
  - 하지만 객체들이 클래스에게 새로운 객체를 만들어달라고 요청했을 때, 클래스는 객체를 만들어내는 등 굉장히 주체적으로 자신의 책임을 수행한다.
- 객체가 현실세계에 존재한다.
  - 객체는 하나의 생명체로써 자신만의 생명주기, 행위, 습관을 지닌 독립적인 개체이다.
  - 우리가 구현하는 프로그램의 범위 바깥에 존재하는 모든 것을 현실 세계라고 가정하자.
    - 현실 세계에는 스스로 생명주기, 행위, 습관을 지닌 피조물들이 존재한다.
    - 객체는 이러한 현실세계의 피조물들을 대표하며 프로그램 상에서 해당 피조물의 대리자(proxy) 역할을 수행하는 것이다.
  - 컨트롤러, 파서, 필터, 검증기, 서비스 로케이터, 싱글턴, 팩토리 등은 이러한 관점에서 좋은 객체가 아니다.
    - 이들은 GoF 패턴들로 안티패턴이라 불린다.
    - 안티패턴 : 실제로 많이 사용되는 패턴이지만 비효율적이거나 비생산적인 패턴을 의미한다.
    - 이들은 현실 세계의 피조물을 대표하는 대리자들이 아니며 단지 다른 객체와 함께 사용하기 위해 만들어낸 것들이다.
  - 자신이 구현한 객체가 현실세계의 어떤 피조물을 대표하는지 생각해보고 답을 찾을 수 없다면 리팩토링을 고려해야 한다.
- 객체가 계약에 따라 동작한다.
  - 객체는 스스로의 특성이 아니라 자신이 준수하는 계약에 따라 사용되길 예상한다.
    - 여기서 계약은 자식 클래스가 상속받는 인터페이스/부모클래스로부터 스스로가 어떻게 동작해야 하는지를 결정받는 것이라 이해했다.
    - 좋은 객체 안에 담긴 모든 공용 메서드는 인터페이스 상에 선언된, 상응하는 메서드들을 구현한 것이다.
    - 만약 자신이 구현한 객체에 어떤 인터페이스에도 상속되지 않은 공용 메서드가 있다면 그 객체는 잘못 설계된 것이다.
    - 이렇게 판단하는 데에는 다음과 같은 2가지 이유가 있다.
      - 첫째, 상위 클래스와 계약 없이 동작하는 객체는 단위 테스트에서 목킹하는 것이 불가능하다.
      - 둘째, 계약 없는 객체는 데코레이션을 통해 확장하는 것이 불가능하다.
        - 데코레이션 : 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 서브클래싱 대신 쓸수 있는 유연한 대안이 될 수 있다.
- 객체가 고유하다.
  - 좋은 객체는 스스로의 고유함을 유지하기 위해 캡슐화된 상태 값을 가져야한다.
  - 만약 캡슐화된 상태값이 없으면 여러 개의 객체 인스턴스가 생성된다 하더라도 서로 동일한 인스턴스(복제본)로 판단될 것이다.
  - 아래는 원글에 작성된 복제본을 가질 수 있는 나쁜 객체의 예시이다.
  ~~~ java
  class HTTPStatus implements Status {
    private URL page = new URL("https://localhost");
    @Override
    public int read() throws IOException {
      return HttpURLConnection.class.cast(
        this.page.openConnection()
      ).getResponseCode();
    }
  }
  ~~~
  
  - 위 코드를 아래와 같이 사용해 인스턴스를 생성했을 때 모든 인스턴스는 서로 동일한 것으로 판단된다.
  - page라는 URL 타입을 캡슐화하고 있는데 왜 복제본이냐라고 생각할 수 있다.
  - page에 담기는 URL 객체는 항상 로컬호스트 주소값을 가지는 URL 객체이므로 일종의 상수처럼 적용되기 때문에 캡슐화된 고유한 상태 값이 없다고 볼 수 있는 것이다.

  ~~~ java
  first = new HTTPStatus();
  second = new HTTPStatus();
  assert first.equals(second);
  ~~~
  
  - 정적(static) 메서드만이 담긴 유틸리티 클래스는 좋은 객체를 인스턴스화 할 수 없다.
  - 유틸리티 클래스는 단지 현대 객체지향 언어를 발명한 사람들이 정적 메서드를 사용할 수 있게 만들어 뒀다는 이유로 존재하는 것 뿐이다.
  
- 객체가 불변적이다.
  - 좋은 객체는 자신이 캡슐화한 상태를 절대 변경하지 않는다.
  - 불변성이 모든 객체 내 메서드가 동일한 값만을 반환하는 것이라고 이해하면 안된다.
  - 오히려 좋은 불변 객체는 매우 역동적이며 그럼에도 자신의 내부 상태는 절대 변경하지 않는다.
  - 다음은 불변성이 왜 좋은 객체의 덕목에 포함되는지에 대한 이유들이다.
    - 불변 객체는 생성, 테스트, 사용하기가 더 간단하다.
    - 진정한 불변 객체는 언제나 스레드 세이프하다.
    - 불변 객체는 시간적 결합(temporal coupling)을 피하는 데 도움이 된다.
    - 불변 객체의 사용은 부수효과를 발생시키지 않는다(방어적 복사를 하지 않아도 된다).
    - 불변 객체는 언제나 실패 원자성을 띤다.
    - 불변 객체는 캐싱하기가 훨씬 더 쉽다.
    - 불변 객체는 NULL 참조를 방지한다.

- 객체의 클래스에 정적 멤버가 없다.
  - 정적 멤버는 객체의 행위가 아니라 클래스의 행위를 구현하는 것이다.
  - 정적 메서드는 객체지향 프로그래밍을 클래스 지향 프로그래밍으로 바꾸기 떄문에 문제를 발생시킨다.
  - 클래스 지향 프로그래밍의 경우 분해(decomposition)가 더 이상 작동하지 않는 데 있다.
  - 객체지향 프로그래밍의 위력은 객체를 범위 분해(scope decomposition)를 위한 도구로 사용할 수 있다는데 있다.
    - 메서드 내에서 객체를 인스턴스화 하면 해당 객체는 특정 과업을 수행하기 위해 전념한다.
    - 이 때 해당 객체는 메서드 외부 다른 모든 객체들로부터 완벽하게 고립될 수 있다. (메서드의 지역변수)
    - 하지만 정적 메서드를 가진 클래스는 어떻게 사용하건 간에 내부 변수들이 전역변수처럼 사용된다.
    - 따라서 정적 메서드를 가지는 경우 범위 분해의 도구로 사용될 수 있다는 장점을 상실하게 된다.

- 객체의 이름이 직명을 나타내지 않는다.
  - 객체의 이름은 객체가 무엇인지 말해야 하지 무슨 일을 수행하는지 말해서는 안된다.
  - 우리가 '페이지 모음기' 대신 '책'을 '물 보관기' 대신 '컵' 등의 이름을 붙이는 것과 같다.
  - 일반적으로 -er 로 끝나는 이름은 피하자. 대부분의 경우 좋지 않은 설계로 이어지게 되는 이름들이다.
    - FileReader 대신 FileWithData 혹은 DataFile 등과 같은 이름을 사용하도록 하자.
  - 언제나 객체가 무슨 일을 하는지가 아니라 그것이 본질적으로 무엇인지 고민하도록 하자.

- 객체의 클래스가 Final이나 Abstract이다.
  - 좋은 객체는 final 클래스나 abstract 클래스에서 온다.
  - final 클래스는 더 이상 쪼갤 수 없는 블랙박스와 같은 클래스이다.
    - 클래스가 설계된 동작 그대로 동작하고, 그것을 사용하거나 사용하지 않으면 그만이다.
    - final 클래스를 다른 클래스에 상속시킬 수는 없다.
    - final 클래스를 확장하는 유일한 방법은 final 클래스의 자식을 데코레이션하는 것이다.
    - ~~~ JAVA
      class OnlyValidStatus extends HTTPStatus {
        public OnlyValidStatus(URL url) {
          super(url);
        }
        @Override
        public int read() throws IOException {
          int code = super.read();
          if (code >= 400) {
            throw new RuntimeException("Unsuccessful HTTP code");
          }
          return code;
        }
      }
      ~~~
      - 위 클래스는 HTTPStatus 클래스를 직접 상속받고 있다.
      - 이는 부모 클래스인 HTTPStatus 메서드 중 하나인 read()를 오버라이드 함으로써 전체 부모 클래스의 로직을 망가뜨릴 위험을 무릅쓰는 것이다.
      - 즉 HTTPStatus 클래스의 다른 기존 메서드들이 새롭게 오버라이드된 OnlyValidStatus 클래스의 read 메서드를 사용하게 되는 것이다.
      - 말 그대로 클래스에 새로운 '구현의 일부'를 삽입하는 것으로 매우 위험한 행위이다.
    - 반면 final 클래스를 확장하려면 확장하는 대상을 블랙박스처럼 간주하고 우리가 직접 구현하는 구현체에 데코레이터 패턴을 사용해야 한다.
    - ~~~ java
      final class OnlyValidStatus implements Status {
        private final Status origin;
        public OnlyValidStatus(Status status) {
          this.origin = status;
        }
        @Override
        public int read() throws IOException {
          int code = this.origin.read();
          if (code >= 400) {
            throw new RuntimeException("Unsuccessful HTTP code");
          }
          return code;
        }
      }
      ~~~
    - 위 클래스는 원본 클래스인 Status와 동일한 인터페이스를 구현하고 있다.
    - HTTPStatus의 인스턴스는 생성자를 통해 클래스에 전달되고 캡슐화된다.
    - 그 뒤 필요한 경우 HTTPStatus의 인스턴스에 대한 모든 호출을 가로채서 다른 방식으로 구현할 것이다.
    - 이 설계에서는 HTTPStatus 객체를 블랙박스로 취급하고 그것의 내부 로직은 전혀 건드리지 않는다.
  - 위 사례들에서 알 수 있었듯 클래스에 final 선언을 해주지 않으면 누군가가 클래스를 확장한 다음 잘못된 기능 삽입을 행할 수 있다.
  - 그러니 추가적인 확장을 원하지 않는다는 것을 명시하기 위해 final 키워드를 반드시 사용해주자.
  - 추상 클래스의 경우 정확히 반대의 경우이다.
  - 추상 클래스는 현재 클래스가 불완전하고 '지금 모습 그대로' 사용할 수 없음을 말해준다. 
  - 따라서 추상 클래스에 별도로 로직을 구현해줘야 하며 이 때 우리가 건드릴 수 있게 허용한 기능만 구현할 수 있다.
  - 이렇게 허용된 기능 즉 메서드를 abstract 키워드를 통해 명시한다.
  - ~~~ java
    abstract class ValidatedHTTPStatus implements Status {
      @Override
      public final int read() throws IOException {
        int code = this.origin.read();
        if (!this.isValid()) {
          throw new RuntimeException("Unsuccessful HTTP code");
        }
        return code;
      }
      protected abstract boolean isValid();
    }
    ~~~
    - 위 코드에서 클래스는 HTTP 코드의 유효성을 정확히 어떻게 검증해야 할 지 알지 못하며 그 부분은 상속과 isValid 메서드의 오버라이딩을 통해 구현되길 기대한다.
    - 다른 모든 메서드는 final로 방어하고 추가 구현을 원하는 기능만 abstract로 명시를 해줬기에 해당 클래스를 상속하는 것은 문제가 없다.
    - 정리하자면 클래스를 설계할 떄에는 반드시 final이나 abstract를 지정해야 하며 그 중간은 없다.





- 요구사항을 오래 붙잡고 있는 것도 큰 의미는 없다. 이후에 구현하다보면 바뀌게 될 가능성이 농후해서이지 않을까? 다음 미션에서는 투자하는 시간을 줄여보도록 하자.
- 클래스를 구현할 때 해당 클래스가 추상 클래스인지 아니면 구현 클래스인지 final 선언을 해줌으로써 명시해 주는 것이 좋다.
- 객체 캐싱의 개념도 한 번 공부해보자.
  - 이번 미션에서 객체를 캐싱하기 위해 Map 자료구조를 사용한 크루들이 많다.
  - 그런데 key 값들의 해시 값이 같아지게 되면 어떻게 될까?
    - 내부적으로 리스트를 생성해서 해당 해시 값으로 접근 시 리스트를 순회하게 된다.(이렇다고 했던것 같은데?)
- 카드 객체들을 값 객체처럼 사용하기 때문에 equals hashCode를 오버라이딩 해준다.
- 정적 팩토리 메서드를 구현해준 경우 다른 생성자는 private으로 은닉화해주는 것이 좋다.
  - 정적 팩토리 메서드를 구현했는데 new 키워드 사용이 가능하다면 보통 new 키워드를 먼저 사용하기 때문이다.
- Hand 객체 내부에서 score 합산 메서드 구현시 사용한 stream reduce 에서 함수형 인터페이스 사용하는데 나중에 정리해보기
- 피드백 2 넘어가기 전에 피드백 1 정리하기

### 피드백 영상 정리
- 52개의 카드를 매번 생성할 필요가 있을까? => 캐싱하자!
  - map 자료구조를 통해 객체를 캐싱할 수 있다.
  - hashMap의 초기 용량을 주입해 주는 이유는 hashMap이 내부적으로 용량을 2배씩 늘리기에 불필요한 메모리 공간 낭비를 막기 위함이다.
  - Map에서 특정 키에 해당하는 값이 존재하는지 확인한 후 없으면 새로 만들어서 넣어주는 코드로 computeIfAbsent를 사용 가능하다.
- 값 객체는 equals & hashCode를 재정의한다.
- 객체에 생성자가 여러개 존재해도 괜찮을까?
  - 생성자의 주된 임무는 제공된 인자를 사용해서 캡슐화된 프로퍼티를 초기화 해주는 것이다.
  - 실질적으로 초기화하는 로직은 오직 하나의 생성자에만 위치 시키고 이 생성자를 주 생성자(Primary Constructor)라고 부른다.
  - 부 생성자(Secondary Constructor)라고 부르는 다른 생성자들이 주 생성자를 호출하도록 만든다.
  - 메서드 수가 많을 수록 단일 책임 원칙을 위반하지만 클라이언트 입장에서 클래스를 더 유연하게 사용할 수 있다.
  - 중복 코드를 방지하고 설계를 더 간단하게 만들 수 있기 때문에 유지 보수성이 향상된다.

## 블랙잭 미션 피드백 2
- 블랙잭에서 hit, blackjack, bust 등을 어떤 방식으로 계산해야 할지 감이 안잡히기 때문에 아웃 -> 인 방식으로 진행
- blackJack 게임 부터 구현해본다.
- enum은 카드를 한장 추가하는 등의 행위와 그 이후 상태를 변경하는 등의 기능을 가질 수 없으니까 다른 무언가로 만들어줘야 된다는 생각을 하게된다.
- 이 상태들을 관리하는 객체를 만들어보자!
- 결과에 따른 수익률 검증 테스트를 작성할 때 double 자료형들을 equal로 비교하면 안된다.
  - 부동소수점 이슈 발생!
- 테스트 코드에서 접근제어자를 디폴트까지 허용해주는 이유 : 페키지 내부에서만 사용된다는 확신이 들 경우 default 접근제어자를 사용할 수 있다.
- 이러한 경우 private 접근제어자처럼 다른 모든 객체들로부터 은닉화하려는 것이 아니라 패키지 내부에 위치한 클래스 객체들과만 메세지를 주고 받을 수 있도록 하는 것이다.
- 완전히 다른 객체에서의 호출을 금지하는 것이 아니기 때문에 허용해주는 것이 아닐까?


# 23.03.12

## [상태 패턴](https://tecoble.techcourse.co.kr/post/2021-04-26-state-pattern/)
### Enum
- Enum이란 서로 연관된 상수들의 집합이다.

### 상태 패턴이란?
- 특정 기능을 수행한 후 다음 상태를 반환하는 것
  - 상태 패턴은 나타내야 하는 상태가 많아지더라도 코드 복잡도가 증가하지 않는다.
    - 단순히 새로운 상태를 나타내는 클래스를 구현하면 된다.
  - 반면 Enum에서 조건문을 이용한 방식은 코드를 복잡하게 만들어 유지보수를 어렵게 한다.

### 상태패턴 적용
- 동일한 메서드가 상태에 따라 다르게 동작할 때 사용할 수 있는 패턴이다.
- 상태 패턴에서는 상태를 별도의 타입으로 분리하고 상태 별로 알맞은 하위 타입을 구현한다.
- 상태 패턴은 추상화된 동일한 메서드에 상태마다 다른 특정 기능을 수행한 후 다음 상태를 반환하는 것이 상태 패턴의 핵심이라고 볼 수 있다.
- 상태 패턴이란 객체지향 방식으로 상태 기계를 구현하는 행위 소프트웨어 디자인 패턴이다.
  - 상태 기계란 한 번에 오로지 하나의 상태만을 가지게 되며, 현재 상태(Current State)란 임의의 주어진 시간의 상태를 칭함.
- 상태 패턴의 장점은 새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향이 최소화 된다는데 있다.
  - 클래스를 새로 추가하더라도 기존 메서드 코드는 그대로 유지된다.
  - 또한 상태에 따른 동작을 구현한 코드가 상태 별로 구분되기 때문에 상태별 동작을 수정하기가 쉽다.

### 고려해야할 점
- 하나의 상태를 클래스로 명확하게 표현하는 것과 , 상태 변수로 표현하는 것 사이에서 장단점을 잘 저울질 해봐야한다.
  - 상태 패턴으로 리팩토링 한 이후가 더 복잡하다면 굳이 상태 패턴을 도입할 이유는 없다.
- 다뤄야 하는 상태의 개수만큼 관리해야 할 클래스가 늘어나는 것에 주의해야 한다. 경우에 따라서는 장점이 될 수도 있다.
- 각각의 상태별로 공통 메소드가 많다면 굳이 상태 패턴이 필요없을 수도 있다.
- 각 상태를 싱글톤으로 관리하는 것도 고려할 수 있다.


## 블랙잭 미션 리팩토링
- 피드백 시간에 배운 상태 패턴을 어떻게 적용해서 리팩토링할 것인가에 집중하자.
- User 객체들이 현재 들고있는 카드 정보를 갖고 있는 Hand 클래스 구현
  - 구현 도중 hand 내에서 가진 카드들의 점수 합을 계산하는 기능의 필요성이 대두
  - 기존 Score 기능 중 값 객체로써의 책임을 제외한 기능들을 hand로 이관
    - List 를 파라미터로 받아 점수를 계산하고 있다면, Cards 객체에서도 수행이 가능할텐데 분리한 이유가 무엇인지 질문드렸던 부분입니다 :)
      - 현재 구현된 Score 클래스는 생성자에서 Card 리스트를 받아 최종 점수를 계산하는 로직을 수행하고 있습니다.
      - Score 클래스를 단순하게 카드의 숫자 계산을 관리하는 값 객체 역할을 부여하기로 변경했습니다.
      - 이로 인해 Card를 받아서 최종 점수를 계산하는 것이 아니라 카드 숫자가 주어지면 이를 계산하는 책임만을 지도록 리팩토링을 진행했습니다.
- hand에 갖고 있는 카드들에 따른 상태를 나타내야 한다. => 상태 패턴을 적용해보자!
- blackjackgame 클래스에서 player와 dealer를 participants로 묶어주는 것만이 정답이었나?









