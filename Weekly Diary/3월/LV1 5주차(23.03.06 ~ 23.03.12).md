# 레벨 1 - 5주차 (23.03.06 ~ 23.03.12)

---

# 23.03.06

## chatGPT
- chat GPT를 사용할 때 답변에 대해 레퍼런스를 직접 물어보는 것도 방법이다!!!

## JVM 
[레퍼런스](https://catch-me-java.tistory.com/12)
- JVM 구성요소로는 3가지가 존재
  - 클래스 로더 시스템 (Class Loader)
  - 메모리 (JVM memory)
  - 실행엔진 (Execution Engine)

## Constant Pool

- 자바 클래스 파일 내부의 Constant Pool? 
  - [oracle 레퍼런스](https://blogs.oracle.com/javamagazine/post/java-class-file-constant-pool)
  - [string pool vs constant pool](https://stackoverflow.com/questions/23252767/string-pool-vs-constant-pool)
  - [JVM stack & frames](https://sanghoonly.tistory.com/62)
  - [오라클 JVM Frames](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)
  - [오라클 JVM Instruction set](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.dup)
  - [런타임 constant pool](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.5)
  - 특정 클래스 파일을 실행할 때가 오면 JVM은 클래스 파일을 찾아내고 load 한다. 
  - loading 프로세스는 클래스 파일 내 다양한 필드들을 Parsing 하는 것과 Parsing된 데이터들을 JVM의 Method 영역에 형식을 맞춰서 저장하는 것을 수반한다.
  - 메서드 영역은 변수, 메서드, 다른 아이템들에 대해 전 쓰레드가 공유하는 영역이다.
  - 클래스 파일 format은 자바 릴리즈 버전에 따라 계속 변화해왔다.
    - 파일 헤더 : 자바 클래스 파일이 생성된 자바 버전을 나타내는 바이트
    - 상수풀 : constant pool이라 불리는 중요한 영역
    - 추가적인 데이터 필드, 메서드, 일련의 속성들 등으로 이루어져 있다.
  - Introducing the Constant Pool
    - constant pool : 클래스 파일의 가장 중요한 영역 중 하나로 클래스에 대한 Symbol 분류표로서 제공되는 항목들의 집합이다.
    - constant pool은 참조되는 클래스들의 이름, 문자열, 숫자 상수들의 초기값, 그리고 적절한 명령 수행에 필수적인 기타 데이터들을 포함한다.
    - Constant Pool을 보기 위해서는 JDK에 포함된 javap 클래스 파일 디셈블러를 사용해라.
      - 결과 값을 보면 첫번째 index는 단순히 항목들의 entry 숫자이다.
      - 두번째 컬럼은 entry의 타입을 명시한다.
      - 세번째 컬럼은 entry의 값을 포함하고 있다. 
      - // 문자 이후 내용들은 javap가 무엇이 사용되고 있는지 표시하기 위해 얘기하고 있는 내용이다.
    - 아마도 이 결과 리스팅에 대해서 가장 충격적인 내용은 문자열 데이터들을 표시하기 위해 자바 클래스 내부에서만 사용되는 UTF-8타입의 entry 빈도수일 것이다.
    - 클래스 이름, 메서드 이름, 메서드 시그니처 등을 모두 utf-8 문자열로 저장한다.
  - 개인적인 정리
    - 자바에서 constant pool은 기본적으로 클래스 파일 내부에 존재하는 클래스 이름, **문자열 / 숫자 상수 초기값**, 그리고 기타 데이터들을 symbol 테이블로 저장한다.
    - 여기에서 문자열 리터럴들은 모두 constant pool에 utf-8로 타입으로 저장된다.
    - 정수형 리터럴 중 byte, short에 해당되는 값들은 미리 상수풀에(상수풀에 저장되는지는 아직 몰루?) 캐싱되어 있다. (자바버전 업그레이드에 따라 과거에 비해 변경된 사항임)
      - 그래서 byte, short에 해당하는 리터럴 값들은 바이트 코드에서 bipush/sipush 를 사용해 값이 operand stack에 push된다.
      - 그 이외 범위의 정수 리터럴들은 LDC를 사용해 런타임 상수풀에 저장되어 있는 리터럴 값을 operand stack에 push한다.(?몰루)
      - 40000 이라는 정수 리터럴은 미리 캐싱되어 있지 않기 때문에 컴파일 시 생성되는 constant pool에 등록된다.
      - 이후 LDC 컴파일 명령어를 통해 runtime constant pool에 저장되어 있는 40000이라는 값을 operand stack에 넣어준다.
    - runtime constant pool은 기존 클래스와 인터페이스 별 constant pool로부터 derived 된다.
    - runtime constant pool은 클래스 혹은 인터페이스의 constant pool 내 모든 symbolic reference들을 resolving하여 얻어지기 때문에
      - runtime constant pool은 정확하게 클래스 / 인터페이스의 constant pool이 가지지 않고 있는 일부 상수들도 포함하고 있다.
    - DUP 명령어는 operand stack에 최상단에 위치한 value를 복사해 다시 operand stack에 push 한다.
    - new 명령어는 새로운 객체를 생성하고 객체에 대한 레퍼런스를 operand stack에 push 한다.


## 블랙잭 미션 1차 피드백 정리

- map 객체를 사용하는데 키 값이 Enum이라면 EnumMap 사용을 고려하자. [레퍼런스](https://velog.io/@kasania/Java-EnumMap)
- Enum 안에서 map을 초기화 하는 방법 [레퍼런스](https://velog.io/@ljinsk3/Enum%EC%9D%98-%EC%9A%94%EC%86%8C%EB%A5%BC-%EC%A1%B0%ED%9A%8C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-vs-HashMap)
~~~ java
private static final Map<String, DrawCommand> inputDrawCommandMap = Collections.unmodifiableMap(Stream.of(values())
            .collect(Collectors.toMap(DrawCommand::getCommand, Function.identity())));  // 함수형 인터페이스 + 제네릭 공부를 해야하지 않을까...?
~~~















