# 레벨 1 - 5주차 (23.03.06 ~ 23.03.12)

---

# 23.03.06

## chatGPT
- chat GPT를 사용할 때 답변에 대해 레퍼런스를 직접 물어보는 것도 방법이다!!!

## JVM 
[레퍼런스](https://catch-me-java.tistory.com/12)
- JVM 구성요소로는 3가지가 존재
  - 클래스 로더 시스템 (Class Loader)
  - 메모리 (JVM memory)
  - 실행엔진 (Execution Engine)

## Constant Pool

- 자바 클래스 파일 내부의 Constant Pool? 
  - [oracle 레퍼런스](https://blogs.oracle.com/javamagazine/post/java-class-file-constant-pool)
  - [string pool vs constant pool](https://stackoverflow.com/questions/23252767/string-pool-vs-constant-pool)
  - [JVM stack & frames](https://sanghoonly.tistory.com/62)
  - [오라클 JVM Frames](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6)
  - [오라클 JVM Instruction set](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.dup)
  - [런타임 constant pool](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.5)
  - 특정 클래스 파일을 실행할 때가 오면 JVM은 클래스 파일을 찾아내고 load 한다. 
  - loading 프로세스는 클래스 파일 내 다양한 필드들을 Parsing 하는 것과 Parsing된 데이터들을 JVM의 Method 영역에 형식을 맞춰서 저장하는 것을 수반한다.
  - 메서드 영역은 변수, 메서드, 다른 아이템들에 대해 전 쓰레드가 공유하는 영역이다.
  - 클래스 파일 format은 자바 릴리즈 버전에 따라 계속 변화해왔다.
    - 파일 헤더 : 자바 클래스 파일이 생성된 자바 버전을 나타내는 바이트
    - 상수풀 : constant pool이라 불리는 중요한 영역
    - 추가적인 데이터 필드, 메서드, 일련의 속성들 등으로 이루어져 있다.
  - Introducing the Constant Pool
    - constant pool : 클래스 파일의 가장 중요한 영역 중 하나로 클래스에 대한 Symbol 분류표로서 제공되는 항목들의 집합이다.
    - constant pool은 참조되는 클래스들의 이름, 문자열, 숫자 상수들의 초기값, 그리고 적절한 명령 수행에 필수적인 기타 데이터들을 포함한다.
    - Constant Pool을 보기 위해서는 JDK에 포함된 javap 클래스 파일 디셈블러를 사용해라.
      - 결과 값을 보면 첫번째 index는 단순히 항목들의 entry 숫자이다.
      - 두번째 컬럼은 entry의 타입을 명시한다.
      - 세번째 컬럼은 entry의 값을 포함하고 있다. 
      - // 문자 이후 내용들은 javap가 무엇이 사용되고 있는지 표시하기 위해 얘기하고 있는 내용이다.
    - 아마도 이 결과 리스팅에 대해서 가장 충격적인 내용은 문자열 데이터들을 표시하기 위해 자바 클래스 내부에서만 사용되는 UTF-8타입의 entry 빈도수일 것이다.
    - 클래스 이름, 메서드 이름, 메서드 시그니처 등을 모두 utf-8 문자열로 저장한다.
  - 개인적인 정리
    - 자바에서 constant pool은 기본적으로 클래스 파일 내부에 존재하는 클래스 이름, **문자열 / 숫자 상수 초기값**, 그리고 기타 데이터들을 symbol 테이블로 저장한다.
    - 여기에서 문자열 리터럴들은 모두 constant pool에 utf-8로 타입으로 저장된다.
    - 정수형 리터럴 중 byte, short에 해당되는 값들은 미리 상수풀에(상수풀에 저장되는지는 아직 몰루?) 캐싱되어 있다. (자바버전 업그레이드에 따라 과거에 비해 변경된 사항임)
      - 그래서 byte, short에 해당하는 리터럴 값들은 바이트 코드에서 bipush/sipush 를 사용해 값이 operand stack에 push된다.
      - 그 이외 범위의 정수 리터럴들은 LDC를 사용해 런타임 상수풀에 저장되어 있는 리터럴 값을 operand stack에 push한다.(?몰루)
      - 40000 이라는 정수 리터럴은 미리 캐싱되어 있지 않기 때문에 컴파일 시 생성되는 constant pool에 등록된다.
      - 이후 LDC 컴파일 명령어를 통해 runtime constant pool에 저장되어 있는 40000이라는 값을 operand stack에 넣어준다.
    - runtime constant pool은 기존 클래스와 인터페이스 별 constant pool로부터 derived 된다.
    - runtime constant pool은 클래스 혹은 인터페이스의 constant pool 내 모든 symbolic reference들을 resolving하여 얻어지기 때문에
      - runtime constant pool은 정확하게 클래스 / 인터페이스의 constant pool이 가지지 않고 있는 일부 상수들도 포함하고 있다.
    - DUP 명령어는 operand stack에 최상단에 위치한 value를 복사해 다시 operand stack에 push 한다.
    - new 명령어는 새로운 객체를 생성하고 객체에 대한 레퍼런스를 operand stack에 push 한다.




# 23.03.07

## 블랙잭 미션 1차 피드백 정리

- map 객체를 사용하는데 키 값이 Enum이라면 EnumMap 사용을 고려하자. [레퍼런스](https://velog.io/@kasania/Java-EnumMap)
- Enum 안에서 map을 초기화 하는 방법 [레퍼런스](https://velog.io/@ljinsk3/Enum%EC%9D%98-%EC%9A%94%EC%86%8C%EB%A5%BC-%EC%A1%B0%ED%9A%8C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-vs-HashMap)
~~~ java
private static final Map<String, DrawCommand> inputDrawCommandMap = Collections.unmodifiableMap(Stream.of(values())
            .collect(Collectors.toMap(DrawCommand::getCommand, Function.identity())));  // 함수형 인터페이스 + 제네릭 공부를 해야하지 않을까...?
~~~

## player 내부의 isWinner 관련 리팩토링
- player와 dealer의 score 상태값을 이용하여 결과를 계산하는 GameResult 클래스를 구현 예정
- 그 전에 전체 player들의 상태와 행위를 관리하기 위한 일급 컬렉션 players를 구현하기로 결정
- player 생성의 책임을 players 내부로 이관 결정
- player 생성 시 카드를 처음부터 받지 않고 나중에 받을 수 있도록 변경 (추상클래스 user 차원에서 기능 변경)
  - user가 소유한 카드가 없을 시에 예외처리 수행해주기.
- player가 생성 시 카드를 가지고 있지 않게 되므로 score 상태 값 외부로 분리
  - User 게임의 점수를 전반적으로 관리하는 GameScore 클래스로 분리 
- 기존 cards 클래스를 사용자의 패 정보를 관리하는 클래스로 변경하고 내부에 가진 카드의 점수를 가질 수 있도록 변경
- 기존 cards 클래스가 수행하던 덱 정보 관리 기능은 Deck 클래스를 새로 생성하기
- User가 가지고 있는 카드 정보를 가지고 있는 Hands 클래스 구현
  - score 계산 기능을 hands 내부 상태값으로 변경하기?
  - user hands와 dealer hands를 이용해 score 비교 기능 추가하기
- 플레이어와 딜러의 승/패를 판단하는 referee 클래스 구현(?)
- BalckJackGame 클래스는 어떤 역할을 해야하는가?
  - 현재 게임 결과를 판단하는 기능을 분리하고 나니 유저들에게 카드를 분배하는 기능 말고는 담당하는 기능이 없다.
- 도메인에서 주고받는 메세지는 원시타입 값이 아닌 포장된 객체여야 한다. -> 이름 값이 메세지로 주고 받아질 때 string이 아닌 Name 객체로 주고 받아지도록 수정
- 게임에서 현재 덱을 관리하는 기존 Cards 클래스를 Deck 클래스로 변경
  - 테스트 코드 수정 과정에서 shuffle 기능 테스트를 위한 전략 패턴 구현

- GameResult 클래스에서 Player와 Dealer의 정보를 받아 게임 결과 계산
  - 과연 구현한 GameResult 객체를 어디에서 생성해서 사용해야 하는가?
  - 전체적으로 리팩토링해야할 부분이 너무 많아서 일단 기존 BlackJackGame 클래스에서 결과를 계산하던 기능을 이관하는 것만 진행하기로 결정.

- 게임 상에서 동명이인은 없는 것으로 결정
- 즉 같은 이름은 동일한 사람으로 취급되어야 함
  - Name 클래스 내에 equals & hashCode 오버라이딩

- 인터페이스를 정의한 이유?
  - User 클래스를 상속하는 Player와 Dealer는 각각 PlayerStatus, DealerStatus 상태 값을 이용하여 자신이 어떤 상태인지 관리하고 있습니다.
  - player와 dealer가 공통적으로 자신의 상태를 외부에서 메세지를 보냄으로써 확인할 수 있도록 하려고 했습니다.
  - 그러나 해당 기능을 User 추상 클래스에 구현하려고 보니 Player와 Dealer의 상태 값 Enum 클래스가 달라서 추상 메서드를 정의해주기가 애매했습니다.
  - 그래서 시간 관계상 깊게 고민하지 못하고 PlayerStatus와 DealerStatus가 UserStatus라는 인터페이스를 상속받게 함으로써 이를 해결해보고자 했습니다.
  - 그러나 막상 UserStatus 인터페이스에 명시할만한 기능은 존재하지 않아 이런 결과를 낳게 되었습니다.
  - 어떤 방식으로 리팩토링 해야할 지 아직 감이 잘 안 잡히는데 이런 경우라면 차라리 추상 메서드 선언을 포기하고 인터페이스를 삭제하는 방향이 좋을지 고민입니다.

안녕하세요 코즈! 히이로입니다.

1차 리뷰에 대한 리팩토링이 개인 사정으로 인해 많이 늦어졌습니다. 죄송합니다 😭

먼저 말씀드리고 싶은 부분은 처음에도 말씀드렸다시피 페어 미션 과정에서 워낙 급하게 구현하느라 이전 미션에서 배운 부분이나 이번 미션에서 주어진 요구사항들 중 지키지 못하고 놓친 부분들이 많습니다. 거기에 코즈가 1차적으로 달아주신 리뷰들을 보며 리팩토링을 어떻게 해야할지 고민하다보니 고치고 싶은 부분이 너무 많이 보이는 것 같아요.

그러나 지금 코드를 전부 엎어가며 리팩토링을 진행하기엔 저나 리뷰어인 코즈에게도 좋은 것은 아닌것처럼 느껴져서 1차적으로 리뷰 주신 부분들만 최대한 집중해서 리팩토링을 진행했습니다. 제 개인적인 의견으로는 2차 미션을 병행하면서 전반적으로 놓친 부분들을 수정하는 것이 좋아보이는데 코즈의 의견은 어떠신지 궁금합니다.

혹시 1단계에서 반드시 짚고 넘어가야할 부분이 있거나  제가 놓친 것이 있다면 알려주시면 감사하겠습니다. 🙇

## 블랙잭 미션 피드백 1
- 좋은 객체의 7가지 덕목 레퍼런스 읽어보자!
- 기본적인 요구사항 정리
- 카드 클래스가 가장 작은 엔티티라고 판단이 된다.
  - 카드를 구현하기 전에 도메인 용어를 파악하기 위해 검색해보는 것도 좋다. (suit, denomination, hand 등...)
  - 네오는 맨 처음 TDD를 하면서 create 테스트 부터 한다. 생성자로 객체를 생성하고 toString 오버라이딩을 통해 내부에 적절한 데이터가 들어있는지 확인 (assertDoesNotThrow) 네오는 toString을 무조건 구현하는 편이라고 함
    - 생각해보면 toString을 디버깅 용도로 사용하는 케이스도 여기에 해당하지 않나 생각된다.
    - 처음에 시작할 떄는 생성 테스트를 해주는 것도 좋겠다.
  - 52개 카드를 매번 생성할 필요가 있을까? -> 캐싱을 해보자!
    - concurrentHashMap 사용?? private static final 로 클래스 변수로 사용한다.
    - computeIfAbsent 메서드 사용
    - 정적 팩토리 메서드를 사용하면 기타 생성자의 접근 제어자를 private화 하는 것이 좋다. (캐싱을 해뒀는데 기본 생성자로 카드를 생성해버리면 안된다.)
- 추상 클래스와 구현 클래스를 구분하기 위해 구현 클래스에는 final 선언을 해주는 것이 좋다.
- Hand 클래스는 card 객체들을 갖는 일급 컬렉션
  - Hand 클래스의 생성자를 여러개 만드는데 이것이 과연 좋은 걸까? 이번 학습자료에 내용 나와있으니 고민해보자.
  - hand 클래스를 구현하다 보니 score 관련 기능이 많이 나온다. 값 객체 분리를 생각해볼 때!
  - 클래스 변수가 상수의 역할을 하지 않는다면 굳이 대문자 컨벤션을 지킬 필요는 없는 것 같다.
  - 네오는 primitive 타입이 아니면 전부 상수 네이밍 컨벤션을 지키지 않는다고 한다.
  - 일급 컬렉션 내부 리스트를 외부로 반환할 때도 방어적 복사를 잘 취해서 불변을 보장하도록 하는 것이 좋다.
- 두 도메인에서 공통되는 기능들을 뽑아내서 인터페이스, 추상클래스로 구현할 수 있다.

# 23.03.08

## 데이터베이스 공통 강의
- 우리가 www.naver.com을 검색하면 서버에 네이버 index.html 파일을 요청하는 것이다.
- url 에서 물음표 뒤에 오는 것들을 쿼리 스트링이라고 한다.
  - 트래킹 URL이 있다는데 뭘까나...?
- post 명령 수행 시 http 바디에 데이터를 담아 전송하게 된다.
  - 데이터가 노출되지 않는다고 하는데 사실 개발자 도구로 까보면 전부 확인할 수 있다.
  - 따라서 별도로 암호화를 챙겨줘야 한다.
- 리다이렉션
  - 301의 경우 영구이동으로 보고 이전 URL을 보여주지 않았는데
  - 302의 경우 임시이동이라 예전 URL을 띄워주는 방식으로 진행되었기에 이와 관련된 이슈도 있었다.
    - 유명 사이트의 비슷한 url을 사서 301리디렉션을 걸어버리는 것.

- 파일시스템
  - 기존 파일 시스템이 가지고 있는 단점을 해결하기 위해 등장한 것이 데이터 베이스이다.

- ERD : 현실에서 개체들 간 관계를 컴퓨터로 가져와 표현하는 방식

- 연산자에서 where title like '%해리포터%' 라고 하면 앞 뒤를 제외하고 해리포터가 포함된 제목들 데이터를 쿼리한다.

- SQL 시뮬레이션 페이지 URL : https://www.w3schools.com/sql/trysql.asp?filename=trysql_asc
- 설문 1번 문제
- 200개 이상 팔린 상품명과 그 수량을 수량 기준 내림차순으로 보여 주세요.
~~~ SQL
SELECT ProductName, SUM(Quantity)
FROM Products AS p
INNER JOIN OrderDetails AS od ON od.ProductID = p.ProductID
GROUP BY p.ProductID
HAVING SUM(Quantity) > 200
ORDER BY SUM(Quantity) DESC;
~~~

- select 문에서는 각 컬럼 값들에 대해 sum, count, min/max 등의 기능 수행이 가능하다.
- groupBy 연산이 select보다 먼저 수행되기 때문에 groupBy 이후에 사용되는 select문 내 연산들은 각 그룹별로 그룹핑된 데이터들에 각각 적용된 결과가 나온다.

- 설문 2번 문제
- 많이 주문한 순으로 고객 리스트(ID, 고객명)를 구해 주세요.
~~~ SQL
SELECT c.CustomerID, CustomerName
FROM Customers AS c
INNER JOIN Orders AS o ON o.CustomerID = c.CustomerID
GROUP BY c.CustomerID
ORDER BY SUM(OrderID);
~~~

- inner join 사용 시 중복되는 컬럼이 두 테이블에 모두 존재할 경우 select문에서 어떤 테이블의 값을 가져와서 표시할지 명시해줘야 된다.

- 설문 3번 문제
- 많은 돈을 지출한 순으로 고객 리스트를 구해 주세요.
~~~ SQL
SELECT c.CustomerID, CustomerName
FROM Products as p
INNER JOIN OrderDetails as od ON p.ProductID = od.ProductID
INNER JOIN Orders as o ON o.OrderID = od.OrderID
INNER JOIN Customers as c ON c.CustomerID = o.CustomerID
GROUP BY c.CustomerID
ORDER BY SUM(p.Price*od.Quantity) DESC;
~~~

## 리스트 미션 진행하기
- java.util.List Interface
  - List 자체는 인터페이스구나!
  - 대표적인 구현체로 ArrayList와 LinkedList가 존재
  - List는 배열에서 지원하지 않는 많은 기능들을 제공하기 때문에 배열보다는 List를 사용하는 것이 좋다.
- ArrayList와 LinkedList의 차이
  - 사용 방법은 같으나 데이터를 저장하는 방식에 차이가 있다.



















