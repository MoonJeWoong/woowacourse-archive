# 레벨 1 - 7주차 (23.03.20 ~ 23.03.26)

---

# 23.03.20

- 면담 설문 작성
- 면담을 통해 논의하고 싶은 내용
  - 레벨 1을 지나오면서 굉장히 많은 것들을 접하고 배웠던 것 같습니다. 
  - 자바 그 자체에 대해서도 많이 배웠지만 여러 디자인 패턴에 대해서도 배우고 비개발적인 요소에 대해서도 생각할 수 있었던 시간이었습니다. 
  - 다만 한가지 마음에 걸리는 게 있습니다. 이래저래 미션에 치이다 보니 이론적으로 머리에 쌓이는 지식이 많다는 생각은 들지 않았던 것 같아요. 
  - 물론 이런 부분을 방지하기 위해 필독서가 있다고 생각해요. 하지만 미션을 진행하다보면 책을 읽을 엄두를 못내고 있는게 현실인 것 같습니다.  
  - 너무 미션에만 집중하게 되는 것이 부정적인 요소로 작용하는 걸까요? 
  - 머리로는 독서를 통한 이론적 학습과 미션을 통한 실습이 병행되어야 한다는 것을 알고 있지만서도 항상 일정에 치이다 보면 이론적 학습이 뒤로 밀리는 경우가 일상 다반사입니다. 
  - 과제와 학습 사이의 밸런스 문제를 의식적으로 해결해보고 싶은데 어떤 방식으로 하면 좋을지 논의하고 싶습니다.

- 최근 자신이 긍정적으로 보는 시도와 변화
  - 밀린 미션을 처리하고난 후 약간의 시간이 날 때 어떻게든 책을 펴보려고 했다.
  - 미션에 부족한 부분이 보여도 일단 데드라인에 맞춰서 제출한다.

- 이번 면담을 통해 어떤 변화가 생기기를 원하는지
  - 데드라인이 있는 과업과 자기주도적인 학습 사이에서 밸런스를 맞추고 지속 가능한 학습을 진행하고 싶습니다.

추가사항
- 레벨 1이 거의 끝나가는데 아직 여기서 하고 가야할 게 너무 많은 것 같다. 그럼에도 앞에 해나가야 할 것들도 많다. 이런 것들을 어떻게 해나가야 할까.



### 블랙잭 미션 2차 피드백 정리
- 상태 패턴을 적용한다고 무조건 좋은 구조가 되는 것은 아니다.
  - 블랙잭 미션의 요구사항을 분석하면서 블랙잭의 도메인을 상태로써 추상화해 인지하고 있고 그에 맞게 객체를 모델링해 적용했다고 한다면 문제가 없다.
  - 반대로 블랙잭 도메인을 바라보는 시선이 정의한 상태들과 맞지 않는다면 코드를 이해하기 힘들어진다.
  - 즉 객체의 모델링 이전에 디자인 패턴이 선행하면 안된다.
  - 블랙잭 도메인을 상태 패턴을 적용하기 적합한 구조로 생각하고 있는지 고민해보자.

- getter 사용에 대하여
  - getter를 사용하지 않을 수 있는 상황에서 사용하게 되면 객체지향으로 얻을 수 있는 이점을 취할 수 없기 때문에 getter 사용을 지양하는 것이다.
  - 필수 불가결한 getter만 존재한다면 문제가 없지 않을까

-  unwarp을 컨트롤러에서 수행해야하는 이유가 있나요? View는 Domain을 알아선 안된다고 생각하시나요?
  - view에서 도메인을 알게 되면 외부로 드러나지 말아야 할 정보들이 같이 노출되는 위험이 발생하게 된다.
  - 예를 들어 회원 아이디, 비밀번호, 나이, 이름 등의 신상정보가 있는 user 도메인을 그대로 넘긴다면 개발자 도구에서 중요 정보를 조회할 수 있다.
  - 이러한 이유때문에 view와 도메인을 분리한다고 생각한다.
  - 이전에는 도메인 로직 단에서 원시타입 상태 값이 이용되어야 하는 경우 값을 포장한 객체에서 내부 값을 꺼내는 것이 아니라 포장한 객체 자체로 사용되어야 한다고 생각했습니다.
  - 예를 들어 게임 참여자의 이름이 필요한 기능을 수행할 때 string 원시타입 값을 사용하는게 아니라 Name 값 객체 자체를 사용해 수행할 수 있어야 한다고 생각했습니다.
  - 위에서 명시한 두 가지 이유로 참여자의 이름 정보를 얻어오기 위한 getter를 열 때 도메인에서 사용하기 위한 Name 값 객체를 반환할 지 view에서 사용하기 위해 String을 반환해야 할 지 고민이 되었습니다.
  - string을 반환하는 getter로 여는 경우 도메인에서 원시타입 값을 이용해 비즈니스 로직을 수행한다는 생각이 들었고 이를 지양하고자 했습니다.
  - 그러다 보니 값 객체를 반환하도록 getter를 열었고 view에서 사용할 때 이를 unwrap 해주는 책임을 어디에선가는 반드시 져야만 했습니다.
  - 원래는 이 책임을 view에서 지도록 해서 view가 도메인에 의존하도록 했습니다. 하지만 위에서 언급한 대로 view가 도메인에 의존하는 경우에도 문제점은 존재했습니다.
  - 그리고 이 책임을 view, domain 모두 지지 않도록 하려고 하다보니 결국 이렇게 컨트롤러가 질 수 밖에 없었습니다.
  - 다만 코즈가 리뷰해주신 대로 unwrapCard 메소드에서 ,로 join 하는 것은 컨트롤러가 뷰의 책임을 침범한 것이라는 데 동의합니다.
  - unwrapCard 메서드의 반환 타입을 List<String>로 수정했습니다.

- 이번 리팩토링을 진행하면서 dto의 사용을 고려하게 되었습니다.
  - controller에서 값 객체를 unwrap 해주는 책임이 이전 미션에 비해 증가했습니다.
  - 또한 여러 값을 한 번에 view에 전달해야 하는 경우가 발생했기에 이를 map 자료구조를 사용해 전달하는 방식을 사용했습니다.
  - 여기에서 여러 값 객체를 unwrap 하여 한 번에 view에게 전달할 수 있는 역할을 수행할 객체의 필요성을 느꼈습니다.
  - 이러한 사고과정을 통해 dto를 도입해보기로 결정했습니다.

- domain 객체 외부에서 출력을 위한 용도로 내부 상태 값을 필요로 하는 경우 Dto를 만들어 반환할 수 있도록 리팩토링 했습니다.

- 인터페이스에 대고 프로그래밍하기
  - LinkedHashMap 구현체를 객체로 생성해서 사용할 때 변수 타입을 HashMap 구현체로 선언하는 것이 아니라 인터페이스 클래스인 Map으로 선언해줘야 한다.
  - 추상화된 인터페이스 타입이 아닌 실제 구현을 제공하는 타입을 이용해서 프로그래밍하는 경우 구현에 변화가 생겼을 떄 변화의 영향력이 이곳 저곳으로 퍼져 나간다.

- BlackjackGame 혹은 Map<Name, Integer> 를 감싸는 객체에서 딜러의 상금을 계산해줄 수 있을것 같아요.
  현재는 딜러의 상금을 계산하는 비지니스 로직을 Controller에서 수행하고 있는 것 같습니다


- user에서 status를 통해 최종 결과에 따른 profitRatio 반환 메서드 구현
  - players에서 이름을 매개변수로 profitRatio 반환하도록 구현
  - betting 관련 변수 및 기능 User에서 삭제
- 게임 결과를 계산해서 이름 별 수익금을 저장하는 GameResult 리팩토링
  - 외부에서 플레이어들의 베팅 금액 정보를 받아서 초기화
  - 나중에 게임이 다 진행되면 딜러와 플레이어를 외부에서 받아서 승패 각각 판단
  - 기존 저장되어 있던 베팅 금액에 승패 결과에 따른 배당률 계산해서 다시 저장
  - getPrizeResultDtosForAllUsers 메서드에서 name과 name별 상금 결과 담아서 반환

- getter를 사용하여 score를 비교하는게 아니라, User 객체에게 비교하는 메서드들을 만들어줄수도 있을것 같네요
  - 코즈 의견에 동의합니다. 리팩토링 과정을 거치면서 User 객체 간 점수 비교 기능은 User 내부에서 비교할 수 있도록 메서드를 작성하여 수정했습니다!



### 솔라의 데일리 미팅 중 느낀 점
- 태스크를 하며 추가되는 사항들을 인지를 못해서 일장 추산이 안되는 구나
- 늘어나는 건 오케이 좋은데 그걸 늘어난 거라고 인정하고 일정 조정을 해야되는데 그걸 못한다.

## 23.03.21

### 체스 피드백 1

- 폰의 움직임을 봤을 떄 높은 수준의 추상화를 하는 것은 불가능했다.
- 양방향의존성 문제가 발생하는 Piece와 pieces 관계인데 트레이드 오프를 택했다고 네오는 말했다. 원칙을 깨더라도 자신이 편하게 구현하기 위해 코드를 구현했다.
- 단순위임 기능을 수행하는 메서드도 테스트해야하는가?
  - naive 하게 생각하면 실제 기능을 테스트하는 코드가 존재하는데 이것을 단순하게 호출하는 단순위임 메서드도 테스트코드를 왜 작성해야 하나 생각할 수 있지만
  - 현 시점에서 단순위임 메서드라고 하더라도 이후에는 변화될 가능성이 존재한다. 여기에 대해 안정성을 보장하고자 한다면 테스트를 작성하면 된다.
- 네오는 객체로 볼수 있는 것들은 최대한 객체로 바라보려고 한다. 그래서 최대한 객체로서 바라보려고 하는 것이 좋은 연습일 수 있다.
- 상속을 했을 떄 캡슐화가 깨졌는지 확인해보려면 인터페이스 처럼 사용될 수 있는지 확인해보자.
- 부모 추상 클래스에 구현된 protected 메서드를 하위 자식 클래스에서 호출하는 것도 캡슐화가 깨지는 것인가요?
  - 깨지는 것이 맞다 하지만 깨지는 것이 항상 나쁜건 아니다. 깨질때 얻는 것이 뭐가 있는지 생각해보고 결정하면 된다.

- 객체 간 협력을 위해서는 메세지를 주고받는다고 말합니다. 
  - 그런데 이 메세지의 내용을 정의하다보면 이게 다른 객체로 보내서 처리하도록 해야하는 내용인지 아니면 해당 객체 내부에서 처리해야 하는 내용인지 애매해질 때가 있던 거 같아요. 
  - 결국 객체 간 책임 분배의 문제와도 같은 얘기라고 생각은 듭니다. 
  - 네오는 어떤 메세지가 객체 간 주고 받아져야만 객체 간 협력이 잘 이뤄지고 있다고 판단하시는 지 질문드립니다.
    - 개인의 선택 영역이다. 체스판에서 말을 움직일 수 있고, 말이 직접 자기의 위치를 움직을 수도 있다.
    - 처음엔 말이 위치를 관리하는 것이 너무 알아야 하는 외부 정보가 많아서 체스판에 부여할 수 있다.
    - 그런데 프로젝트 요구사항이 추가되면서 체스판 책임이 과도해진다면 다시 말에게 책임을 옮길 수도 있다.

- 객체적 설계를 의식적으로 연습하는 방법 : 프로그래밍 요구사항으로 주어진 사항들이 왜 주어지는 지 생각해보고 연습하면 된다.
  - 그리고 이 요구사항들의 등장 이유와 준수하는 것을 다 연습했다는 판단이 들면 아래 원칙들을 공부하고 넘어가서 봐보자.
    - https://www.nextree.co.kr/p6960/
      https://nesoy.github.io/articles/2019-05/GRASP-Pattern 를
- https://github.com/orgs/woowacourse-precourse/repositories 성장이 안느껴질때는 여길 들어가보자 - 토미

### 솔라와의 면담

- 면담 설문 작성
- 면담을 통해 논의하고 싶은 내용
  - 레벨 1을 지나오면서 굉장히 많은 것들을 접하고 배웠던 것 같습니다.
  - 자바 그 자체에 대해서도 많이 배웠지만 여러 디자인 패턴에 대해서도 배우고 비개발적인 요소에 대해서도 생각할 수 있었던 시간이었습니다.
  - 다만 한가지 마음에 걸리는 게 있습니다. 이래저래 미션에 치이다 보니 이론적으로 머리에 쌓이는 지식이 많다는 생각은 들지 않았던 것 같아요.
  - 물론 이런 부분을 방지하기 위해 필독서가 있다고 생각해요. 하지만 미션을 진행하다보면 책을 읽을 엄두를 못내고 있는게 현실인 것 같습니다.
  - 너무 미션에만 집중하게 되는 것이 부정적인 요소로 작용하는 걸까요?
  - 머리로는 독서를 통한 이론적 학습과 미션을 통한 실습이 병행되어야 한다는 것을 알고 있지만서도 항상 일정에 치이다 보면 이론적 학습이 뒤로 밀리는 경우가 일상 다반사입니다.
  - 과제와 학습 사이의 밸런스 문제를 의식적으로 해결해보고 싶은데 어떤 방식으로 하면 좋을지 논의하고 싶습니다.

- 최근 자신이 긍정적으로 보는 시도와 변화
  - 밀린 미션을 처리하고난 후 약간의 시간이 날 때 어떻게든 책을 펴보려고 했다.
  - 미션에 부족한 부분이 보여도 일단 데드라인에 맞춰서 제출한다.

- 이번 면담을 통해 어떤 변화가 생기기를 원하는지
  - 데드라인이 있는 과업과 자기주도적인 학습 사이에서 밸런스를 맞추고 지속 가능한 학습을 진행하고 싶습니다.

추가사항
- 레벨 1이 거의 끝나가는데 아직 여기서 하고 가야할 게 너무 많은 것 같다. 그럼에도 앞으로 해나가야 할 것들도 많다. 이런 것들을 어떻게 해나가야 할까. 
- (현업자가 되어서도 계속 고민이 될 것 같은데 어떤 식으로 해나가는지 궁금하다.)
  - 프롤로그에 등재된 자바 자체 키워드 학습 및 정리
  - 객체 지향적 설계 의식적 연습
  - 위 사항들이 어느정도 학습됐다고 느껴졌을 때 solid, grasp 등의 원칙 및 패턴 학습

- 어제 솔라가 데일리 호스팅을 했을 때 일정 추산을 해보고 실제로 하루를 살아봤다. 
- 그런데 6시간 정도면 그래도 블랙잭 미션을 마무리할 수 있지 않을까?라고 예상한 것과 다르게 11시까지 남아서 진행했음에도 끝내지 못했다.
- 처음 일정 추산을 진행할 때 잡은 소요 시간보다 더 오래 걸렸던 이유를 혼자 생각해봤다.
- 첫째는 전날 새벽 늦게까지 미션을 진행하고 잠을 잘 자지 못한 상태였기 때문에 평소보다 낮은 효율로 진행했기 때문이다.
- 둘째는 한 태스크를 처리하는 도중 추가되는 다른 태스크들이 분명히 있는데 인지하지 못하고 하나의 태스크라고 인지했기 때문이다.
- 첫째 이유야 컨디션 관리 문제니까 그렇다 치겠는데 둘째 이유는 다시 여러가지로 나뉘어 고민이 됐다.
- 어떤 태스크를 진행하며 발생한 혹은 추가된 태스크들을 어떻게 판단해야 할까
  - 추가되는 태스크들 중 일부는 기존 진행하던 태스크에 반드시 선행되어 처리되어야 하는 것들이 있을 것이고
  - 다른 일부는 기존 진행하던 태스크보다 후순으로 처리되어도 되는 것들이 있을 것이다.
- 여기서 기존 태스크에 선행되어야 하는 태스크가 추가 발생했을 때 일정조절이 잘 안되는 것 같다.

면담내용 정리
- 이론적 학습을 하고 실습을 하는 것이 더 잘 맞는지, 실습을 일단 먼저 해보고 그 다음 이론적 학습이 이어지는 것이 더 좋은지는 개인의 스타일 차이이다.
- 레벨 1을 진행하면서 책을 읽을 필요성을 강하게 느꼈다면 잘 경험한 것.
- 일주일 가용 시간을 계산해서 일주일에 이 정도는 책 읽는데 투자할 수 있겠다! 고정시간을 정해두고 진행해보자.
- 일주일에 고정시간 모여서 혹은 각자 자기 할 것을 진행하는 스터디를 만들어서 자율적인 강제성을 부여해보자.
- 내가 계획한 대로 이론과 실습을 parallel 하게 진행해보고, 이게 두 마리 토끼를 다 잡기는 힘든 것 같다고 판단이 든다면 비중을 조절하는 식으로 진행해보자.
- 스토리 라인이 있는 책이 아니라면 먼저 책을 읽어본 크루에게 가장 재밌있던, 중요했던 단원이 어디였는 지 물어보고 거기부터 읽어나가는 식으로 읽어보자
  - 좋코 나코는레벨 1에서 읽어야 하는 책 1권만 추천한다면 이걸 추천하겠다 했을 때 코치들 사이에서도 이견이 갈렸던 책이다.
  - 그렇기 떄문에 지금 읽고, 나중에 10개월이 지나서 읽고, 현직자로 시간이 지나서 읽을 때 다 다가오는 느낌이 다를 수 있다.
  - 책을 읽는데 너무 안 와닿고 머리에 들어오지 않는다면 지금 나에게 필요한 책이 아니구나라고 판단해볼 수 있지 않을까


## 23.03.22
### 4기와의 수다 타임

#### 블링의 우테코 10개월 동안 잘한일 베스트 5
- 꾸준한 등하교 루틴
  - 등하교시에 기술블로그 글 or 유튜브 
  - 노트북은 캠퍼스에 두고다님
  - 나는 패캠 강의를 듣고 오자마자 정리해서 올리는 학습을 먼저 해보자!
  - 레벨 3때 부터는 하교 전에 개발일지를 무조건 작성했다.
  - 오늘 한 일, 잘한 일, 아쉬운 일, 내일 목표 정리
- 건강과 행복에 투자하기!!
  - 비타민, 영양제는 기본, 홍삼, 한약 등등
  - 밥 잘 챙겨먹기, 소확행 등등
  - 꾸준하게 취미를 계속했다. 밴드 , 게임기획/제작, 영화책 모임
- 스터디는 필요할 떄 한다!
  - 미션, 프로젝트를 하면서 필요한 공부를 하는 것으로도 충분히 바빴다.
  - 나중에 필요에 따라서 한, 두 개씩 참여
  - 이건 따로 더 공부하지 않으면 모르겠는데? , 이건 어떻게 해야 할 지 감이 안잡히는데 다른 사람들은 이걸 어떻게 준비하지?
- 더 깊이 공부하기
  - 한번에 끝장을 보고 다른걸 외면하고 집착하지 않는다.
  - 모르겠으면 일단 넘어가고, 다음 번에 이 개념을 다시 만나거나 자료를 발견했을 때 그때 다시 탐구
  - 하나씩 깊이를 깊게 하다보면 여러 개념들이 엮이는 부분들이 있다. (A때문에 B일 수밖에 없겠구나)
  - 나만의 스토리 만들어내기, 단순한 복붙 글이 아닌 나만의 해석과 정리가 들어간 글
  - 양보다는 질, 적당한 꾸준함으로 좋은 글을 쓰자.
  - 이거 하나만큼은 경력자(면접관)보다 최신 정보를 빠삭하게 알고 있는걸 목표로 해보자(목표만...ㅎㅎ)
- 사람들을 잘 활용하기
  - 코치님들
    - 면담, 잡담, DM 등등 고민상담, 도움이 필요할 때 열심히 활용하기 
    - 열심히 말을 따라보기(강의, 면담 등등)
  - 리뷰어님들
    - 열심히 질문하고 최대한 많은 것을 얻으려고 노력
    - 리뷰에 대해 공부하고 더 좋은 질문을 하려고 노력
    - 내 생각이 코드로 잘 전달이 되는가에 대한 고민
    - 내 코드에 대한 최소한의 고집
  - 주변 크루들
    - 좋은 선생님, 좋은 청중, 동료가 되기도 한다.
    - 지금만큼 질문과 소통, 수다가 자유롭던 때가 그립다.
    - 단순히 내 분야에만 갇히지 않고 전체 서비스, 프로세스를 이해하는 데 도움
    - 나중에 프로젝트에 들어가서 여러 분야의 사람들과 잘 친해져 보자!
  - 선배 크루들
    - 어찌보면 가장 우리를 잘 이해할 수도 있는 사람들
    - 고민이 있거나 궁금한게 있다면 언제나 편하게 연락달라 (블링)
- 지금 이 과정은 어디 가서도 다시 즐길 수 없으니 지금 이 순간을 최대한 즐겼으면 좋겠다!
- 사람들을 얻었고, 사람들과 소통하는 방식을 배워갈 수 있던게 제일 큰 무기가 될 수 있었다.

#### 연로그의 미래를 대비하는 방법
- 무엇이 궁금하냐? -> 취직이 궁금하다
- 개발자로서 중요한 것
  - 시니어와 신입 개발자의 차이는 뭘까?
  - 그 차이는 어떤 선택을 내릴 때 기준을 갖고 있느냐 없느냐이다.
  - 새롭게 알게 된 지식,경험 하나하나가 내 행동을 만드는 기준이 될 수 있다.
  - 신입은 적응하기 바빠서 어떤 기준을 가지고 일을 해야 하는지 판단하기 어렵다.
  - 시니어는 이미 전체 프로젝트의 흐름을 이해하고 있기 때문에 새로운 기술을 도입해도 더 빠르게 판단하고 결정할 수 있다.
- 기준을 만들어내기 위해 가장 빠르고 안전한 방법은 경험이라고 생각한다.
- 그래서 미래를 대비하는 방법은 미래에 대해 걱정만 하지 말고 그냥 하고 싶은거 하면된다.
- 직접 겪어보지 못한 것에 대해서 판단하려고 하는 것은 너무나 어렵다.
- 빠르게 실패하고 빠르게 다시 시작해라

#### 호호의 무엇을 하는게 좋을까
- 자신만의 무기 만들기
  - 관심, 재미, 흥미를 느낀 개발 키워드나 주제를 만날 것이다.
  - 언어가 될수 있고 프레임워크, 테스트, 객체지향, 아키텍처 등등 이 될 수 있다.
  - 지금 당장은 아니더라도 이것 만큼은 자신있다고 느껴질만한 무기 만들기
    - 내가 이해한 바를 남에게 이해시킬 수 있다. 정도?
- 하지말라는거 안해도 된다.
  - 분명히 공부해야 하는 순간이 온다.
  - 다만 누군가 한다고 해서, 이걸 해야 취업을 할 수 있다고 해서 하지 않았으면 좋겠다
  - 나만의 무기를 만들다보면 언젠가 꼭 만나게 될 것이다.
- 빠르게 학습하고 적용하는 능력 기르기
  - 우테코에서 자바 스프링 mysql 정말 열심히 했다.
  - 그런데 회사에서는 전혀 배우지 않았던 기술들만 써야 했다.
  - 지금 배우는 내용은 기본내용, 지금 겪는 어려움의 고통이 쌓여서 더 빠르게 학습하는 능력이 생길 것이다.
- 좋은 동료 개발자 되기
  - 앞으로 페어로, 팀으로, 회사 동료로 만나게 될 사람들이 옆에 있는 크루들이다.
  - 동료의 성장이 곧 나의 성장이 될 것이라는 믿음이 있다.
  - 그 사람이 많이 성장해서 다시 나를 도와줄 것이라 생각했다.
- 자신이 흥미있는 주제를 공부하는 것이 속도를 올리는데 도움될 수 있다.
- 자신에게 맞는 학습 방법을 찾아야 한다.

### 솔라와의 커피챗
- 이번 블랙잭 미션 리팩토링을 진행하면서 특정한 한 부분을 리팩토링하려고 했을 때 다른 부분이 연쇄적으로 리팩토링이 필요한 경우를 경험했다.
- 현업에서 리팩토링은 훨씬 더 규모가 크고 복잡할 것 같은데 어떻게 하는게 일반적인지?
- 현업에서도 리팩토링은 굉장히 보수적으로 접근하는 작업이다.
- 최대한 작은 단위의 기능부터 해나가는 것이 일반적이다.
  - 예를 들어 안쓰는 메서드를 파악해 삭제한다던가, 메서드의 이름을 좀 더 적절하게 바꾼다던가 하는 작업부터 진행
- 리팩토링이라는 두꺼운 책이 따로 한 권 있을 정도로 굉장히 어려운 작업이다.
  - 해당 책에서는 첫번째 리팩토링 원칙으로 단위 테스트 코드가 없으면 리팩토링 하지 말라고 한다.
  - 두번째 원칙으로는 단위 테스트 코드가 없음에도 리팩토링을 해야한다면 단위 테스트 코드를 먼저 작성하라고 얘기한다.
- 이번에 블랙잭 미션을 리팩토링하면서 느낀 것처럼 처음 추산했던 일정 상 태스크에 대한 예상이 틀렸다는 걸 인지한 순간 반드시 일정을 재조정해야 한다.
- 처음에 한 덩어리로 묶어서 생각했던 태스크를 쪼개서 여러 태스크로 나누고 다시 그 안에서 우선순위를 결정한다.
- 만약 재조정된 태스크들을 고려해봤을 때 정해진 데드라인 혹은 생각한 시간 안에 해결하지 못할 것 같다면 이제 포기할 것들을 우선순위에 의거하여 결정한다.


### 체스 1,2 단계 미션 피드백 정리
- enum 비교는 == 으로 해주는게 좋을것 같아요
  - 리팩토링하면서 들었던 한 가지 궁금한 점이 있습니다. enum처럼 동일한 단일 객체에 대해 비교를 해줄 때 반드시 동일성으로 비교해줘야만 하는 이유가 있는지 여쭤보고 싶습니다.
  - 동등성과 동일성 비교 연산간 뚜렷한 성능차이가 있는 것인지, 그게 아니면 코드를 보는 입장에서 직관적으로 더 의미가 와닿을 수 있도록 명시하기 위함인지 질문드립니다!

- 저는 contains 확인용도라면 보통 set 자료구조를 사용하는 편인것 같아요
  - 단순하게 contains 를 통해 컬렉션에 포함된 값인지 확인만 하는 용도라면 list보다 set을 사용하자!

- 어떤 direction인지를 판단하는 로직을 value로 가지는거면 차라리 of에서 if문으로 분기하는게 가독성이 좋다고 생각합니다.
  - 함수형 인터페이스는 direction이 결정되고 그 direction으로 수행해야할 로직이 있다면 value로 들어가는게 좋을것 같아요
  - Enum의 값으로 함수형 인터페이스를 주는 경우는 해당 Enum 객체가 결정되고 해당 객체로 수행해야 하는 로직이 있을 때 사용하도록 하자!

- 여기도 for문이나 intstream 고려해보면 좋을것 같네요, cache는 조금 오버엔지니어링 아닐까 싶습니다!
  - 왜 cache를 해야하지?
  - Position 클래스는 현재 체스판 위의 칸에 대한 위치 정보를 저장하고 관리하는 책임을 지고 있습니다.
  - 그리고 두 개의 서로 다른 position 객체가 주어졌을 때 그 사이 정방향의 경로를 계산하는 책임도 지고 있습니다.
    - 여기서 정방향이란 상하좌우, 기울기 절댓값이 1인 대각선이라고 저는 정의했습니다.
  - 체스판의 칸은 총 64개로 정해져있습니다. 그리고 한 칸 위에 여러 말이 위치할 수도 없구요.
  - 그래서 한 칸에 대한 정보가 비즈니스 로직 상에서 고유하게 하나만 존재한다는 도메인적 의미를 부여하고 싶었습니다.
  - 그리고 캐싱을 함으로써 중복되는 값으로 Position 객체가 생성되는 것 또한 방지하고 싶었습니다. (equals를 통해 서로 같은 객체라고 판단할 수 있을지라도요!)
    - 여기에서 position 객체를 생성할 때마다 검증을 매번 진행하는 것보다는 차라리 캐싱을 하는 것이 더 직관적일 것 같다는 판단을 내렸습니다.
  - 도메인적인 의미를 부여하려고 사용하기엔 캐싱이라는 개념이 과도한 오버엔지니어링이었는지 다시 한 번 더 질문드립니다!
  - 만약 수정해야 한다면 어떤 방식으로 도메인적 의미를 부여하면서 적절한 엔지니어링을 할 수 있을지 힌트도 같이 주시면 너무 좋을 것 같습니다...!

- 메인 코드에서 안쓰이면 지우는게 좋을것 같습니다.
  up, down, upLeft 요런 로직들도 pawn에서만 쓰이네요
  pawn의 로직을 변경해서 나머지도 없애는 방향도 고민해보면 좋겠네요!
  - 다른 Piece 객체들은 정방향(상하좌우, 기욱기 절댓값이 1인 대각선)인 경우 Direction에서 판단하도록 되어 있습니다.
  - 그런데 영이의 리뷰대로 폰 이동관련해서 판단할 때만 Position의 move 메서드를 사용하고 있었네요!
    - 해당 부분은 원래 다른 piece 객체들도 position을 이용해 자신의 움직임 방향을 판단하고 있다가 Direction Enum을 구현하면서 변경되었던 것 같아요.
  - 그래서 폰 객체 내부에서 최대한 이를 판단하는 방향으로 리팩토링을 고민해봤습니다.

- chessBoard에서 pawn에 대한 로직을 줄여볼 수는 없나?
  - 대각선으로 이동
    - 방향이 대각선인지 확인 && 도착 지점에 말이 있는지 확인
    - 폰의 대각선 이동은 결국 기존 validatePieceMovable return문 로직으로도 해결이 가능하지 않다.
    - 폰은 상대말이 대각선에 존재할 때만 전진 가능하기 떄문이다.
  - 앞 방향으로 이동
    - 앞으로 한 칸 이동
    - 앞으로 두 칸 이동
      - 진행경로 및 도착지점에 아무것도 없으면 이동 가능, 즉 아무것도 없는지 검증해야함
      - 다른 말들은 도착 지점에 다른 색 말이 있을 경우 무조건 잡고 이동이 가능하지만 폰이 전진하는 경우에는 다른 색 말이 있더라도 잡을 수 없음, 즉 이동 불가능.
      - 기존 로직에서 validateMovableEndPosition 메서드에서 폰의 경우만 다르게 동작하도록 리팩토링하면 된다.


## 23.03.24
### 코수타
- 컨디션 난조로 인한 효율을 보장하는 팁?
  - 일정한 리듬으로 사는 것
  - 오리엔테이션에서 워니의 한마디? 너무 열심히 하지 말자
  - 너무 폭주하지 말자, 오늘도 적당히 열심히 하자
  - 포비는 달릴 때는 달리고 쉴 때는 쉰다.
  - 결국은 나한테 가장 맞는 방법을 찾아야 지속할 수 있다.
  - 포비 : 무엇인가에 끌린다면 상당기간 몰입하고 어느 정도 해소되면 또 어느정도 막 살고 하는 식으로 산다.
- 새로 배울 것들과 기존 학습에 대해 균형을 어떻게 맞춰야 할까
  - 현직자들도 갖고 있는 고민들이다.
  - 이런 고민을 덜려면 약간의 버릴 수 있는 용기가 필요하다.
  - 관심 있는 하나가 있는데 주변에서 뭐가 좋다고 얘기하다보면 휩쓸리기 쉽다.
  - 깊이 있게 몰입하는 경험이 더 중요하다.


## 23.03.26
### 체스 피드백 2 강의 정리
- 우리에게 할당된 시간이 얼마인지, 어디까지 작업할 것인지 결정부터 내린다.
- DB적용을 목적으로 진행해보자.
- To do 작성
  - Db 연결을 한다. 7분
  - 테이블 설계를 한다. 10분
  - 쿼리를 작성한다. 20분
  - CRUD를 수행한다. 3 ~ 40분
    - Create(새로운 게임을 시작 할 때 데이터를 추가한다.) 10분
    - Update (게임을 진행하면서 말이 움직일 떄 업데이트 된다.) 15분
    - Read(기존 게임이 있는 경우 조회한다.) 8분


- 사용자가 어떤 입력을 했을 떄 Db와 어떻게 통신하게 될지 막연하니 시나리오를 작성해보자
- 시나리오 작성 10분
  - 시작을 했을 때 DB에서 저장된 체스 게임의 정보를 읽어온다.
    - 새로운 게임 시작 (create)
    - 기존 게임이 있는 경우 (select)
  - 게임을 진행한다.
    - 각 플레이어의 턴이 존재한다.
    - 말이 움직인다. (update) / (delete/insert)
    - 점수를 계산한다.
  - 게임을 종료한다.

- 우리가 데이터베이스를 사용한다고 해도 인터페이스로 규칙만 약속해둔다면 언제든지 중간에 DB를 추가할 수 있을 것 같다.
  - 어느 위치에서 데이터를 저장하고 업데이트할 것인가 정한다.
  - 그 위치에 인터페이스를 작성해두고 나중에 DB 연결을 하자.

- DB에 연결되어 있지 않은 시점에서 DB를 연결해서 관련 기능을 구현하려고 할 때 테스트가 DB의 영향을 많이 받을 수 밖에 없다. 즉 테스트의 범위가 커질 수 밖에 없다.
- 변경을 최소화하면서 테스트를 진행할 수 있는 방법이 없나?
- 메모리 상에서 해당 기능을 수행할 수 있는 객체를 하나 만들자!

``` sql
CREATE TABLE chess_board {
    piece_name VARCHAR(255) NOT NULL,
    piece_color VARCHAR(255) NOT NULL,
    piece_row INT NOT NULL,
    piece_column INT NOT NULL,
    turn VARCHAR(255) NOT NULL
}

INSERT INTO chess_board(piece_name, piece_color, piece_row, piece_column, turn) VALUES (?, ?, ?, ?, ?);
SELECT piece_name, piece_color, piece_row, piece_column, turn FROM chess_board;
DELETE FROM chess_board;
```



- 강의 1:15분부터 다시보기!!





































