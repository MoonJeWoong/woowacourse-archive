# 레벨 1 - 7주차 (23.03.20 ~ 23.03.26)

---
## 23.03.27

글쓰기 미션 , 체스 피드백 강의, 레벨 인터뷰 작성

- 체스 피드백 2 강의 1:15분부터 다시보고 정리하기!!

- 체스 미션 리뷰 피드백 정리
- 성능 차이는 없을겁니다 equlas 내부적으로도 == 을 사용할거에요
  - 다만 타입이 다른경우라도 equals는 컴파일에러를 내지 않고 == 은 컴파일 에러가 뜨기 때문에 타입 오류를 예방할 수 있고
  - equals는 nullPointerException이 날 수 있지만 == 은 NullPointerException이 나지 않는 장점이 있을것 같아요

- beforeEach는 사용가능할것 같아요
  그리고 평소에도 beforeAll보다는 beforeEach 를 사용하면 좋을것 같아요
  독립된 테스트를 보장하기 위해서요

- 폰 나이트 에서만 구현해주고
  나머지는 따로 구현을 안해주면 되지 않을까요? piece에서 로직 그대로 사용할 수 있도록요

- path를 생성하는 로직이 너무 복잡한것 같아요
  이런 부분은 정적팩토리 메서드를 활용해보는게 좋을것 같네요

- column to number / row to number enum 내부로 이관 고려


### 학습로그 작성

- Enum간 비교는 equals가 아니라 ==(동일성) 비교를 해야한다.
  - 성능적으로 차이는 없다. equals 내부적으로도 동일성 비교를 해준다.
  - 다만 객체 타입이 다른 경우라도 equals 는 컴파일 에러를 내지 않고 ==은 컴파일 에러를 발생시켜준다.
    - 그래서 타입 오류를 개발하는 시점에서 알 수 있게 된다는 장점이 있다.
  - equals는 NPE 발생의 위험이 존재하지만, ==은 NPE가 발생하지 않는다는 장점도 있다.


- 인터페이스와 추상클래스

- 인터페이스 : 모든 메서드가 추상 메서드로 선언된다.
  - 미리 사용할 메서드를 인터페이스에 선언해두고 구현 시 선언된 메서드들을 구현하면 된다.
  - 즉 자식 클래스에게 구현을 강제시켜 구현 객체의 동일 동작을 보장한다.
  - 상속보다는 다형성의 개념에 더 가깝다.
  - 다형성을 제공하기 위해 반드시 구현해야하는 메소드를 포함한 틀이다.


- 추상클래스 : 클래스 내 추상 메서드가 하나 이상 포함되거나 abstract로 정의된 경우
  - 여러 메서드가 존재하므로 다음의 방법들 중 선택해서 사용한다.
    - 메서드가 구현된 그대로 가져다 쓴다.
    - 오버라이드해서 기존 메서드를 재구현해 사용한다.
    - abstract로 선언된 메서드를 구현해서 사용한다.
  - 부모가 가진 기능을 재사용 혹은 확장 할 수 있는 상속을 위한 틀

- 공통적으로 둘 다 상속받은 자식에게 메서드 구현을 위임하도록 한다.
- 추상 클래스가 모든 메서드를 추상 메서드로 가지면 인터페이스와 같아지나?
  - 추상클래스는 인터페이스와 다르게 다중 상속이 불가능하다.






## 레벨로그 작성
### 일급 컬렉션을 사용하는 이유
- 동일 타입 객체들에 대한 상태와 행위를 한 곳에서 관리하기 위함이다.
- 일급 컬렉션을 사용하면 얻을 수 있는 장점
  - 리스트 요소 객체들에 대한 검증 및 기능 로직들을 스스로 관리할 수 있게 된다. (객체간 중복 여부, 객체 개수 검증 등...)
- 일급 컬렉션을 사용하지 않는다면...?
  - 객체 요소 컬렉션을 사용하는 모든 클래스마다 리스트 요소 객체들에 대한 검증 및 기능 로직들을 구현해줘야 한다.

### 객체의 불변성 유지
- final 키워드
  - 선언된 변수가 초기화 될 때를 제외하고 값이 재할당 되는 것을 막아주는 키워드이다.
  - 객체의 참조 타입 상태 값에 대해 단순하게 final 선언만 해준다고 불변을 보장할 수 없다.
  - 참조 타입 변수에 담기는 객체 내부적으로도 스스로의 상태 값에 대한 불변을 보장해야 한다.
- 방어적 복사
  - 클래스 내부에 저장된 객체 데이터를 보호하기 위해 주로 사용된다. 주된 사용 경우는 아래와 같다.
    - 생성자의 매개변수로 객체를 받아서 클래스 내부 필드를 초기화해야 하는 경우.
    - getter 메서드로 클래스 내부에 저장된 객체를 외부로 반환해야 하는 경우.
- unmodifiable List
  - List를 수정할 수 있는 연산 (add, remove) 등을 막아둔 List 구현체를 unmodifiable 리스트라고 한다.
  - 객체 내부 상태값 리스트를 getter를 통해 외부로 반환할 때 사용하기도 한다.
    - 단 동료 개발자 입장에서 unmodifiable 리스트가 반환된다는 것을 알아차릴 수 있도록 메서드 명 등을 통해서 알릴 수 있어야 한다.
  - unmodifiable 리스트는 원본 리스트 자체에 대한 불변은 보장하지 않는다.
    - 즉 원본 리스트가 변경되면 unmodifiable 리스트도 변경된다.

### 디미터의 법칙
- 디미터의 법칙은 최소한의 지식 원칙(The Principle Of Least Knowledge)을 강조하며, 모듈은 사용하는 객체의 속사정을 몰라야 된다는 원칙이다.
- 디미터의 기본 법칙 요약 : 어떤 클래스 C의 메서드 f 내부에서는 다음과 같은 객체의 메서드만 호출해야 한다.
  - 클래스 C가 갖고 있는 다른 메서드
  - 클래스 C가 저장하고 있는 인스턴스 객체의 메서드
  - 메서드 f의 매개변수로 전달받은 객체의 메서드
  - 메서드 f의 내부에서 생성된 객체의 메서드
- 위와 같은 원칙들을 지켜서 객체를 사용할 때 객체간 결합도를 낮추고 자율성을 높여 객체 간 올바른 협력관계를 구축할 수 있다.

### 객체 간 동등성과 동일성 비교
- 동일성 비교는 객체가 할당된 메모리 주소가 동일한지 비교한다.
- 동등성 비교는 객체가 내부적으로 같은 상태값을 가지는지 비교한다.
  - 단 객체 내부적으로 equals 메서드를 재정의해줘야 한다.
- Enum간 비교는 equals가 아니라 ==(동일성) 비교를 해야한다.
  - 성능적으로 차이는 없다. 기본적으로 equals도 내부에서 동일성 비교를 해준다.
  - 다만 객체 타입이 다른 경우라도 equals 는 컴파일 에러를 내지 않고 ==은 컴파일 에러를 발생시켜준다.
    - 그래서 타입 오류를 개발하는 시점에서 알 수 있게 된다는 장점이 있다.
  - equals는 NPE 발생의 위험이 존재하지만, ==은 NPE가 발생하지 않는다는 장점도 있다.

### 인터페이스와 추상클래스

- 인터페이스 : 모든 메서드가 추상 메서드로 선언된다.
  - 미리 사용할 메서드를 인터페이스에 선언해두고 구현 시 선언된 메서드들을 구현하면 된다.
  - 즉 자식 클래스에게 구현을 강제시켜 구현 객체의 동일 동작을 보장한다.
  - 상속보다는 다형성의 개념에 더 가깝다.
  - 다형성은 하나의 타입에 대입되는 객체에 따라서 실행 결과가 다르게 나오는 성질을 말한다.
  - 인터페이스는 다형성을 제공하기 위해 반드시 구현해야하는 메소드를 포함한 틀이라고 얘기할 수 있다.

- 추상클래스 : 클래스 내 추상 메서드가 하나 이상 포함되거나 abstract로 정의된 경우
  - 여러 메서드가 존재하므로 다음의 방법들 중 선택해서 사용한다.
    - 메서드가 구현된 그대로 가져다 쓴다.
    - 오버라이드해서 기존 메서드를 재구현해 사용한다.
    - abstract로 선언된 메서드를 구현해서 사용한다.
  - 부모가 가진 기능을 재사용 혹은 확장 할 수 있는 상속을 위한 틀
  - 재사용은 확장의 개념에 포함되는 것이라 본다.

- 공통적으로 둘 다 상속받은 자식에게 메서드 구현을 위임하도록 한다.
- 추상 클래스가 모든 메서드를 추상 메서드로 가지면 인터페이스와 같아지나?
  - 추상클래스는 인터페이스와 다르게 다중 상속이 불가능하다.
  - 레퍼런스! (https://velog.io/@dnwlsrla40/Java%EC%97%90%EC%84%9C-%EB%8B%A4%EC%A4%91-%EC%83%81%EC%86%8D%EC%9D%84-%EC%A7%80%EC%9B%90-%EB%AA%BB%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0)


### 상태패턴
## [상태 패턴](https://tecoble.techcourse.co.kr/post/2021-04-26-state-pattern/)
### Enum
- Enum이란 서로 연관된 상수들의 집합이다.

### 상태 패턴이란?
- 특정 기능을 수행한 후 다음 상태를 반환하는 것
  - 상태 패턴은 나타내야 하는 상태가 많아지더라도 코드 복잡도가 증가하지 않는다.
    - 단순히 새로운 상태를 나타내는 클래스를 구현하면 된다.
  - 반면 Enum에서 조건문을 이용한 방식은 코드를 복잡하게 만들어 유지보수를 어렵게 한다.

### 상태패턴 적용
- 동일한 메서드가 상태에 따라 다르게 동작할 때 사용할 수 있는 패턴이다.
- 상태 패턴에서는 상태를 별도의 타입으로 분리하고 상태 별로 알맞은 하위 타입을 구현한다.
- 상태 패턴은 추상화된 동일한 메서드에 상태마다 다른 특정 기능을 수행한 후 다음 상태를 반환하는 것이 상태 패턴의 핵심이라고 볼 수 있다.
- 상태 패턴이란 객체지향 방식으로 상태 기계를 구현하는 행위 소프트웨어 디자인 패턴이다.
  - 상태 기계란 한 번에 오로지 하나의 상태만을 가지게 되며, 현재 상태(Current State)란 임의의 주어진 시간의 상태를 칭함.
- 상태 패턴의 장점은 새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향이 최소화 된다는데 있다.
  - 클래스를 새로 추가하더라도 기존 메서드 코드는 그대로 유지된다.
  - 또한 상태에 따른 동작을 구현한 코드가 상태 별로 구분되기 때문에 상태별 동작을 수정하기가 쉽다.

### 고려해야할 점
- 하나의 상태를 클래스로 명확하게 표현하는 것과 , 상태 변수로 표현하는 것 사이에서 장단점을 잘 저울질 해봐야한다.
  - 상태 패턴으로 리팩토링 한 이후가 더 복잡하다면 굳이 상태 패턴을 도입할 이유는 없다.
- 다뤄야 하는 상태의 개수만큼 관리해야 할 클래스가 늘어나는 것에 주의해야 한다. 경우에 따라서는 장점이 될 수도 있다.
- 각각의 상태별로 공통 메소드가 많다면 굳이 상태 패턴이 필요없을 수도 있다.
- 각 상태를 싱글톤으로 관리하는 것도 고려할 수 있다.


### 디미터의 법칙으로부터 파생된 객체간 의존성과 자율성
- 객체간 결합도? 자율성? 어떤 개념인지 정리해보자!
- 한 객체 내에서 다른 객체에 대한 메서드를 호출하는 것을 두고 의존한다라고 한다.
- 객체 간 의존성이 높다는 것은 곧 결합도가 높다고 말할 수 있다.
- 결합도가 높다면 한 객체를 변경할 때 다른 객체를 함께 변경해야할 가능성이 높아진다.
  - 결합도를 낮추기 위해서 다음과 같은 방법을 고려할 수 있다.
  - 객체에게 자율성을 부여한다.
    - 자율성이란 객체 내부의 데이터를 변경하는 책임을 스스로에게 위임하는 것을 말한다.
  - 객체를 캡슐화한다.
    - 개념적, 물리적으로 객체 내부의 세부적인 사항을 감춰야 변경하기 쉬운 객체를 만들 수 있다.
  - 의존관계는 인터페이스에서 의존한다.
    - 객체를 인터페이스와 구현부로 나누고 외부에는 인터페이스만 공개한다.
- 객체간의 올바른 협력관계?
  - 객체 간 자율성이 보장되는 협력관계!


## 이것이 자바다 (인터페이스)
### 인터페이스의 역할
- 인터페이스는 객체의 사용 방법을 정의한 타입이다.
  - 인터페이스는 개발 코드와 객체 간 서로 통신하는 접점 역할을 한다.
  - 개발코드가 인터페이스 메서드를 호출하면, 인터페이스 메서드는 객체의 메서드를 호출한다.
  - 개발코드가 직접 객체의 메서드를 호출하지 않고 중간에 인터페이스를 두는 이유는 개발코드를 수정하지 않고 사용하는 객체를 변경하도록 하기 위함이다.(다형성!)

### 인터페이스 선언 
- 인터페이스는 상수필드, 추상메서드, 디폴트 메서드, 정적 메서드를 가질 수 있다.
- 자바 8부터 인터페이스에서 디폴트와 정적 메서드를 선언하고 구현할 수 있다. 그 이유는 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서이다.
  - 나의 생각) 기존에 구현해 둔 인터페이스를 구현한 구현 객체가 이미 수십개가 되는 경우 새로운 기능을 추가하기 위해 인터페이스를 재정의하는 것은 거의 불가능에 가깝다.
  - 그래서 cheating의 개념으로 default 메서드를 추가할 수 있도록 해서 필요한 기능만 기존 인터페이스에 추가해서 사용할 수 있도록 한 것이라 생각된다.
  - 하지만 에코가 토론에서 얘기해줬듯이 동기화 관련된 컬렉션을 다루는 경우 등 일반적으로 디폴트 메서드로 기능을 추가했을 때 예상치 못한 결과를 낳기 때문에 추가하지 말라고 보통 얘기한다.

### 인터페이스 구현
- 인터페이스로 구현객체를 사용하기 위해서는 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다.
- 익명 구현 객체
  - 일회성의 구현 객체를 만들기 위해 소스 파일을 만들고 클래스를 선언하는 것은 비효율적이다.
  - 그래서 자바 8부터 지원하는 람다식은 인터페이스의 익명 구현 객체를 만든다.
- 다중 인터페이스 구현
  - 다중 인터페이스를 구현하는 경우, 즉 하나의 클래스에서 여러 개의 인터페이스를 구현하는 경우, 구현 클래스는 모든 인터페이스의 추상 메소드에 대해 실체 메소드를 작성해야 한다.

### 인터페이스 사용
- 인터페이스는 클래스의 필드, 생성자 또는 메서드의 매개변수, 로컬변수의 타입으로 선언될 수 있다.
- 디폴트 메서드 사용
  - 인터페이스에서 바로 사용할 수는 없고 구현 객체가 생성된 이후에 사용가능하다.
  - 그래서 구현 객체에서 디폴트 메서드를 오버라이딩 해서 재구현 해주면 구현체마다 수행 기능이 달라지게 할 수 있다.
- 정적 메서드 사용
  - 인터페이스로 바로 호출이 가능하다.

### 타입 변환과 다형성
- 다형성은 하나의 타입에 대입되는 객체에 따라서 실행 결과가 다르게 나오는 성질을 말한다.
- 상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 사용방법이 동일한 클래스를 만드는 기술이라는 차이가 있다.
- 자동 타입 변환
  - 구현 객체가 인터페이스 타입으로 변환되는 것은 자동 타입 변환에 해당한다. (Promotion)
  - 자동 타입 변환은 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 말한다.
- 인터페이스 배열로 구현 객체 관리
  - 배열의 요소 값 타입으로 인터페이스를 선언하여 내부 요소 객체들로 다양한 구현체를 동시에 가질 수 있다.
- 강제 타입 변환
  - 구현 객체가 인터페이스 타입으로 자동 변환되면 인터페이스에 선언된 메서드만 사용 가능하다는 제약사항이 따른다.
  - 인터페이스에 3개의 메서드가 선언되고, 구현체 클래스에 5개의 메서드가 선언되었다면 인터페이스로 호출 가능한 메소드는 세 개뿐이다.
  - 하지만 경우에 따라서는 구현 클래스에 선언된 필드와 메서드를 사용해야 하는 경우 강제 타입 변환을 사용해 구현클래스 타입으로 변환시켜 사용할 수 있다.

### 인터페이스 상속
- 인터페이스는 다중 상속을 허용한다.
- 하위 인터페이스의 구현체는 하위 인터페이스 뿐만 아니라 상위 인터페이스의 추상 메서드들도 모두 구현해야 한다.



# 23.03.29

## 레벨 인터뷰
- 어떤 비슷한 개념 A와 B가 있을 때 각각 어떤 장단점이 있고, 개인적으로 어떤 기준을 가지고 어떤것을 더 선호하는지 정리하는 학습방식을 유지해보자. (가장 중요!)
- 리뷰어에게 개념에 대해 어떤 생각이나 판단 근거를 갖고 있는지 자주 여쭤볼 수 있도록 해보자!
- 기업에서는 우리의 경험을 사고 싶어하지 지식을 사고싶어 하지 않는다.
- 키워드 학습을 위해 모던 자바 책을 읽어보자.
- 제리
  - 화이트 박스 테스트를 했을 때 오히려 테스트 코드가 걸림돌이 될 수 있지 않나
  - 만약 Dao를 JDBC를 사용하다가 다른 것으로 교체하고 싶을 때 모든 테스트 코드를 리팩토링해줘야 하는데 이런 경우에도 화이트박스를 채택해야 하나?
- 강의 자료에서 제시된 내용들이 생각보다 많다. 방학 때 잘 복습해보자!

## 체스 리팩토링
- [ ] path 생성로직 쉽게 바꿔보기 (정적 팩토리 메서드..?)
- [x] isMovableDirection 메서드 상위 클래스로 이관시켜보기
  - Piece에 getMovableDirections를 abstract Method로 구현
  - 각 구현체에서 getMovableDirections를 구현
  - Piece 클래스에서는 getMovableDirections를 사용해 기존 isMovableDirection 구현하기
  - 진짜 경탄스럽다...!
- [x] RowToNumber / ColumnToNumber 클래스 Position내부로 이관시키기
- [x] 컨트롤러에서 DB에 직접 접근하는 방법은 좋은 연결방법이 아니다.
  - 서비스 레이어의 도입 타이밍이다!
  - presentation, business, persistance layer로 관리할 수 있도록 변경이 필요하다.
  - 레퍼런스 (https://walbatrossw.github.io/etc/2018/02/26/etc-layered-architecture.html)
  - Service Layer에서는 트랜잭션과 도메인 간의 순서만을 보장한다.(https://velog.io/@ovan/Domain-Layer%EC%97%90%EC%84%9C-%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4-%EB%A1%9C%EC%A7%81-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0)
  - DAO는 데이터베이스 쿼리를 날리고 원시 데이터를 DTO에 담아서 서비스레이어로 반환하는 역할
  - 서비스 레이어는 DTO에 담긴 데이터를 가지고 도메인에 전달하여 로직을 수행할 수 있도록 한다.
- [ ] DAO 내부 switch문 enum에서 함수형 인터페이스를 사용해 Piece 객체를 생성하여 반환할 수 있도록 수정하기
  - https://velog.io/@jaca/%ED%95%A8%EC%88%98%ED%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%99%80-Enum
- [ ] DAO 명칭을 PieceDao로 수정하기!

- [ ] DAO에서 Connection을 관리하기 보다는 util 클래스를 만들어서 관리해보자
  - 레퍼런스 (https://velog.io/@hc7919/JDBC-Util-%EB%A7%8C%EB%93%A4%EA%B8%B0)
- [ ] gameCommand의 readNextCommand를 지금의 컨트롤러로 이관, 기존 컨트롤러의 네이밍을 ControllerRouter로 변경하기
  - 기존 GameCommand들을 controller로 네이밍 변경하기
- [ ] save할 때 움직인 말의 정보를 찾아서 해당 데이터만 업데이트 해주는 방식으로 변경하기
- [ ] 리드미에 ddl 명시해주기!

나중에 수정해보기
- validateNoPieceAt 메서드에 position 좌표값을 예외처리 메세지에 넣어주기 (후순위)
- PieceName에서 view 로직을 처리하는 부분 수정하기

## 체스 피드백 2 강의 정리
- 우리에게 주어진 가용시간을 고려하고 그 시간안에 완료할 수 있는 수준으로 최선을 다해야 한다.
- 데이터베이스에 저장된 데이터는 그 자체만으로 유의미해야 하고 쉽게 찾을 수 있어야 한다.
- 강의에서 구현할 때 턴에 대한 정보와 기물에 대한 정보를 한 테이블에 담았는데 공간을 효율적으로 사용할 수는 없을까?
  - 기물과 보드를 분리한다.
- 무르기 기능이 추가되면 어떻게 되나?
  - 다시 말들의 움직임에 대한 기록 데이터를 DB에 게임별로 저장한다.
- 중간 테이블을 만들어서 기존 테이블의 데이터를 캐싱하듯이 사용할 수도 있다.
  - piece 테이블에는 각 말의 종류별로 위치할 수 있는 모든 케이스를 캐싱해둔다.
  - chess_game_piece 테이블에는 piece 테이블에 저장되어 있는 데이터를 가져와서 게임 정보와 맵핑해준다.
- 요구사항들이 추가되고 변화하면서 계속 설계에 대한 고민을 하게된다.
- 강의자료에 나온 과정이 정규화 과정인데 항상 중복을 제거하고 분리하는 것이 정답은 아니다.
  - 오히려 중복되는 데이터가 존재하는게 더 좋은 경우도 있다.
  - 만 명의 사용자가 동시에 접근하는 경우 한 테이블에서 중복으로 모두 관리하는게 더 효율적일 수도 있다.
- 서버개발자 입장에서는 데이터베이스 정규화 관점에서만 생각하면 안된다.
- 중복을 제거하면 데이터 불일치 문제가 생길 가능성은 줄어든다.
  - 하지만 여러 곳에서 동일한 데이터를 바라봐야 한다는 문제가 생기는 것인데 동시성 문제가 생기게 된다.
- 그래서 서버 개발자 입장에서 데이터베이스 설계는 조회와 쓰기 사이의 트레이드 오프의 연속이다.
- 개발자로서 어플리케이션 로직을 설계하고 데이터가 어떤 방식으로 다뤄져야 하는지 생각해야한다.
  - 이러한 트레이드 오프에 대한 고민들을 레벨 2때 많이 시도해봐야 한다.
- 애플리케이션은 코드를 짜고 단순히 리팩토링 하는게 상대적으로 쉽다
- 하지만 데이터베이스는 실 사용중인 서비스라면 실시간으로 데이터가 들어오고 있을텐데 이를 마이그레이션하거나 다른 방식으로 변경하는 것은 굉장히 어려운 일이다.
- 앞으로 레벨을 진행하면서 서버 개발자로서 데이터베이스를 어떻게 바라볼 것인지에 대한 관점을 정하는 것이 중요하다.

- 테스트 더블
- 스턴트 더블에서 나온 개념
  - 귀중한 자원을 분리해서 지키는 개념
- 테스트 더블은 테스트를 단순화 시키고, 외부 세계로부터 보호하기 위해 사용한다.
- 대표적으로 stub과 fake를 사용한다.
- 보드를 조회해서 플레이하는 기능을 테스트한다고 가정해보자
  - 디비를 조회하고 저장하는 로직 때문에 쉽게 테스트 하기가 힘들다.
  - 디비를 붙여두면 굉장히 불확실성이 커져서 테스트가 실패하게 될 문제가 생긴다.
- stub
  - 어떻게 동작을 수행할 지 정해두고 호출에 따라 정해놓은 값을 반환하도록 시뮬레이션하는 방법
  - 테스트 코드를 작성하는 시점에 Dao가 어떤 방식으로 동작할 지 결정할 수 있다는 장점이 있다.
  - 내부 동작을 정해둘 수 있기 때문에 우리가 원하는 정확한 시점에 테스트를 진행할 수 있게 된다.
- fake
  - 어떻게 동작할 지에 대한 내용을 간단하게 구현한 객체
  - 우리가 사용하게 될 Dao 인터페이스를 정말 간단한 로직으로 구현한 가짜 객체이다.
- 테스트 시점에 어떻게 동작할지를 정해두는 것과 간단하게 구현 코드를 작성해서 테스트 하는 것에는 어떤 차이가 있을까
  - fake를 사용하면 테이블 구조를 몰라도 쉽게 테스트할 수 있다.
  - 또한 세부 구현을 몰라도 쉽게 객체를 갈아 끼울 수 있다는 장점이 있을 것이다.
  - stub을 사용하면, 즉 mocking을 사용하면 테스트를 원하는 지점을 정확하게 테스트할 수 있는 대신에 세부 구현 방식을 정확하게 알고 테스트해야 한다.

- sociable tests
  - fake 방식을 사용한 케이스
  - fake 객체에 대한 의존성을 가진 테스트를 진행할 수 밖에 없다.
  - 그래서 테스트를 위해 이런 객체들까지 만드는게 옳은가에 대한 고민들이 들게 된다.
  - 이 테스트를 위해 이런 객체들 까지 필요하네... 테스트 범위가 너무 커지는게 아닌가...?
- solitary tests
  - 우리가 테스트를 작성하는 시점에 어떻게 동작할 지를 결정할 수 있기 때문에 테스트를 위핸 객체들에 대한 의존성은 없앨 수 있다.
  - 다만 내부 구현 방식을 알고 테스트를 진행해야 하고 기존 코드가 바뀌었을 때 테스트가 안깨지는 경우가 생길 수 있다.
  - 테스트 시점에 동작 방식을 이미 다 정하고 테스트를 진행하게 되기 때문이다.
- 이런 키워드들을 가지고 공부를 해보자
- 이런 관점에 대해 디트로이트(classist), 런던(mocking) 학파로 나뉘어진다.
  - tdd에서 시작된 개념들
  - 디트로이트 관점에서는 fake 객체를 만들어가면서 테스트를 수행해왔다.
  - 하지만 이렇게 되면 상위 객체를 테스트 하기 위해서는 반드시 하위 객체들이 필수적으로 선행되어 구현되어야 한다는 in out 방향으로밖에 테스트 할 수 없다는 문제가 있다.
  - 런던학파에서는 이에 대해서 이게 너희가 원하는 TDD, 단위테스트가 맞냐?
  - 진짜 단위 테스트, TDD라면 우리가 원하는 부분의 기능이 어떻게 동작할지 예상하고 이에 대해서만 테스트를 작성할 수 있어야 되는 것 아니냐라고 반문한다.
  - 정말 TDD를 위한다면 mock을 사용해서 우리가 원하는 부분만 딱 테스트할 수 있도록 해야하는 것 아니냐라고 주장한다.
- 프레임워크를 사용하며 객체지향이 많이 깨지는 경우를 많이 접하게 될텐데 이 또한 트레이드오프다.
  - 객체지향의 장점을 조금 포기하고 프레임워크를 사용하는 장점을 취한다.
- 









