# 레벨2 - 10주차 (23.04.10 ~ 23.04.16)

---
## 23.04.10

### 레벨2 OT
- 레벨2 학습목표 중 가장 중요한 것은 새로운 기술을 익히는 본인만의 효과적인 학습 방법 찾는 것이다.
- 다른 목표들은 이 목표가 잘 이뤄지면 잘 할 수 있다.
- 어떻게 학습을 진행하는 것이 제일 효과적인가를 찾아가는 과정이 될 것이다.

- 테스트로 배우는 스프링
  - 스프링이라는 새로운 기술을 어떻게 학습할 것인가?
    - 책을 읽는다.
    - 강의를 듣는다.
    - Spring 소스코드를 파본다.
    - 학습 테스트를 통해 기능을 읽힌다. (브리의 추천!)
- 레벨2 무물보 언제든지 강의를 듣다가 궁금해진 점 혹은 다뤄줬으면 좋겠는 점을 잘 남겨달라.
- 레벨2가 힘든 이유
  - 학습해야하는 내용의 범위가 넓다.
  - (역시나) 절대적인 진리, 정답은 없다.
  - 성장이 더디게 느껴진다.
- 어디까지 학습할 지 경계를 정한다.
  - 학습해야하는 내용의 범위가 넓으니, 깊이를 제한한다.
    - 스프링의 동작 원리를 학습해야하나?
    - HTTP 완벽 가이드를 다 읽어야 할까?
  - 만약 깊이를 정하기 어렵다면 프롤로그 로드맵을 참고한다.
  - 스프링의 동작 원리를 파악하는 시간은 레벨4 때 직접 구현하면서 파악할 시간이 있을 것이다.
  - 스프링에 대해서 얼마나 정확하게 알고있는지에 대해서 집중해보면 좋겠다.
    - 레벨2에서 했으면 좋겠는 것은 스프링 MVC를 이용해서 리퀘스트를 어떻게 처리를 하는지, 실제로 어떻게 사용할 수 있는지 이런 것들을 학습했으면 좋겠다.
    - 리퀘스트 요청이 어떤 원리에 의해 이렇게 이루어지는지 등에 대해서 레벨2에는 집착하지는 않았으면 좋겠다.
    - 솔라의 코멘트~
      - 스프링은 웹개발자가 바로 활용하기를 바라면서 만들어진, 프레임워크에요. 
      - 그래서 레벨2에서는 프레임워크의 활용방법, 스프링을 활용해서 내가 어떤 것을 할수있는지에 집중하는 방향이에요~! 
      - 스프링 프레임워크를 사람들은 이걸 왜 이렇게 만들었지? 어떻게 만들었지? 는 활용법에 익숙해지고 나서 다음번에 집중해보자~는 의미같아요
      - 비유가 잘 안되는것 같지만만…framework를 활용해보신적이 없어서 안 와 닿으신다면, 여러분이 웹 개발을 하시기전에, java 프로그래밍을 처음 배울 때를 떠올려보세요. 
      - java 언어에서 제공하는 모든 라이브러리들 내부구현과 동작원리가 1차 관심대상이 아니라, 제공되는 라이브러리의 활용방법을 익혀서 내가 만들려고 하는 기능을 완성하는게 1순위 관심 대상이었을 것 같아요. 
      - 스프링도 똑같이 대해주세요~
- 현재 상태에 따른 목표 설정하기
  - 스프링이 처음이라 몰라서 걱정된다.
    - 지금 과정은 스프링을 아예 모르는 사람들을 대상으로 진행되기 떄문에 미션에 집중하면된다.
- 꾸준함 잃지 말기 (가장 중요하다)
  - 어떻게 해야 할까?
  - 정확한 가용시간에 맞춘 욕심을 부린다...ㅎㅎ

- 이번 레벨2는 학습테스트를 통해 새로운 것을 학습하고 남이 만들어진 매체를 사용하기보다는 공식문서나 내가 지속적으로 쓸 수 있는 학습법을 찾는 것이 목표이기 때문에 필독서 선정 기준이 조금 달랐다.
- 미션을 진행하며 필독서에 해당하는 내용 중 궁금한 점이 생기면 찾아보는 식으로만 참고해보자.

- 이번 주 미션 소개
- 웹 자동차 경주 미션을 진행한다.

## 23.04.12

### 리사의 번아웃 특강
- 정신적 탈진
  - 극심한 육체적,정신적 피로를 느끼고 직무에서 오는 열정과 성취감을 잃어버리는 증상의 통칭
- 회복탄력성 계발
  - 우리 각자의 사연은 소중하다.
  - 완벽한 인생은 없다.
  - 각자의 출발선은 다를 수 있다.
  - 대체로 우리는 사건을 실체보다 더 비판적으로 받아들인다.
  - 쌍둥이 대상 연구결과 30%만 유전적요인이다.
- 여러분은 언제 감사함을 느끼나요? (긍정성)
  - 실제로 감사할 일이 없다 하더라도 감사할 일을 스스로 찾아 나서는 것이 더 중요하다.
  - 감사일기를 다시 써보자.
- 일이 계획대로 진행되지 않아도 불안해하지 않는다.
  - 제어할 수 있는 것과 제어할 수 없는 부분을 나눠서 생각한다.
  - 필수적인 영역과 욕심인 영역을 나눈다.
  - 크게 여러번 심호흡하기
  - 나 자신과 대화하기 (감정 적기 - 내 상태 파악하기)
  - 멈추고 싶은 생각을 적어두고 이를 의식적으로 걸러내는 것이 좋다.
  - 내가 이루고 싶은 목표와 경험적기
    - 목표만이 아니라 경험해보고 싶은 것을 적는 것이 좋다.
- 스트레스를 해소하는 나만의 방법이 있다.
  - 로이스가 얘기해준 방법으로 살아보자
  - 내 삶의 질을 위한 것들을 할당해두고 나머지를 개발로 채우자.
  - 이불 속에서 귀여운 동물 영상 보기
  - 10시간 이상 자기, 이불속에서 살기 + 그 이후 1시간 이상 걸으며 생각 정리


### Spring MVC 학습 테스트 

- Http REST 기능 테스트는 io.restAsured.RestAssured 클래스를 사용해서 수행한다.
- SpringBootTest 어노테이션
  - webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT 을 인자로 받는다.
  - 테스트 시 사용하는 포트를 랜덤하게 사용하겠다는 의미인 것 같다.
- Mapping - 요청을 메서드에 연결하는 부분 학습 테스트
  - Http Method
    - controller에 @RestController 를 사용해서 해당 컨트롤러가 REST API를 처리할 수 있는 컨트롤러임을 나타낼 수 있다.
    - @RequestMapping을 사용할 때 명시한 URL로 들어오는 Request들을 해당 컨트롤러의 메서드에 mapping하겠다는 의미를 나타낼 수 있다.
  - UriPatternController
    - @PathVariable : @GetMapping에 명시해준 URL에서 값을 받아와서 저장해줄 변수를 선언해줄 수 있다.
    - path에 pattern을 적용해서 작성할 수 있다 (공식문서를 참조하자.)
    - 일반적으로 pathVariable은 {}를 사용해서 명시한다.
    - path에서 ?는 하나의 char를 의미한다.
      - /pages/t?st.html — matches /pages/test.html as well as /pages/tXst.html but not /pages/toast.html
      - /resources/*.png — matches all .png files in the resources directory
      - /resources/** — matches all files underneath the /resources/ path, including /resources/image.png and /resources/css/spring.css
      - /resources/{*path} — matches all files underneath the /resources/, as well as /resources, and captures their relative path in a variable named "path"; /resources/image.png will match with "path" → "/image.png", and /resources/css/spring.css will match with "path" → "/css/spring.css"
      - /resources/{filename:\\w+}.dat will match /resources/spring.dat and assign the value "spring" to the filename variable
  - MediaTypeController
    - 메서드 mapping을 할 때 mapping 어노테이션에 consumes 옵션으로 사용할 데이터 타입을 명시해서 mapping하는데 활용할 수 있다.
    - 응답하는 데이터 타입을 기준으로 메서드를 mapping 할 수도 있다. (produces 옵션)
  - ParamHeaderController
    - URI로 전달되는 파라미터나 메세지 헤더의 값을 이용해 메서드 mapping을 할 수 있다.
- Handler - 요청을 처리하는 부분 테스트
  - @RequestParam : Servlet request parameters를 controller의 메서드 매개변수에 바인드해준다.
    - @RequestParam을 생략하면 내부적으로 String이나 Long 같은 기본 타입은 @RequestParam으로 취급한다. 
      - required = false로 설정되는 것과 같다고 한다. 이 때는 null값이 들어올 수도 있음을 알려주는 것 같다.
    - 그 외 타입 파라미터들은 @ModelAttribute로 취급한다.
    - @ModelAttribute는 Converter를 통해 @PathVariable 혹은 @RequestParam 등을 통해 받아온 값들 중 겍체 상태 값 변수명과 일치하는 값들 가진 객체를 반환한다.
    - 혹은 받아온 변수들을 이용해 객체의 기본생성자, 혹은 주 생성자를 이용해 생성한다.
  - @RequestBody : HttpMessageConverter를 사용해서 HTTP Request body의 내용을 선언된 메서드 매개변수 타입으로 변환한다.
    - @RequestBody는 request body에 담긴 JSON, XML, Text 등의 데이터를 다룬다.
    - @RequestBody를 사용할 객체는 필드를 바인딩할 생성자나 setter 메서드가 필요없다.
      - MappingJackson2HttpMessageConverter라는 컨버터 내부에서 ObjectMapper를 통해 JSON 값을 Java 객체로 변환해주는데 이 작업을 역직렬화라고 한다.
      - 이 과정에서 리플렉션을 통해 역직렬화를 사용하는데 직렬화가 가능한 클래스들은 기본 생성자가 필수적으로 정의되어 있어야 한다.
      - 또한 데이터 바인딩 과정에서 필요한 필드명을 알아내기 위해 getter나 setter 1가지는 정의되어 있어야 한다.
  - @ModelAttribute를 사용하면 HTTP 파라미터 데이터를 Java 객체에 맵핑한다.
    - /modelattribute?name=req&age=1 같은 Query String 형태 혹은 요청 본문에 삽입되는 Form 형태의 데이터를 처리합니다.
    - JSON 데이터를 POST 하는 요청에는 사용이 불가능하다. 즉, Query String 및 Form 형식이 아닌 데이터는 처리할 수 없다.
    - Client의 HTTP 파라미터 데이터를 Java 객체에 맵핑하는 과정에서 파라미터 데이터를 바인딩할 수 있는 생성자 혹은 setter 메서드가 필요한다.
  - @ResponseEntity : @ResponseBody와 같지만 status와 header를 갖고 있다.
    - status와 header를 먼저 반환하고 body 내용을 나중에 반환하는 비동기식으로 동작하는 것도 지원한다는데 아직은 정확히 모르겠다.
  - 컨트롤러에서 String을 반환하는 것은 viewResolver 구현체에 의해 resolve되는 view의 이름이다.
- Exception
  - @ExceptionHandler를 붙인 메서드가 존재하는 controller 객체에서 발생하는 예외를 처리할 수 있다.
    - ExceptionHandler 어노테이션과 같이 예외처리할 예외 클래스를 명시한다.
    - @ControllerAdvice 혹은 @RestControllerAdvice 클래스에 선언된 @ExceptionHandler, InitBinder, @ModelAttribute 메서드들은 모든 컨트롤러에 적용 가능하다. 

## 23.04.13

### jwp-racingcar PR 메세지 질문 정리
- 기존 Java 콘솔 기반 프로젝트를 웹 기반 서비스로 마이그레이션하는 것이 미션의 주 목표였던 것 같은데 스프링을 거의 모르는 상황에서 빠뜨린 부분은 없는지 궁금합니다.
  - 기존 콘솔 도메인 로직 수행에 필요한 값들을 받아오거나, 결과값을 외부로 반환하는 과정의 코드를 수정하는데 집중했습니다.
- Dto 패키지 분리
  - 이번 프로젝트를 진행하면서 Controller와 Service 사이에서 주고 받는 데이터를 관리하기 위해 request, response Dto를 설계했습니다.
  - 그런데 Service와 Repository 사이에서 주고 받는 데이터를 관리하기 위한 객체를 설계하는 과정에서 객체의 네이밍과 패키지 분리가 고민되었던 부분 같습니다.
  - client가 요청하고 그에 대한 응답을 담아서 보낸다는 의미에서 request, response라는 단어를 사용했는데, Service와 Repository 사이에는 이런 직관이 적용되기 힘들었던 것 같습니다.
  - 혹시 Service와 Repository 사이에서 주고 받는 데이터를 관리하는 책임을 지는 객체를 Dto로 설계하는 것이 적합할지, 적합하다면 그 네이밍은 어떻게 해서 Controller ~ Service 간 사용되는 Dto와 분리시킬 수 있을지 질문드립니다.
- 테스트를 어떻게 진행해야 하는지?
  - 기존에 Domain을 미리 구현해둔 상태였기 때문에 새로운 테스트 코드를 작성한다고 하면 어떤 부분에 대해 작성해야 하는지 감이 잡히질 않았습니다.
  - Controller, Service, Repository 등 Layered Architecture 구조를 사용하게 되면서 각 계층에 대해 테스트를 어떻게 진행해야 하는지 큰 방향에 대한 감을 좀 잡고 싶습니다.
  - 그리고 테스트에 DB의 영향을 우회하기 위해 테스트 객체들을 Mocking해야 할 것 같은데 이런 부분도 어떤 방식으로 진행하면 좋을지 여쭤보고 싶습니다.
- Dao에 도메인을 넘겨도 되는가?
  - 페어와 미션을 진행하면서 의견이 갈렸던 부분이었습니다.
  - Dao에 저장하기 위한 데이터를 전달하거나 받아오는 책임을 수행하는 객체로 Dto를 설계해 따로 둬야한다는 것이 저의 입장이었습니다.
  - 그러나 제 페어는 어떤 당위성에 의해 domain을 dao로 넘기면 안되는지에 대해 의문을 제기했습니다.
  - DB를 다루는 코드와 domain은 분리해야 각종 변경으로부터 domain을 지킬 수 있다고만 생각해왔던 저는 결국 페어를 완전히 설득하는데 실패했었습니다.
  - 미션을 진행하면서 game_id와 carDto를 함께 넘겨줘야 하는 상황 때문에 Dto를 구현하는 방향으로 진행하긴 했으나 명혹하게 저만의 기준이 아직 확립되진 않은 것 같습니다.
  - 이 부분에 대한 범블비의 의견을 여쭤보고 싶습니다!


### 솔라 미팅
- 레벨2에서의 핵심은 공식 문서를 통해 새로운 기술을 학습하는 방법을 찾아 정립하는 것이다.
- 공식 문서를 봐야만하는 이유는 여러가지가 있다.
  - 기술은 결국 만든 사람이 제일 잘 안다.
  - 다른 사람이 정리한 글에는 그 사람의 주관이 들어갈 수 밖에 없기 때문에 신뢰성이 떨어진다.
  - 최신 버전의 기술을 사용하게 될 수록 의지할 곳은 공식 문서밖에 없다.
- 개발자는 결국 학습하는 사람이 아니라 서비스를 만들어야 하는 사람이다.
  - 처음 접하는 기술을 최대한 빠르고 효율적으로 내가 만들어야 하는 것에 사용할 수 있도록 하자.
- 레벨2에서 깊게 파보면서 왜라는 질문을 던질 부분은 스프링보다는 DB나 웹 부분이다. (추천도서가 그렇게 결정된 이유도 이 때문이다.)

### Spring JDBC 학습 테스트
- Data Access with JDBC
  - JDBC Data Access를 하는데에는 몇가지 접근 방법 중 하나를 선택한다.
    - JdbcTemplate
    - SimpleJdbcInsert
    - SimpleJdbcCall
  - QueryingDao
    - jdbcTemplate의 query 혹은 queryForObject 메서드를 사용해 쿼리를 날려 값을 조회할 수 있다.
    - 인자로 rowMapper를 구현해 사용할 수 있다.
    - query문에 명시된 ?를 통해 값을 할당할 수 있다.
  - UpdatingDao
    - 만약 keyHolder라는 개념을 아예 모르는 상황에서 어떻게 공식문서에서 이를 찾아서 학습할 수 있을까?
      - 나는 JdbcTemplate을 이용해서 update를 수행하고 싶다.
      - 공식문서를 찾아본다. 하지만 기본적인 update 설명만 나와있고 더 자세하게는 안나와있네?
      - 자세히보다보니 공식문서에는 JdbcTemplate의 몇가지 용법만을 다루고 자세한 전체 구현 기능들은 javadoc을 참고하라며 링크를 걸어준다.
      - 공식문서에 나와있지 않은 기능을 찾고자 한다면 먼저 공식문서에 명시된 기능이 전부인지 확인한 후 만약 일부 용법의 예시만 나와있는 거라면 javadoc 등 전체 API 구현 리스트를 찾아서 볼 수 있도록 하자.
      - 그런데 KeyHolder는 interface네? 그럼 내가 직접 구현해줘야 하는가?
      - 자세히 살펴보니 javadoc에 잘 알려진 구현체에 대해 명시가 되어있다. 이걸 사용하면 된다! (그냥 인텔리제이에서 new 연산자 사용해서 자동완성 확인해보는 것도 괜찮을 듯...?)
    - 공식문서에서 key와 관련된 기능은 없는지 잘 찾아보는게 우선순위!
  - namedParamDao
    - @NamedParameterJdbcTemplate 어노테이션이 사용된 클래스는 변수명이 붙은 매개변수를 사용해서 JDBC statement 프로그래밍을 지원한다.
    - SQL 쿼리문의 :(콜론)은 바인드 변수를 표현하고자 할 때 사용한다.
    - SQL 쿼리문에 변수를 바인드할 때 SqlParameterSource 구현체 중 하나인 MapSqlParameterSource 구현체를 사용해서 변수 매핑 정보를 나타낼 수 있다.
      - 반환 타입인 SqlParameterSource는 변수 매핑 정보를 담은 객체를 만들 수 있다.
    - SqlParameterSource 구현체 중 하나는 BeanPropertySqlParameterSource 클래스이다.
      - 명명된 변수 값들을 가져오는 출처로 JavaBean을 사용한다.
    - NamedParameterJdbcTemplate 클래스는 JdbcTemplate 클래스를 wrapping한 클래스이기 때문에 순수 JdbcTemplate 기능이 필요한 경우 getJdbcOperations 메서드를 사용해서 접근할 수 있다.
- SimpleInsertDao
  - SimpleJdbcInsert 객체를 생성할 때는 dataSource 객체를 매개변수로 넘겨줘야 하는데 여기에는 DB 연결정보가 저장되어 있는 듯하다.
    - 그리고 insert할 테이블 명과 자동으로 생성되는 key 등을 지정할 수 있다.
    - Map 자료구조 혹은 BeanPropertySqlParameterSource 등을 이욯해서 SimpleJdbcInsert 객체의 execute 메서드를 실행할 수 있다.


## 23.04.14
### 웹 자동차 경주 첫번째 미션 피드백
- 새로운 지식을 학습하는 방법 (예시)
  - 테스트를 하는 방법을 어떻게 알 수 있을까?
  - 접근 방법 / 키워드 찾기
    - 웹 요청 응답에 대한 테스트를 작성해보고 싶은데 어떻게 진행할 수 있지?
    - 기존 코드를 참고해서 진행할 수 있다. (학습 테스트 코드를 참고해서 진행)
      - 비슷한 기능을 구현한 기존 코드를 보고 감을 잡는다.
      - 검색, chatGPT 등 익숙한 도구를 사용해서 접근하는 것도 좋다.
    - 사용하며 익숙해지기
      - 일단 구현해본다.
    - 정확한 내용 확인/학습하기
      - 공식문서에 해당 내용을 찾아서 내용 검증이 필요하다.
      - 구글에 site: spring.io 로 필터링해서 검색해볼 수 있다.
      - phind 라는 홈페이지에서 개발자를 위한 AI 검색 엔진이 있다. 한 번 사용해보자!
      - 처음부터 다 읽는 것은 너무 힘들 수 있으니, 일단 하던대로하고 마지막에 확실한 내용검증을 공식문서로 진행해보도록 하자.
- 키워드를 학습하기 위해 공부를 하는데 모르는 키워드가 너무 많이 쏟아져서 어떻게 학습해야 할지 모르겠다.
  - 스프링의 메커니즘을 찾아보다가 나온 상황이라면 경험이 부족해서 그런 것이기 때문에 사용경험을 더 쌓아야 한다.
  - 그냥 사용을 하고 싶은데 너무 접근이 어렵다는 상황이라면 키워드들을 일단 쌓아두고 사용을 하면서 시간이 자나면서 주기적으로 다시 확인해보는 식으로 진행하자.
  - 지금 드는 걱정이 맞으니 너무 걱정 하지 말라. 학습해야할 양에 압도되어 조바심을 느끼진 않았으면 좋겠다.

### Spring MVC
- 요청과 응답
  - 클라이언트와 서버는 지속적으로 요청과 응답을 하는데 HTTP 프로토콜을 사용하게 된다
  - 여기서 Request, Response 메세지 형식이 있는데 이에 대해 한 번 알아보자.
  - 이 요청을 스프링 MVC가 어떻게 처리해주지?
  - 요청에 따라 적절하게 기능을 수행할 수 있는 컨트롤러를 맵핑해준다.
  - 응답의 형식은 html 페이지가 될수도 있고, Json이 될 수도 있다.
- RestController는 controller와  requestBody 어노테이션을 포함한다. (공식문서에 나와있다.)
  - 따라서 restController 안에서 requestbody를 쓴다면 적절하게 사용한 게 아니다.
- ResponseEntity를 리턴하게 되면 헤더와 상태를 추가할 수 있다.
  - 리턴 타입을 ResponseEnitiy 등으로 래핑할지 안할지 일관성을 지켜주는 것이 좋다.
  - 제네릭을 로우 타입으로 사용하지 말자. 정확하게 사용하는 것을 지향하자.
  - 최대한 학습 레퍼런스로 걸려있는 부분들을 정확하게 미션에 적용하려고 노력했으면 좋겠다.
- JDBC
  - 스프링이 제공하는 JDBCTemplate을 사용하게 되면 connection을 열고 닫는 코드를 직접 작성해줄 필요가 없어진다.
  - Jdbc데이터베이스 접근 방법에는 여러 종류가 있는데 단순하게 접근이 된다고 넘어가지 말고 어떤 접근 방법을 왜 사용했는지 정리하고, 사용 판단 기준을 세워보자.

### 코수타
- 스프링을 잘 아는 크루와 같이 페어를 하게 된다면 질문을 계속 던져보자.
- 레벨 1과는 다르게 레벨2에서는 계속 뭔가를 프레임워크를 만들어보는 경험을 쌓는 것이 더 중요하다.
- 학습해야할 키워드가 너무 많아지는 레벨2인데 지금 선택과 집중을 반드시 해야한다.
  - 프레임 워크 학습을 좀 더 집중한다면 HTTP, DB등의 키워드 학습은 조금 얕게 가져가는 식으로 진행하기.
브리의 조언
  - 한번에 학습하는 키워드의 개수를 제한해보는 것은 어떨까?
  - 일단은 사용하는 방법을 먼저 익히는 것을 우선으로 진행해보자. 결국 이것이 나중에 현업에서 모르는 새로운 기술을 사용해야 할 때에도 동일한 상황이 될 것이다.
  - 학습의 depth를 의식적으로 제한할 수 있는 방법을 생각해서 적용해보자!

### Spring Core
- @Repository는 DAO라고 알려진 repository의 정형화된 조건을 충족하는 어떠한 클래스를 가리키는 어노테이션이다.
- Spring은 @Component, @Service, @Controller라는 고정 어노테이션들을 추가 제공한다.
- @Component
  - @Component는 스프링이 관리하는 모든 컴포넌트들을 위한 일반적인 고정 타입이다.
  - @Repository, @Service, @Controller는 @Component의 구체화된 어노테이션들이다.
  - 구현한 component 클래스들에게 @Component 어노테이션을 사용할 수 있지만 @Repository, @Service, @Controller와 같은 구체화된 어노테이션을 사용하면 도구로써 사용하거나 의미상으로 연관짓기 더 적합해진다.
    - 구체적인 어노테이션을 사용하면 미래에 릴리즈 될 스프링 프레임워크의 추가적인 의미를 담게 할 수도 있다.
    - 이러한 연유로 서비스 레이어에 @Component 보다는 @Service 어노테이션을 사용하는 것이 더 나은 선택이다.
- 자동 클래스 탐색 및 Bean Definitions 등록
  - 스프링은 자동으로 고정 타입 클래스를 식별하고 일치하는 BeanDefinition 인스턴스들을 ApplicationContext에 등록한다.
  - 클래스들을 자동 식별하고 일치하는 빈들을 등록하기 위해서는 @Configuration 클래스에 @ComponentScan 어노테이션을 추가해줘야 한다.
  - @Configuration 클래스는 basePackages는 자동 등록하고자 하는 클래스들의 공통 부모 패키지에 속해야 한다.
  - 현재 학습테스트 코드에서는 HelloApplication이라는 최상위 패키지의 메인 클래스에 @SpringBootApplication 설정이 되어있다.
    - @SpringBootApplication 어노테이션 내부에 @ComponentScan 설정이 되어 있어서 자동등록이 되는 것이다.

- dependency Injection
- D.I는 아래의 것들만을 통해 객체가 스스로의 의존성을 정의하는 방식을 말한다.
  - 생성자 매개변수
  - 팩토리 메서드의 매개변수
  - 팩토리 메서드의 반환 타입 혹은 생성 이후의 객체 properties
- 컨테이너는 bean을 만들 때 객체들의 의존성을 주입한다. 즉 객체 생성의 제어권이 컨테이너에게 있다.
- 이러한 의존성 주입은 기존 객체 생성과는 정반대의 과정이다. (Inversion Of Control - 제어의 역전)
  - 기존에는 직접 클래스가 자신의 생성자 혹은 Service Locator Pattern을 사용해서 자체적으로 의존성의 인스턴스화 혹은 의존성의 위치를 제어할 수 있었다.
  - 그러나 이러한 제어를 컨테이너가 직접 행하기 때문에 이러한 과정을 제어의 역전이라 부른다. (Inversion of Control)
- DI 원칙을 적용한 코드는 더 깔끔하고 객체들이 의존성이 주입된 상태로 제공될 때 결합도 낮추기가 더 효과적이다. 
  - 객체들은 더이상 의존성을 탐색하지 않고 의존관계의 클래스 혹은 위치를 알지 못한다.
  - 결과적으로 클래스는 테스트하기 더 쉬워졌다. 
    - 특히 추상클래스나 인터페이스에 의존하는 경우는 mock이나 stub을 구현하여 unit test등에 사용하는 것을 허용하기 때문에 특히 더 쉽다.
- constructor 기반 의존성 주입
  - 생성자 혹은 정적 팩토리 메서드의 매개변수를 통해 의존성을 주입하는 방식
- setter 기반 의존성 주입
  - setter 메서드의 매개변수를 통해 의존성을 주입하는 방식
- constructor 기반 의존성 주입과 setter 기반 의존성 주입 방식의 차이
  - constructor 기반 의존성 주입은 필수적인 의존성 주입이 필요한 경우 사용한다.
  - setter 기반 의존성 주입은 선택적인 의존성 주입이 필요한 경우 사용한다.
    - setter 기반 의존성 주입은 선택적이기 때문에 이를 통한 의존성 주입을 강제하고 싶은 경우 @Autowired 어노테이션을 메서드에 붙여줘야 한다.
- Field Injection
  - @Autowired 어노테이션을 사용한다.
  - @Autowired 어노테이션은 선언된 생성자, 필드, setter 메서드 등은 spring의 DI 관리부에 의해 autowired된다.








