# LV2 14주차 (23.05.08 ~ 23.05.14)

---

## 23.05.09
### 3주차 지하철 노선도 미션
- 목표
  - 복잡한 도메인 기반 웹 애플리케이션 개발 경험
  - 통합테스트와 단위 테스트를 이용한 기능 구현 경험
    - 통합 테스트를 이용하여 기능의 큰 그림 그리기
    - 단위 테스트를 이용하여 세부적인 요구사항 구현
  - Configuration, Profile을 이용하여 프로젝트 설정
  - Datasource를 이용한 데이터베이스 설정

- 뼈대코드가 베스트 프랙티스로서 제공된 것은 아니고 밈션 시작하는데 도움을 주기 위한 것이다.
- CRUD 기반으로 더 집중해줬으면 하는 부분이 있어서 제공하는 것이다. (수정해도 된다!)
- 열번 구현하는데 TDD를 한 두번이라도 수행하면 TDD를 한 것이다. 점점 횟수를 늘려가면서 TDD 역량을 늘려가자.


### TDD with Spring
- 어떻게하면 코드를 이쁘게 짤수있을까 생각하다보면 우리는 레벨1때 테스트의 가호 아래에서 코드를 짰었다.
- 테스트 라이브러리에 대한 이해가 기반이 된다면 이해가 조금 더 쉬워질 것이다.
- 단위 테스트 
  - 단위 테스트가 하나의 프로덕션 코드를 가리키는 경우도 있고, 여러 개의 프로덕션 코드를 묶어서 가리키는 경우도 있다.
  - 단위 테스트라는 단어를 들으면?
    - 작은 코드 조각(단위)을 검증, 빠르게 수행 가능, 격리된 방식으로 처리 => 흔히 단위테스트에 대한 특징으로 통용되는 세가지
  - 테스트에서 테스트 대상을 검증하기 위해 필요한 협력 객체의 유무에 따라 완전히 다른 테스트가 될 수 있다.
    - 협력객체가 없는 테스트라면 구현하기 쉬웠을 것이다.
    - 테스트하기 어려웠던 경우는 대부분 협력객체가 존재하는 경우다.

- 테스트 더블
  - 실제 객체 대신 사용되는 모든 종류의 객체에 대한 일반용어
  - 즉, 실제 클래스, 모듈, 함수등을 가짜 버전으로 대체한다는 의미이다.
  - 테스트 더블에는 DummyObject, TestStub, TestSpy, MockObject, FakeObject 등이 있다.

- 통합(Sociable) vs 고립(Solitary)
  - 협력 객체를 실제 객체로 사용하는지, Mock 객체로 사용하는지에 따라 테스트 구현이 달라지는데 통합 테스트와 고립 테스트로 나뉘어진다.
  - 통합테스트는 협력 객체를 실제 객체로 사용
    - 통합 테스트에서 보통 integration을 사용하는데 여기서 말하는 Sociable이라는 용어를 사용해서 다른 의미로 사용되는 것이다.
  - 고립 테스트는 협력 객체를 가짜 객체를 사용(Mock)

- 테스트 코드를 볼 때 다른 부분보다 when 부분을 먼저 보는 것이 도움이 된다.

- Stub
  - 협력 객체가 DB에 접근해서 값을 가져와 테스트 대상에게 데이터를 제공해주는 역할을 수행하는 구조로 테스트를 짰다고 가정하자.
  - 이때 테스트는 협력 객체의 정상 작동에 의존하게 된다. 즉 테스트의 정상 작동이 DB와의 정상적인 통신 여부에 의존하게 되는 것이다. 
  - Stubbing은 이러한 협력 객체가 가지는 의존성을 없애기 위해 stub 객체를 사용하는 것이다.
    - 요청을 했을 떄 실제 DB와 통신을 수행하지 않고 바로 특정 응답이 오도록 설정을 해주는 것.
    - 이처럼 미리 약속된 행위를 지정하고 테스트를 진행하는 방식이 stubbing인 것이다.
  - Stub 객체를 만드는 방법은 여러가지가 존재한다.
    - 모키토의 mock()메서드를 사용한다.
    - Mockito Exctension을 사용한다.
      - @ExtendWith(MockitoExtension.class)를 사용하면 스프링 빈을 주입받는 것처럼 mock 객체들을 주입받을 수 있게 된다.
        - 여기서 ExtendWith는 Junit5 에서 테스트를 확장하고 커스터마이징해서 다양한 기능들을 추가할 수 있도록 해준다.
      - @ExtendWith 어노테이션을 테스트 클래스나 메서드에 적용한 이후 Mock 객체를 주입받을 파라미터에 @Mock 어노테이션을 선언해준다.
    - Spring을 활용한 Stubbing
      - Spring 컨테이너에서 관리되는 빈들을 Mock 객체로 활용하고 싶을 때 사용가능하다.
      - @ExtendWith(SpringExtension.class) 어노테이션을 통해 테스트 클래스 혹은 메서드를 확장시켜준다.
      - 이후 @MockBean 어노테이션을 이용해 스프링 빈에 등록된 빈을 mock 객체로 만들 수 있다.
- 여기서 사용되는 Mock이라는 용어는 테스트 더블이라는 의미를 대체해서 나타내는 경향이 있다고 한다.
- 테스트 더블을 하기 위해서는 스텁을 만들어야 하고 스텁은 mock으로 만들 수 있다. 정도로 이해하고 넘어가자.


- Stub을 잘 알기 위해서는 mock과의 차이를 잘 알아야한다.
  - stubbing은 상태를 검증 / mocking은 행위를 검증한다고 일반적으로 많이 설명한다.
  - Stubbing을 사용하면 일반적으로 어떤 기능을 수행할 때 필요한 협력 객체를 mock 객체로 사용하는 경우가 많다.
    - mock 협력 객체들을 활용해서 수행하는 기능이 제대로 수행되었는지에 대해 검증하게 된다.
    - 그래서 테스트를 진행하기 전에 mock 객체들이 호출되었을 때 어떻게 수행되어야 하는지 설정을 해주고 본 테스트를 진행하게 된다.
    - 이 때 목표 테스트 객체의 특정 결과 값 혹은 상태 값을 검증하는 경우가 주를 이루기에 상태를 검증한다고 일반적으로 표현한다.
  - mocking을 사용하면 테스트하고자 하는 실제 객체를 Wrapping한 mock 객체가 존재해야 한다.
    - 특정 객체의 메서드가 호출이 되었는지, 몇 번 호출이 되었는지를 검증하게 된다.
    - 이 실제 객체를 Wrapping하는 mock 객체는 실제 객체의 메서드를 포함할 뿐만 아니라 이 메서드들이 몇 번 호출되었는지에 대한 정보와 같은 것도 상태값으로 관리한다.

- 결론! : mock() 메서드를 사용해서 반환되는 객체는 동일하지만 stub 객체로 활용될 수도 있고,mock 객체로 활용될 수도 있다.

- Fake 방식
  - mock 객체를 사용하지는 않고 fake 방식으로 단위테스트를 만든다고 생각하면 된다.
  - stub과 비슷하게 느껴질 수 있는데 자세히 뜯어보면 다르다.
    - stub은 메서드 호출이 발생했을 때 어떤 결과 값을 반환하게 할 지 설정해서 테스트를 진행한다고 생각하면 된다.
    - fake는 실제 객체와 비슷하지만 다르게 동작하는 fake 객체를 실제로 구현해서 테스트 시에 이 fake 객체를 이용해 수행할 수 있도록 하는 것을 말한다.
    - 즉 실제로 객체를 구현해야 되는지 안해도 되는지가 가장 큰 차이라고 보여진다.

- spy 방식
  - 실제 객체에서 일부 몇 개의 메서드만 바꿔서 테스트를 수행하도록 해주는 방식을 일컬음.

- Classist VS Mockist
- 협력 객체를 실제 객체로 사용해야 할까? 아니면 가짜 객체로 사용해야 할까?
  - 실제 객체를 사용하면 협력 객체의 행위를 협력 객체 스스로가 정의
  - 가짜 객체를 사용하면 협력 객체의 행위를 테스트가 정의
- 가짜 객체를 협력 객체로 사용하는 경우
  - 테스트 대상을 검증할 때 외부 요인(실제 협력 객체들)으로부터 철저하게 격리
  - 하지만 테스트에서 협력 객체의 세부 구현사항을 알아야한다. (세부 구현사항을 알아야 어떤 값이 반환될 지 알고 이를 설정해줄 수 있기 때문)
- 실제 객체를 협력 객체로 사용하는 경우
  - 테스트에서 협력 객체들의 구현이 어떻게 되어 있는지 알 필요가 없다.
  - 테스트의 성공 여부가 협력 객체들의 정상 동작 여부에 의존하게 된다.

- 테스트를 바라보는 관점이 다른 두 학파에서 갈리는 지점은 단위 테스트가 격리된 방식으로 수행되어야 한다는 것이다.
  - 여기서 말하는 격리를 어떻게 바라보는지에 따라 갈린다.
    - 테스트와 테스트간의 격리 : Classist
    - 테스트 객체와 협력 객체 간의 격리 : Mockist

- Classic TDD (Inside-out)와 Mockist TDD (Outside-In) 방법 간에는 장단점이 명확하다.
  - Outside-In 방식
    - 객체지향과 TDD에 익숙하지 않은 사람들에게 가이드할 때 도움이 된다고 생각된다.
    - 도메인에 대한 이해도가 높지 않은 상태에서도 진행이 가능하다.
    - 상대적으로 프로덕션 코드에 의존적인 테스트가 작성된다. (깨지기 쉬운 테스트)
      - 협력 객체들을 mocking 하기에 추후 실제 객체의 내부 로직이 변경되었을 때 이를 Mocking 객체에도 직접 반영해줘야 하기 때문이다.
  - Inside-Out 방식
    - 도메인 설계가 충분히 이루어진 다음 진행이 가능하다.
    - TDD 사이클을 이어나가기가 상대적으로 어렵다. (협력 객체를 실제 객체로 사용해야 하기 때문이다.)
    - 프로덕션 코드에 상대적으로 덜 의존하는 테스트가 작성된다.
      - 협력 객체들을 실제 객체들로 사용하기에 실제 객체의 내부 로직이 변경되어도 테스트 하는 기능의 결과가 바뀌지 않는다면 테스트 코드는 깨지지 않기 때문이다.

그러면 우리는 어떤 기준을 가지고 TDD를 수행해야 하는가?
- 켄트벡 TDD 책에서...
  - 사실은 상향식, 하향식 둘 다 TDD의 프로세스를 효과적으로 설명해 줄 수 없다.
  - 만약 어떤 방향성을 가질 필요가 있다면 '아는 것에서 모르는 것으로(known-to-unknown)'방향이 유용할 것이다.
  - 이러한 방향성은 우리가 어느 정도의 지식과 경험을 가지고 시작한다는 점, 개발하는 중에 새로운 것을 배우게 될 것임을 예상한다는 점 등을 암시한다.
    
추천하는 방법!
- Top-Down으로 방향을 잡고, Bottom-Up으로 구현하기
- 인수 테스트(통합 테스트) 작성을 통해 요구사항과 기능 전반에 대한 이해를 선행
- 내부 구현에 대한 설계 흐름을 구상
- 설계가 끝나면 도메인부터 차근차근 TDD로 기능 구현
- 만약 도메인이 복잡하거나 설계가 어려울 경우 이해하고 있는 부분부터 기능을 구현한다.

블라디미르 코리코프 - 단위 테스트 책에서 단위 테스트 부분만 찾아서 읽어보자.


## 23.05.10
- 글쓰기 워크숍
- 소재 탐색 및 목차만들기 목표

준 : 목차를 만들때 고려하면 좋을 질문
'어떤 목차를 추가하면, 저자 말하고자 하는 핵심 씨앗이 더 잘 드러날까?;

예를 들어, '개발자들은 헬스가 건강에 도움이 됩니다'라는 씨앗을 만들었다면, 내가 어떤 목차를 추가하면 개발자 독자들이 헬스를 하고 싶은 마음이 들까?를 고민해주시면 됩니당~!

의도를 전달해주는 하나의 제품이라고 생각하고, 제품의 핵심 메시지가 더 잘드러나게 도와주세요~~


## 23.05.14
### 지하철 미션 1차 코드리뷰 정리
- 객체지향 생활체조 규칙 다시 적용시켜 보기
- 지하철 역 애플리케이션을 통해 하고 싶은 것, 즉 use-case가 무엇인지 파악하지 않고 직관에 따른 도메인 설계를 진행
  - 이렇게 설계된 domain에 어플리키에션의 use-case를 맞추려고 해서 어긋난 부분들이 많다.
  - 해결책은 해결해야 하는 요구사항에 맞춰서 도메인 모델을 나누는 것.
  - 앞으로는 도메인을 위한 도메인 혹은 우리의 직관에 따른 도메인이 아니라 요구사항을 충족시키기 위한 도메인을 설계해야 함을 잊지말자...!
- 현재 요구사항에 존재하지 않는 API들이 많이 구현되어 있다.
  - 비즈니스 요구사항을 기술적으로 풀어내는 것이 최우선순위.
  - 기술이 어려워서 비즈니스 요구사항을 충족시키지 못하는 상황은 없어야만 한다.
- 고객이 원하는 기능을 고객이 원하는 시점에 전달하는 것. 개발자 뿐만 아니라 돈을 받으며 일을 하는 프로로서 당연히 지켜야 할 원칙이다.
  - 아무리 급해도 항상 80~90점 짜리 소프트웨엉를 일정 내에 개발할 수 있는 방법을 연구하고, 연마해야 한다.
  - 이것이 바로 경력이고, 잠밥이고, 생산성이다.
  - 실력이 뛰어난 개발자들은 본인만의 원칙을 기준으로 빠르게 의사결정을 진행한다.
  - 그동안 경험을 통해 여러가지 확고한 원칙을 세웠기 때문에 대부분의 경우 빠르게 결정을 내릴 수 있고, 정말 설계가 필요한 부분에 대해서만 깊은 고민을 진행할 수 있게 된다.
  - 이렇게 되면 일정은 일정대로 지켜지고, 퀄리티가 정말 중요한 부분에서도 퀄리티를 챙길 수 있게 된다.



- 이번 미션에서 API 기능 요구사항의 use-case를 고려하지 않고 우리의 직관대로 도메인을 설계한 것이 어려움의 큰 요인이었다.
  - 다시 API 기능 요구사항을 기반으로 설계를 변경하기 위해 API 통합 테스트를 먼저 확인하고 수정하자.
  - 어디까지가 프론트의 책임이고 백엔드의 책임인지 모호한 것 같다. 일반적으로 팀 회의를 통해 결정해서 팀마다 그 기준이 상이할 것이라 생각한다.
  - 이번에 페어와 미션을 진행하면서 프론트 입장에서는 이미 어떤 역들이 어떤 순서로 노선을 구성하는지에 대한 정보를 알고 있는 상태로 역에 대한 작업을 수행할 것이라 생각했다.
  - 그래서 삽입/삭제 하고자 하는 역이 중간에 있는 역인지, 종점인지, 노선에 처음 추가되는 역인지 알고 요청을 할 수 있다고 가정했었다.
  - 그런데 현구막은 왜 처음 API를 봤을 때 백엔드의 책임이 프론트의 책임으로 넘겨둔 것이라고 느꼈는지 그 이유에 대해 질문드리고 싶다.

- 도메인에서 노선에 등록된 역의 순서를 외부 라이브러리에 의존하는 방식이었는데 이를 수정했다.









