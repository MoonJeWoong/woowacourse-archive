# LV2 11주차 (23.04.17 ~ 23.04.23)

---

## 23.04.18
- jwp-racingcar 피드백
- 의존 방식에 따른 결합도
- 객체와 객체 사이에 의존성은 어쩔 수 없이 생기는 것인데 왜 신경쓰며 개발해야 할까?
  - 변경에 대한 파급효과를 줄이기 위해 최소한의 의존성만 남겨두는 것이 좋다.
- 두 객체가 있을 때, 한 객체가 다른 객체를 사용, 생성을 한다면 생성, 사용하는 객체가 다른 객체에 의존하는 것이다.
- 객체의 생성과 사용을 모두 의존하는 경우 테스트도 어려워지고, 변화에 취약해지게 된다. 협력의 문맥이 고정된다(테오), 한 클래스 내에서 사용과 생성의 책임을 모두 지고있다.
- 인터페이스를 구현해서 사용하게 되면 사용 부분에 대해서 의존성을 조금은 느슨하게 할 수 있다.
  - 하지만 아직 생성에 대한 의존성은 해결하지 못했다.
  - 그래서 생성책임을 다른 객체에게 위임하고자 한다.
- 객체의 생성은 팩토리 객체에게 위임한다.
  - 생성에 대한 의존성을 축소시킬 수는 있으나 완전히 없앨 수는 없다.
  - PlayResultDao라는 이름 자체가 남아있게 되기 떄문에 아예 의존성을 없앨 수는 없다.
- 조립기 : 의존성을 삽입해주는 역할을 지도록 하는 새로운 객체를 추가한다.
- 스프링은 객체를 생성하고 관리하는 역할을 수행한다.
  - IOC 컨테이너라고 스프링을 부르기도 한다.(빈 팩토리라는 표현도 사용하는 경우가 있다고 한다.) - 왜 이런 용어들을 사용하는지 정리해보는 것도 좋을 것 같다.
  - 컨테이너는 DI라는 방식으로 의존성을 주입해서 객체를 생성하고 관리한다.
  - 스프링 빈은 컨테이너가 관리하는 객체들을 일컫는다.
- 스프링 빈 설정의 방식에는 XML, Annotation-based Configuration, Java-based configuration 등이 있다.
- 이번 피드백에서는 어노테이션 기반 설정에 대해 알아본다.
- controller, service, repository 어노테이션으로 설정할 수 없지만 빈으로 관리하고싶은 객체는 Component 어노테이션을 붙였을 것이다.
- @ComponentScan 어노테이션을 통해 등록할 빈을 스캔할 classPath를 지정한다.
- 의존성과 관련된 문제들을 해결하기 위해 컨테이너가 등장하게 되었구나를 알고 있으면 좋을 것 같다.
- repository와 dao의 차이는 repository 어노테이션의 설명 도큐먼트 부분을 읽어보자.

- 솔라 : 아직 repository 는 아직 안써봣으니(보통ORM에서 본격사용) 당연히 모르는거 아닐까요? 나중에 사용해보셔야 진짜 차이를 알게될거같아요

- 모든 객체를 빈으로 만들것인가에 대한 문제인데, 어떤 객체까지 빈으로 관리할 것인가? 미션을 진행하면서 직접 느껴주면 좋겠다!

- 컴포넌트들을 최대한 많이 사용하면서 경험 기반으로 학습을 진행하도록 하자.

### 실습 진행
- @Component와 @Autowired의 차이?
  - @Component를 사용하면 빈으로 등록할 수 있다.
  - @Autowired는 생성자, setter, 필드, 메서드에 사용할 수 있다.
    - 스프링 컨테이너에서 관리되고 있는 빈에 등록이 되어 있으면 의존성을 주입시켜준다.
    - 첫 번째는 타입을 검사하고, 그 다음은 빈의 이름을 검사한다. 
    - 만약 동일하다고 판단되는 빈이 2개가 존재하면 예외가 발생한다.
- @Repository를 Dao에도 붙이는 이유?
  - Repository 어노테이션은 여러가지 구체적인 Persistence 예외 상황들을 통합된 스프링의 unchecked Exception으로 전환시켜주는 역할을 한다.
  - Dao에서 발생하는 예외는 최대한 발생한 지점에서 가까이 처리되어야 한다.
  - 또한 Repository는 Dao만을 사용해서 로직을 수행하지는 않는다. 다른 방법을 이용해 Persistence 계층의 기능을 수행할 수 있다.
  - 이 때 발생하는 예외들도 처리해줄 수 있어야 하기 때문에 repository 클래스에도 @Repository 어노테이션을 붙여줘야 한다.
- JdbcTemplate을 사용하는 객체에 @Repository를 붙여야 하는가 아니면 @Component를 붙여도 되는가?
  - JdbcTemplate은 내부적으로 Spring 에외로의 전환을 수행해준다. 그렇기 때문에 Component 어노테이션을 붙여도 상관 없다.
- 스프링 빈에서는 왜 전부 싱글톤으로 관리하는 걸까?
  - https://velog.io/@minwest/Spring-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%80-%EB%B9%88%EC%9D%84-%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%A0%EA%B9%8C


- 스프링에서 의존성을 주입하는 방법엔 어떤 것들이 있나요?
- 미션에서 어떤 방법을 사용했으며 그 이유는 무엇인가요?
  - 스프링에서 의존성을 주입하는 방법에는 생성자 주입, setter 주입, 필드 주입 이렇게 세 가지 방법이 대표적으로 존재합니다.
  - 저는 특별한 이유가 있지 않는 한 생성자 주입을 사용하고 있습니다. 
  - 그 이유는 현재 미션 수준에서 지연 초기화를 사용해야 하는 객체들이 존재하지 않기 때문입니다. 
  - 그래서 항상 생성된 객체는 온전히 초기화가 완료되어 있어야 하는데 이를 생성자 의존성 주입 방식을 사용함으로서 강제할 수 있습니다. 
  - 이러한 이유로 저는 생성자 의존성 주입을 사용합니다.

- 애플리케이션의 모든 객체를 스프링 컨테이너가 관리할 필요는 없습니다. 그렇다면 어떤 객체를 스프링 빈으로 등록해야할까요? 
- 이번 미션에서 스프링 빈으로 등록한 객체를 기반으로 스프링 빈으로 관리할 객체에 대한 기준을 정해 보세요.
  - 비즈니스 로직을 수행하는 도메인 객체들 간의 의존성을 제외한 나머지 계층형 아키텍처 구조에서 존재하는 의존성들에 대해서는 스프링 빈으로 관리를 해보려고 합니다. 
  - 도메인 간의 의존성은 깨졌을 때 처음 설계한 의도와 다르게 비즈니스 로직이 수행될 가능성이 있다고 봅니다.  예를 들어 아직 초기화가 진행되면 안되는 객체가 미리 초기화 되어버린다는 문제등이 발생할 수 있을 것 같습니다.
  - 하지만 스프링 프레임워크의 구조를 따르는 controller - service - repository 등의 큰 구조를 구성하는데 생기는 의존성은 오히려 스프링 빈으로 관리함으로써 더 편하지만 안전하게 애플리케이션을 개발할 수 있다고 정리했습니다!


## 23.04.19
### 이동욱님 특강
- 100군데 넣었다가 하나 된 두번째 직장이 zum...
- 자존감 기둥 만들기
  - 뛰어난 동료, 새로운 환경, 프로젝트 실패 등 자존감이 떨어질 수 있다.
  - 자존감의 여섯 기둥 - 책 , 기둥이 하나면 쉽게 무너질 수 있기 때문에 여러개를 만들어둬야 한다.
  - 글쓰기, 커뮤니티 참여, 운동, 독서, 멘토링, 전동료와의 대화 등....
  - 연차가 낮을 때부터 본인이 틀렸다는 것을 인정하는 연습을 하는 것이 좋다. 그것이 내 자존감을 무너뜨리지 않도록 하자.
- 회사를 다니면 회사일의 숙련자가 된다. 회사를 길게 다닌다고 개발 전문가는 되지 않았다.
  - 지속적으로 방법에 대해 고민하고 변화해야 한다.
  - 주니어때는 성과가 아니라 성장을 목표로!
  - 새로운 환경에서도 잘할 수 있는 사람인지? 적응할 수 있는 것이 중요하다.
  - 지금 잘하는 사람보다 지금 못해도 계속 상향곡선을 그리는 사람을 곁에 두는 것이 중요하다.
- SI 들어가서 학습했던 고민
  - 혼자서 사이드 프로젝트
    - A-Z 구현 경험
    - 기능 구현에만 집중
    - 깊게 공부하지 못함
  - 책 스터디
    - 높은 완주율은 좋았으나...
    - 내가 발표한 주제만 기억에 남는 문제가 있었다.
  - 직접 강의하는 것
    - 100% 내용 습득 가능
    - 강의 외적인 부가작업이 필요하다.
    - 낮은 시간 가성비의 문제
  - public 블로그
    - 온라인에 누구를 가르친다고 생각하고 글을 써보자
    - 온라인 모두가 리뷰어
    - 동료에게 공유 가능
    - 피드백의 부끄러움, 부끄러운 것보다 연차 낮을 때 빠르게 고치는 것이 더 중요하다.
- 지금은 블로그, 일일커밋, 독서, 오프라인 강좌 등의 방법을 사용한다.
  - 일일커밋은 컨디션이 좋든 안좋든 해야할 것을 정해서 하는 것이 중요하다.
  - 독서와 오프라인 강좌가 제일 중요했던 것 같다.
  - 가능하면 인증되고, 정제된 자료로 습득한다.
  - OREILLY 페이지에 연단위 결제하면 온라인으로 원서들을 볼 수 있다.
  - 클린코더스 강좌 엄청 좋다!
  - 나에게 맞는 가장 효율적인 훈련방법을 찾아야한다.
  - 계속 점검하고 더 좋은 방법을 찾아보고 시도한다.
- 자바, 스프링 mysql 기반을 사용하다가 다른 플랫폼으로 넘어가는 것이 무섭지는 않았나?
  - 그 동안의 학습과 성장은 모두 자바 스프링 mysql을 기반 삼아서 진행한 것들
  - 내가 그동안 공부했던게 이미 아는게 너무 많아져서 학습을 쉽게 느끼고 있는게 아닌가?
  - 완전 제로 베이스에서 그 동안의 학습 방법을 검증해볼 수 있는 시간
  - 최대한 빠르게 나에게 맞는 최적화된 방법을 찾아서 고도화시켜야 한다.
- 새로운 환경을 잘 배우는 방법
  - 테스트코드
  - 데브옵스 + aws + 온프레미스 인프라
  - 뷰, 리액트, 등 프론트엔드
  - 데이터 파이프라인
  - 노드, 타입스크립트
  - 돈보다 시간이 제일 비싸다.
  - 신뢰할만한 사람한테 돈을 지불하고 질문이 가능한 강의를, 코드 리뷰를 구매한다.
  - 코드리뷰 자체를 지원하는 강의들도 있다. (넥스트 스텝, 코드숨)
  - 강의가 없다면 강의 자료 만들듯이 샘플 프로젝트와 블로그 글을 만든다.
- 어떤 방식이 제일 잘 맞나
- 24시간 중 언제 가장 집중이 잘 되는가
- 어떤 환경에서 가장 집중이 잘 되는가

- 학습 주제
  - 우리한테는 1년 뒤의 문제일 것이다.
  - 회사 업무에서 만난 문제를 연구 정리 해결해서 커뮤니티에 공유하고 피드백을 받는다.
  - 당장 직면한 문제를 해결하고 주변 동료들에게 인정받고 그 외의 분야로 공부하는 것이 중요하다.
  - 이것이 결국 스노우볼 시너지를 불러온다.
  - 회사일을 빠르게 끝내고 스스로의 성장에 더 집중할 수 있게 된다.
  - 회사일과 공부를 따로 두지 말자!!

- 산만함 관리하기
  - 잦은 컨텍스트 스위칭을 하다보면 점점 산만해지는 자신을 발견하게된다.
  - 하지만 서비스 회사를 다니다보면 생길 수 밖에 없다.
  - 집중이 잘 되는 환경 구성하기
  - 출근전 1~2시간 집중하고 출근하기
  - 점심, 저녁시간 산책하기
  - 주 2~3회 운동하기

- 거인의 어깨에 올라타서 배우기
  - 뛰어난 사람 옆에서 배우기
  - C(CTO, CEO)레벨, 테크 리드와 가까이 일할 수 있는 것은 큰 기회!
  - 실무를 배우지는 않겠지만, 어떻게 커뮤니케이션하고, 어떻게 팀원들의 신뢰를 얻고 조직의 문화를 만들어가는지, 어떤 기준으로 결정을 내리는지 

- 보상
  - 줌에서는 나만 남고 다 퇴사
    - 일단 버티고 봤더니 최고참이되어 사람을 직접 면접하는 기회도 겪어보고 좋은 문화를 상상하며 만들어갈 수 있었다.
  - 배민에서는 정산 보정을 엄청 어렵게 했는데 이걸 하려고 내가 개발자했나라는 생각
    - 일단 버티고 봤더니 포인트 시스템 TF 리드라는 직책을 맡게 되었다.
  - 시련 뒤에는 항상 보물이 기다리고 있었다.

- 경험해봤으니 이번엔 **다른 선택**하기
- 남을 설득하는 방법 배우기
- 만약 팀원들이 매번 내 의견을 반대한다면 완벽한 논리가 중요한 게 아니다.
- 어떻게 협업을 하면서, 이 사람들과 함께 성과를 낼것인가, 어떻게 나를 인정하게 만들 것인가, 어떻게 이 사람들과 유대감을 만들 것인가
- 내가 잘하면 너네가 따라오겠지 마인드는 위험하다.
- 개발 실력이 중요하다고 해서 나머지가 오케이 되는 건 아니다.
- 그래서 소프트 스킬이 중요하다.

- 모든게 좋은데, 그 중 하나만 별로하면?
  - 그걸 얻어내는 방법을 모르면 매번 퇴사하는 것 외에는 방법이 없다.
  - 팀장만 별로고 나머지 다 좋은 회사라면 팀장을 내 사람으로 만드는 것이 중요하다.
  - 이런 것들을 지금 우테코 가장 낮은 수준의 환경에서 배울 수 있었으면 좋겠다.

- 내가 만약 단기전을 잘하는 사람이 아니라면 길게 보고 끝에서 잘되는 사람이 되어야지라고 생각하자.

- 학습 키워드 : 그때그때 방향을 바꾸지는 않고 깊게 파고드는 것 보다는 짧은 시간을 투자해서 끝냈다.
  - 지금 필요한 내용까지만 학습하고 다음으로 넘어간다.
  - 키워드를 정해진 시간 안에 끝내고 넘어가도록 하자.

- 꾸준함의 기준을 잘 잡아야 한다.
  - 그냥 단순하게 책을 정리해서 올리는 등의 글은 꾸준함이 아니다.
  - 정도는 상관 없다. 그저 조금씩이라도 나아지고 있는가? 가 꾸준함으로 보여질 수 있다.

- 대기업은 10%밖에 안된다.
  - 나머지 90%는 프론트, 데브옵스, 백엔드, 인프라 전부 다뤄야한다.
  - 어떤 분야의 개발자라고 생각하지말고 그냥 개발자라고 생각하자.
  - 문제를 해결하기 위해 가장 좋은 해결방법을 찾겠다.
  - 한 분야의 성을 쌓을 것인가?
  - 아니면 여러 분야를 두루 쌓아서 고객에게 사랑받는 상품을 만드는 경험을 해볼 것인가?
   
- 사파리 북스 번역을 돌려서 책을 보는 편이다.
- 실제 사람들이 사용할 수 있는 서비스를 만드는 것이 핵심
- 원대한 꿈이나 목표보다는 어떤 것을 얼마나 꾸준하게 최선을 다해서 할 수 있는지를 고민해보자.
- 어떻게 하면 더 프로그래밍을 재미있게 할 수 있을까를 고민했으면 좋겠다.

## 23.04.20
### 패캠 실습 강의
- 변수 넘겨받기
  - pathVariable
  - queryParam

### 2단계 PR 요청
안녕하세요 범블비, 히이로입니다!
지난 번에 리뷰 달아주셧던 부분들에 대해서는 이전 PR에 답글을 달아두었는데 한 번 확인해주시면 감사하겠습니다! 🙇
혹시 해당 부분에 대한 추가 피드백이 있다면 다음 리팩토링 시 반영해보도록 하겠습니다.

이번 2단계 미션을 진행하며 집중했던 부분은 다음과 같습니다.
(말씀해주셨던 대로 일단은 테스트에 대한 부분은 다음으로 넘겨두고 진행했습니다. )


- 각 계층 사이에서 어떤 객체와 데이터를 전송하는가에 대해 자신만의 기준을 확립해 보고자 했습니다.
  - controller와 service, 즉 Presentation Layer와 Business Layer 간에는 Request, Response 객체가 필요한 데이터를 전송하는 책임을 지도록 했습니다. 하지만 웹 서비스 상 직관성을 위한 네이밍일 뿐 수행하는 역할은 Dto와 동일했습니다.
  - service와 repository, 즉 Business Layer와 Persistence Layer 간에는 Domain 객체를 주고 받을 수 있도록 했습니다. 여기서 repository는 service 입장에서 객체의 컬렉션과 같이 동작하는 상태 값처럼 생각하고 구현했습니다. 그래서 service는 단순히 domain객체를 repository에 저장하고, 가져올 수 있는 양상을 가지게 되었습니다.
  - repository와 Dao, 즉 Persistence Layer 내부의 구성 요소 객체 간에는 Entity를 주고 받도록 했습니다. 여기서 Entity는 테이블에 추가되는 auto generated key 등과 같이 기존 Domain 객체는 가질 수 없는 데이터 또한 상태값으로 가질 수 있습니다. 결과적으로 Entity는 DB 테이블과 1:1 맵핑되어 DB에 데이터를 저장하거나 조회할 때 사용됩니다.

- Repository의 추상화
  - 미션 요구사항 중 기존 콘솔 프로그램 또한 동작하도록 해야하며 웹과 콘솔 기반 프로그램이 가진 중복된 로직을 제거하는 것이 있었습니다.
  - 저는 웹, 콘솔 기반 프로그램이 모두 공통된 Service 객체를 통해 비즈니스 로직을 수행할 수 있도록 리팩토링을 진행했습니다.
  - 해당 과정에서 Service가 가지는 Repository에 대한 의존성을 주입해줘야 했으나 스프링이 해주는 것이 아닌 직접 생성해서 주입해줘야 했습니다.
  - 그래서 콘솔 기반 프로그램은 DB와 연동하는 요구사항이 없었기에 RacingCarRepository를 추상화하고 Dao를 사용하지 않는 ConsoleRacingCarRepository를 구현하여 이를 수행하도록 했습니다.

  
이번 2단계에서도 여전히 스프링과는 친숙해지기 어려운 것 같습니다. 최대한 키워드에 대한 학습을 진행하며 미션을 수행했는데 만족스럽지는 않으나, 어떤 것 때문에 만족스럽지 못한지 모르는 상태가 지속되는 기분입니다... 😂 제가 놓치거나 부족한 부분 잘 짚어주시면 리팩토링 열심히 해보겠습니다!


## 23.04.21
### 웹 자동차 경주 피드백 2
- 레벨2의 목표는 무엇인가?
  - 아직 잘 모르는 기술을 가지고 내가 원하는 기능을 만들 수 있도록 하는 연습
  - 그리고 그 이후에 해당 기술의 원리와 작동방식을 학습하는 연습
- 

- 계층화
  - 서비스 레이어는 왜 나눴는가?에 대한 질문을 많이 받았을 것이다.
  - 이번 미션은 콘솔과 웹 기반 서비스를 동시에 제공하는 것이었다.
  - 두 플랫폼을 구현하는 코드에서 중복되는 비즈니스 로직과 데이터 로직이 발생했을 것이다.
  - 데이터 로직 부분을 InmemoryDao, JdbcDao 등으로 분리했을 것이다.
  - 비즈니스 로직 부분을 Service로 분리했을 것이다.
  - 계층화는 물리적인 구분보다는 논리적인 구분이다. 보통 패키지로 나워주는 것이 일반적.
  - 관심사를 분리하는 것이 계층적으로 나타난 것.
  - Presentation - domain - data
  - 변경에 대한 취약성을 보호하기 위해 코드를 분리한다.
    - presentaion, persistence 부분에 대한 변경이 있어도 domain로직 자체는 동일한 것을 사용하는 구나!
  - 이러한 계층 구조가 너무 자연스럽게 사용하다보니 지나치게 되는데 한 번 다시 의심해볼 필요가 있다.
  - 만약 서비스에서 Dao를 생성하고 호출하는 것만 수행한다면 그것은 잘 계층화를 한 것일까?
    - 서비스가 자신만의 책임을 지고 있는 것인가?
  - 도메인 로직이 복잡한 미션을 진행하게 되면 도메인 자체 로직을 풍부하게 할 것인지, 아니면 서비스 차원에서 수행하는 코드를 더 풍부하게 할 것인지 고민하게 될 것이다.
  - 무지성으로 계층화를 진행하지 말고 각 계층이 현재 어떤 책임을 지고 있는지 잘 생각하면서 진행했으면 좋겠다.

- validation
  - 값의 검증을 어떤 계층에서 확인해야 하는가?
  - 자동차 이름이 5자 이하여야 한다는 검증 로직은 자동차 경주 도메인에 국한된 것이다.
    - 이런 부분은 도메인에서 진행해주는 것이 적절해 보인다.
    - 콘솔과 웹 기반 서비스를 모두 제공하는 환경에서 이를 도메인에서 검증하지 않으면 각 컨트롤러마다 중복 검증 로직을 구현해줘야 한다.
  - 그런데 시도 횟수가 0보터 커야 한다와 같은 타입 검증 등은 어디에서 하는게 좋을까?
    - 이런 부분도 도메인에서 검증해줘야 하나?
    - 정답은 없지만 고민해야 할 부분은 각 계층이 어떤 역할을 해야하는가이다. 그래야 내가 생각하는 적합한 설계를 진행해볼 수 있다.
  - 레벨1과는 달라진 도메인 로직 작성 방법을 가져가게 될텐데 값에 대한 검증을 어디에서 진행해줄 것인지, 예외는 어떻게 처리해줄 것인가 고민해보자.
  - 누누의 Dto와 도메인에서 모두 검증해줘야 하는가에 대한 레퍼런스
    - https://stackoverflow.com/questions/20091826/should-dto-and-entity-both-have-input-validations
  - 프레임워크 의존적인 설계가 괜찮나?
    - 현실적으로 그 의존적 설계가 문제가 되는 경우는 거의 없었던 것 같다.
    - 프레임 워크가 바뀌면 프로젝트를 아예 새로 시작하기 때문이다.
    - 그래서 스프링의 검증기능을 사용해도 문제는 없을 것이라 생각해주면 좋겠다.
    - 솔라의 답변
      - 현업에서는 같은 기능을하는데 아예 새로운 프로그래밍 언어로 하도록 변경하거나, 아예 새로운 웹 프레임워크를 쓸 정도의 작업은 ‘리팩토링’보다는’porting’에 해당하는 작업으로 정의합니다. 
      - 보통 포팅에서는 기존 코드를 최대한 재활용하는 이점보다 새로운 언어나, 프레임워크를 선택하는 이점이 더 크다고 판단해 선택하는 경우가 많아서, 기존코드의 언어적, 프레임워크적 특징이 담긴 코드를 못가져가는것은 당연히 감수해야하는 것으로 생각하긴 했습니다.

- 계층화된 아키텍처 안에서도 관심사가 같은 컴포넌트들을 묶는 경우도 있다.
  - 레이어드 아키텍처에서 갖고 있는 문제점이라고 한다.
  - 호이의 레퍼런스 https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html
  - 실제로 persistence 계층에 값이 하나 추가되서 모든 계층에 변경이 일어나게 되는 경우도 발생한다.

- DB가 도입되면서 무엇이 객체지향인지 모호해진 것 같다.
  - 브라운 왈 : 잘 학습하고 있는 것이다.
  - 왜 객체지향의 개념이 모호해지는지 생각해보고 어떤 기준을 세우고 프로그래밍할 것인지 결정해보자.

### 코수타 정리
- 평균의 종말, 객체지향 개구리 책 좋다.
- 레벨1에서 어떤 것을 잘 학습하지 못했던 느낌이 들어서 힘들 수 있는데 이를 잘 구체화시켜봐야 한다.
- 레벨2만의 목표와 계획을 잡아보라는 것이 이를 해결하기 위한 의도이다.

### 패캠 강의 수강 (우플비)
- Json 데이터를 살펴보면 중괄호와 대괄호를 사용하는데 중괄호는 {} 객체를 나타내며, 대괄호는 [] 배열을 나타낸다.
- RequestBody 어노테이션을 통해 HTTP 바디를 객체에 맵핑할 때 ObjectMapper 모듈을 이용하게 된다.
  - 기본적으로 자바는 Camel Case를 사용하고, Json은 SnakeCase를 사용하기 때문에 이 변수명들이 매칭되지 못한다.
  - ObjectMapper 또한 기본적으로 SnakeCase를 찾아서 Mapping 해주기 때문에 이를 맵핑해주기 위한 작업이 따로 필요하다.
    - @JsonProperty라는 어노테이션을 선언해 어떤 SnakeCase 변수명을 맵핑할 지 직접 정해주는 것으로 사용할 수 있다.
    - 개발을 진행하다보면 snake 케이스도 아니고 camel 케이스도 아닌 변수명을 사용하게 되는경우가 발생하는데 이럴 떄 특정 변수명을 JsonProperty 어노테이션을 사용해서 해결할 수 있다.


## 23.04.22
### 웹 자동차 경주 미션 2차 코드 리뷰
- 래퍼 클래스를 사용해주신 이유가 있을까요?
  - Primitive 타입 변수를 사용하면 null값이 들어와도 기본적으로 0 값이 저장된다는 것을 알게 되었습니다.
  - Request 메세지에서 항상 값이 제대로 들어올 것이란 보장은 없을 것이라고 생각했기에 null이 들어오는 경우는 0이 아니라 null을 받을 수 있도록 해야 한다고 생각했습니다.
  - 하지만 기존 코드는 null 값이 들어오는 경우 이를 검사해서 Exception 처리를 해주지는 못합니다.
  - 그래서 WebRacingController에 Exception Handler를 구현해서 이를 처리할 수 있도록 했습니다.
  - 다만 Request Message로 넘어오는 값들의 검증으로 인해 발생하는 예외와 도메인 로직에서 발생하게 되는 로직은 구분해서 넘겨줘야 할 것 같다는 생각이 들었습니다.
  - 지금은 도메인쪽에서 IllegalArgumentException만 발생하는 간단한 경우지만 좀 더 규모가 커질수록 어떠한 방식으로 예외처리를 진행해주는 것이 좋을지 감이 쉽게 잡히지 않는 것 같습니다.
  - Controller 단과 Service단에서 발생하는 Exception에 대한 처리를 어떻게 하면 효과적으로 분리해서 처리할 수 있는지 여쭤보고 싶습니다!

>- 요구사항을 가장 잘 충족시키는 가장 심플한 것을 찾으라. ... 복잡한 것이 나쁘고 잘못된 것이기 때문이다.
- 토비님이 예전에 남겼던 글의 일부입니다. 복잡한 아키텍처를 도입하는 건 그 아키텍처가 아니면 복잡성을 풀어낼 수 없을 때입니다. 
- 먼저 가장 심플하게 풀어낼 방법을 찾고 해결이 안 되면 복잡한 방법을 찾는 습관이 좋은 개발자를 향한 한 걸음이 아닐까 싶네요 😄
  - 좋은 말씀입니다. 동의되지 않는 기술과 원칙에 쉽게 굴복하지 말아야 하는데... 학습하는 사람의 입장에서 정말 쉽지 않은 것 같습니다.
  - 조금 더 주관을 가지고 최대한 간단한 방법으로 문제를 해결하는 습관을 남은 기간동안 연습해봐야겠습니다. 감사합니다~!!

- 생성자가 여러개일 경우 생성자 체이닝을 활용하는 편이 좀 더 일관성 있는 프로그램을 만드는 방법이 될 수 있습니다.
  - 객체의 모든 프로퍼티를 초기화하는 생성자를 주 생성자로 두고 나머지 생성자들은 주 생성자를 체이닝 하도록 하면 더 깔끔한 클래스 상단부를 만들 수 있겠네요!
  - Entity 뿐만 아니라 도메인 쪽에서도 추가된 생성자들을 함께 정리했습니다.

- 크게 남길 코멘트가 없어서 이런 부분까지 얘기해보자면,
  지금 구현이 동시성이나 여러 대의 서버가 뜨는 상황에서 안전한 프로그래밍 방식은 아닌 것 같아요. 
- 보다보니 콘솔 레포에 id 값이 없어도 될 것 같은데 히이로 생각은 어떠신가요?
  - 콘솔 기반 프로그램에는 이력 저장 등의 요구사항이 없었기에 ConsoleRacingCarRepository는 단순하게 생성된 게임 객체를 그대로 저장하게 했습니다.
  - 그 과정에서 map의 key값으로 id를 사용하도록 했습니다. 깊게 고민하지 않았던 부분이라 동시성에 대한 문제는 생각하지 못했던 것 같습니다.
  - 아직 학습해본 부분은 아니지만 스프링을 사용하는 프로젝트라면 @Transactional 키워드를 사용해 이러한 문제를 다룰 수 있을 것 같습니다.
  - 다만 지금은 콘솔 기반 프로그램이므로 해당 방법을 적용하긴 힘들어 보입니다.
  - 범블비가 말씀해주신대로 키를 없애고 단순히 List로 관리하게 되면 당장 프로그램 요구사항은 만족하고 동시성 문제도 해결할 수 있을 것 같아요.
  - 그런데 만약 콘솔 기반에서도 동시성을 고려하면서 id가 필요해지는 기능이 추가되어야 한다면 어떻게 해야할까요?
  - 그 순간이 DB를 연동해야만 하는 타이밍인지, 아니면 순수 자바 기반 프로그램에서도 이런 트랜잭션의 기능을 구현할 수 있는지 궁금해지네요...!















