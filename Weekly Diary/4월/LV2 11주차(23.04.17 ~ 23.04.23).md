# LV2 11주차 (23.04.17 ~ 23.04.23)

---

## 23.04.18
- jwp-racingcar 피드백
- 의존 방식에 따른 결합도
- 객체와 객체 사이에 의존성은 어쩔 수 없이 생기는 것인데 왜 신경쓰며 개발해야 할까?
  - 변경에 대한 파급효과를 줄이기 위해 최소한의 의존성만 남겨두는 것이 좋다.
- 두 객체가 있을 때, 한 객체가 다른 객체를 사용, 생성을 한다면 생성, 사용하는 객체가 다른 객체에 의존하는 것이다.
- 객체의 생성과 사용을 모두 의존하는 경우 테스트도 어려워지고, 변화에 취약해지게 된다. 협력의 문맥이 고정된다(테오), 한 클래스 내에서 사용과 생성의 책임을 모두 지고있다.
- 인터페이스를 구현해서 사용하게 되면 사용 부분에 대해서 의존성을 조금은 느슨하게 할 수 있다.
  - 하지만 아직 생성에 대한 의존성은 해결하지 못했다.
  - 그래서 생성책임을 다른 객체에게 위임하고자 한다.
- 객체의 생성은 팩토리 객체에게 위임한다.
  - 생성에 대한 의존성을 축소시킬 수는 있으나 완전히 없앨 수는 없다.
  - PlayResultDao라는 이름 자체가 남아있게 되기 떄문에 아예 의존성을 없앨 수는 없다.
- 조립기 : 의존성을 삽입해주는 역할을 지도록 하는 새로운 객체를 추가한다.
- 스프링은 객체를 생성하고 관리하는 역할을 수행한다.
  - IOC 컨테이너라고 스프링을 부르기도 한다.(빈 팩토리라는 표현도 사용하는 경우가 있다고 한다.) - 왜 이런 용어들을 사용하는지 정리해보는 것도 좋을 것 같다.
  - 컨테이너는 DI라는 방식으로 의존성을 주입해서 객체를 생성하고 관리한다.
  - 스프링 빈은 컨테이너가 관리하는 객체들을 일컫는다.
- 스프링 빈 설정의 방식에는 XML, Annotation-based Configuration, Java-based configuration 등이 있다.
- 이번 피드백에서는 어노테이션 기반 설정에 대해 알아본다.
- controller, service, repository 어노테이션으로 설정할 수 없지만 빈으로 관리하고싶은 객체는 Component 어노테이션을 붙였을 것이다.
- @ComponentScan 어노테이션을 통해 등록할 빈을 스캔할 classPath를 지정한다.
- 의존성과 관련된 문제들을 해결하기 위해 컨테이너가 등장하게 되었구나를 알고 있으면 좋을 것 같다.
- repository와 dao의 차이는 repository 어노테이션의 설명 도큐먼트 부분을 읽어보자.

- 솔라 : 아직 repository 는 아직 안써봣으니(보통ORM에서 본격사용) 당연히 모르는거 아닐까요? 나중에 사용해보셔야 진짜 차이를 알게될거같아요

- 모든 객체를 빈으로 만들것인가에 대한 문제인데, 어떤 객체까지 빈으로 관리할 것인가? 미션을 진행하면서 직접 느껴주면 좋겠다!

- 컴포넌트들을 최대한 많이 사용하면서 경험 기반으로 학습을 진행하도록 하자.

### 실습 진행
- @Component와 @Autowired의 차이?
  - @Component를 사용하면 빈으로 등록할 수 있다.
  - @Autowired는 생성자, setter, 필드, 메서드에 사용할 수 있다.
    - 스프링 컨테이너에서 관리되고 있는 빈에 등록이 되어 있으면 의존성을 주입시켜준다.
    - 첫 번째는 타입을 검사하고, 그 다음은 빈의 이름을 검사한다. 
    - 만약 동일하다고 판단되는 빈이 2개가 존재하면 예외가 발생한다.
- @Repository를 Dao에도 붙이는 이유?
  - Repository 어노테이션은 여러가지 구체적인 Persistence 예외 상황들을 통합된 스프링의 unchecked Exception으로 전환시켜주는 역할을 한다.
  - Dao에서 발생하는 예외는 최대한 발생한 지점에서 가까이 처리되어야 한다.
  - 또한 Repository는 Dao만을 사용해서 로직을 수행하지는 않는다. 다른 방법을 이용해 Persistence 계층의 기능을 수행할 수 있다.
  - 이 때 발생하는 예외들도 처리해줄 수 있어야 하기 때문에 repository 클래스에도 @Repository 어노테이션을 붙여줘야 한다.
- JdbcTemplate을 사용하는 객체에 @Repository를 붙여야 하는가 아니면 @Component를 붙여도 되는가?
  - JdbcTemplate은 내부적으로 Spring 에외로의 전환을 수행해준다. 그렇기 때문에 Component 어노테이션을 붙여도 상관 없다.
- 스프링 빈에서는 왜 전부 싱글톤으로 관리하는 걸까?
  - https://velog.io/@minwest/Spring-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%80-%EB%B9%88%EC%9D%84-%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%A0%EA%B9%8C


- 스프링에서 의존성을 주입하는 방법엔 어떤 것들이 있나요?
- 미션에서 어떤 방법을 사용했으며 그 이유는 무엇인가요?
  - 스프링에서 의존성을 주입하는 방법에는 생성자 주입, setter 주입, 필드 주입 이렇게 세 가지 방법이 대표적으로 존재합니다.
  - 저는 특별한 이유가 있지 않는 한 생성자 주입을 사용하고 있습니다. 
  - 그 이유는 현재 미션 수준에서 지연 초기화를 사용해야 하는 객체들이 존재하지 않기 때문입니다. 
  - 그래서 항상 생성된 객체는 온전히 초기화가 완료되어 있어야 하는데 이를 생성자 의존성 주입 방식을 사용함으로서 강제할 수 있습니다. 
  - 이러한 이유로 저는 생성자 의존성 주입을 사용합니다.

- 애플리케이션의 모든 객체를 스프링 컨테이너가 관리할 필요는 없습니다. 그렇다면 어떤 객체를 스프링 빈으로 등록해야할까요? 
- 이번 미션에서 스프링 빈으로 등록한 객체를 기반으로 스프링 빈으로 관리할 객체에 대한 기준을 정해 보세요.
  - 비즈니스 로직을 수행하는 도메인 객체들 간의 의존성을 제외한 나머지 계층형 아키텍처 구조에서 존재하는 의존성들에 대해서는 스프링 빈으로 관리를 해보려고 합니다. 
  - 도메인 간의 의존성은 깨졌을 때 처음 설계한 의도와 다르게 비즈니스 로직이 수행될 가능성이 있다고 봅니다. 
  - 하지만 스프링 프레임워크의 구조를 따르는 controller - service - repository 등의 큰 구조를 구성하는데 생기는 의존성은 오히려 스프링 빈으로 관리함으로써 더 편하지만 안전하게 애플리케이션을 개발할 수 있다고 정리했습니다!








































