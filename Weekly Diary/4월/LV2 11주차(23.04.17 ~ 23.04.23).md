# LV2 11주차 (23.04.17 ~ 23.04.23)

---

## 23.04.18
- jwp-racingcar 피드백
- 의존 방식에 따른 결합도
- 객체와 객체 사이에 의존성은 어쩔 수 없이 생기는 것인데 왜 신경쓰며 개발해야 할까?
  - 변경에 대한 파급효과를 줄이기 위해 최소한의 의존성만 남겨두는 것이 좋다.
- 두 객체가 있을 때, 한 객체가 다른 객체를 사용, 생성을 한다면 생성, 사용하는 객체가 다른 객체에 의존하는 것이다.
- 객체의 생성과 사용을 모두 의존하는 경우 테스트도 어려워지고, 변화에 취약해지게 된다. 협력의 문맥이 고정된다(테오), 한 클래스 내에서 사용과 생성의 책임을 모두 지고있다.
- 인터페이스를 구현해서 사용하게 되면 사용 부분에 대해서 의존성을 조금은 느슨하게 할 수 있다.
  - 하지만 아직 생성에 대한 의존성은 해결하지 못했다.
  - 그래서 생성책임을 다른 객체에게 위임하고자 한다.
- 객체의 생성은 팩토리 객체에게 위임한다.
  - 생성에 대한 의존성을 축소시킬 수는 있으나 완전히 없앨 수는 없다.
  - PlayResultDao라는 이름 자체가 남아있게 되기 떄문에 아예 의존성을 없앨 수는 없다.
- 조립기 : 의존성을 삽입해주는 역할을 지도록 하는 새로운 객체를 추가한다.
- 스프링은 객체를 생성하고 관리하는 역할을 수행한다.
  - IOC 컨테이너라고 스프링을 부르기도 한다.(빈 팩토리라는 표현도 사용하는 경우가 있다고 한다.) - 왜 이런 용어들을 사용하는지 정리해보는 것도 좋을 것 같다.
  - 컨테이너는 DI라는 방식으로 의존성을 주입해서 객체를 생성하고 관리한다.
  - 스프링 빈은 컨테이너가 관리하는 객체들을 일컫는다.
- 스프링 빈 설정의 방식에는 XML, Annotation-based Configuration, Java-based configuration 등이 있다.
- 이번 피드백에서는 어노테이션 기반 설정에 대해 알아본다.
- controller, service, repository 어노테이션으로 설정할 수 없지만 빈으로 관리하고싶은 객체는 Component 어노테이션을 붙였을 것이다.
- @ComponentScan 어노테이션을 통해 등록할 빈을 스캔할 classPath를 지정한다.
- 의존성과 관련된 문제들을 해결하기 위해 컨테이너가 등장하게 되었구나를 알고 있으면 좋을 것 같다.
- repository와 dao의 차이는 repository 어노테이션의 설명 도큐먼트 부분을 읽어보자.

- 솔라 : 아직 repository 는 아직 안써봣으니(보통ORM에서 본격사용) 당연히 모르는거 아닐까요? 나중에 사용해보셔야 진짜 차이를 알게될거같아요

- 모든 객체를 빈으로 만들것인가에 대한 문제인데, 어떤 객체까지 빈으로 관리할 것인가? 미션을 진행하면서 직접 느껴주면 좋겠다!

- 컴포넌트들을 최대한 많이 사용하면서 경험 기반으로 학습을 진행하도록 하자.

### 실습 진행
- @Component와 @Autowired의 차이?
  - @Component를 사용하면 빈으로 등록할 수 있다.
  - @Autowired는 생성자, setter, 필드, 메서드에 사용할 수 있다.
    - 스프링 컨테이너에서 관리되고 있는 빈에 등록이 되어 있으면 의존성을 주입시켜준다.
    - 첫 번째는 타입을 검사하고, 그 다음은 빈의 이름을 검사한다. 
    - 만약 동일하다고 판단되는 빈이 2개가 존재하면 예외가 발생한다.
- @Repository를 Dao에도 붙이는 이유?
  - Repository 어노테이션은 여러가지 구체적인 Persistence 예외 상황들을 통합된 스프링의 unchecked Exception으로 전환시켜주는 역할을 한다.
  - Dao에서 발생하는 예외는 최대한 발생한 지점에서 가까이 처리되어야 한다.
  - 또한 Repository는 Dao만을 사용해서 로직을 수행하지는 않는다. 다른 방법을 이용해 Persistence 계층의 기능을 수행할 수 있다.
  - 이 때 발생하는 예외들도 처리해줄 수 있어야 하기 때문에 repository 클래스에도 @Repository 어노테이션을 붙여줘야 한다.
- JdbcTemplate을 사용하는 객체에 @Repository를 붙여야 하는가 아니면 @Component를 붙여도 되는가?
  - JdbcTemplate은 내부적으로 Spring 에외로의 전환을 수행해준다. 그렇기 때문에 Component 어노테이션을 붙여도 상관 없다.
- 스프링 빈에서는 왜 전부 싱글톤으로 관리하는 걸까?
  - https://velog.io/@minwest/Spring-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%80-%EB%B9%88%EC%9D%84-%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%ED%95%A0%EA%B9%8C


- 스프링에서 의존성을 주입하는 방법엔 어떤 것들이 있나요?
- 미션에서 어떤 방법을 사용했으며 그 이유는 무엇인가요?
  - 스프링에서 의존성을 주입하는 방법에는 생성자 주입, setter 주입, 필드 주입 이렇게 세 가지 방법이 대표적으로 존재합니다.
  - 저는 특별한 이유가 있지 않는 한 생성자 주입을 사용하고 있습니다. 
  - 그 이유는 현재 미션 수준에서 지연 초기화를 사용해야 하는 객체들이 존재하지 않기 때문입니다. 
  - 그래서 항상 생성된 객체는 온전히 초기화가 완료되어 있어야 하는데 이를 생성자 의존성 주입 방식을 사용함으로서 강제할 수 있습니다. 
  - 이러한 이유로 저는 생성자 의존성 주입을 사용합니다.

- 애플리케이션의 모든 객체를 스프링 컨테이너가 관리할 필요는 없습니다. 그렇다면 어떤 객체를 스프링 빈으로 등록해야할까요? 
- 이번 미션에서 스프링 빈으로 등록한 객체를 기반으로 스프링 빈으로 관리할 객체에 대한 기준을 정해 보세요.
  - 비즈니스 로직을 수행하는 도메인 객체들 간의 의존성을 제외한 나머지 계층형 아키텍처 구조에서 존재하는 의존성들에 대해서는 스프링 빈으로 관리를 해보려고 합니다. 
  - 도메인 간의 의존성은 깨졌을 때 처음 설계한 의도와 다르게 비즈니스 로직이 수행될 가능성이 있다고 봅니다.  예를 들어 아직 초기화가 진행되면 안되는 객체가 미리 초기화 되어버린다는 문제등이 발생할 수 있을 것 같습니다.
  - 하지만 스프링 프레임워크의 구조를 따르는 controller - service - repository 등의 큰 구조를 구성하는데 생기는 의존성은 오히려 스프링 빈으로 관리함으로써 더 편하지만 안전하게 애플리케이션을 개발할 수 있다고 정리했습니다!


## 23.04.19
### 이동욱님 특강
- 100군데 넣었다가 하나 된 두번째 직장이 zum...
- 자존감 기둥 만들기
  - 뛰어난 동료, 새로운 환경, 프로젝트 실패 등 자존감이 떨어질 수 있다.
  - 자존감의 여섯 기둥 - 책 , 기둥이 하나면 쉽게 무너질 수 있기 때문에 여러개를 만들어둬야 한다.
  - 글쓰기, 커뮤니티 참여, 운동, 독서, 멘토링, 전동료와의 대화 등....
  - 연차가 낮을 때부터 본인이 틀렸다는 것을 인정하는 연습을 하는 것이 좋다. 그것이 내 자존감을 무너뜨리지 않도록 하자.
- 회사를 다니면 회사일의 숙련자가 된다. 회사를 길게 다닌다고 개발 전문가는 되지 않았다.
  - 지속적으로 방법에 대해 고민하고 변화해야 한다.
  - 주니어때는 성과가 아니라 성장을 목표로!
  - 새로운 환경에서도 잘할 수 있는 사람인지? 적응할 수 있는 것이 중요하다.
  - 지금 잘하는 사람보다 지금 못해도 계속 상향곡선을 그리는 사람을 곁에 두는 것이 중요하다.
- SI 들어가서 학습했던 고민
  - 혼자서 사이드 프로젝트
    - A-Z 구현 경험
    - 기능 구현에만 집중
    - 깊게 공부하지 못함
  - 책 스터디
    - 높은 완주율은 좋았으나...
    - 내가 발표한 주제만 기억에 남는 문제가 있었다.
  - 직접 강의하는 것
    - 100% 내용 습득 가능
    - 강의 외적인 부가작업이 필요하다.
    - 낮은 시간 가성비의 문제
  - public 블로그
    - 온라인에 누구를 가르친다고 생각하고 글을 써보자
    - 온라인 모두가 리뷰어
    - 동료에게 공유 가능
    - 피드백의 부끄러움, 부끄러운 것보다 연차 낮을 때 빠르게 고치는 것이 더 중요하다.
- 지금은 블로그, 일일커밋, 독서, 오프라인 강좌 등의 방법을 사용한다.
  - 일일커밋은 컨디션이 좋든 안좋든 해야할 것을 정해서 하는 것이 중요하다.
  - 독서와 오프라인 강좌가 제일 중요했던 것 같다.
  - 가능하면 인증되고, 정제된 자료로 습득한다.
  - OREILLY 페이지에 연단위 결제하면 온라인으로 원서들을 볼 수 있다.
  - 클린코더스 강좌 엄청 좋다!
  - 나에게 맞는 가장 효율적인 훈련방법을 찾아야한다.
  - 계속 점검하고 더 좋은 방법을 찾아보고 시도한다.
- 자바, 스프링 mysql 기반을 사용하다가 다른 플랫폼으로 넘어가는 것이 무섭지는 않았나?
  - 그 동안의 학습과 성장은 모두 자바 스프링 mysql을 기반 삼아서 진행한 것들
  - 내가 그동안 공부했던게 이미 아는게 너무 많아져서 학습을 쉽게 느끼고 있는게 아닌가?
  - 완전 제로 베이스에서 그 동안의 학습 방법을 검증해볼 수 있는 시간
  - 최대한 빠르게 나에게 맞는 최적화된 방법을 찾아서 고도화시켜야 한다.
- 새로운 환경을 잘 배우는 방법
  - 테스트코드
  - 데브옵스 + aws + 온프레미스 인프라
  - 뷰, 리액트, 등 프론트엔드
  - 데이터 파이프라인
  - 노드, 타입스크립트
  - 돈보다 시간이 제일 비싸다.
  - 신뢰할만한 사람한테 돈을 지불하고 질문이 가능한 강의를, 코드 리뷰를 구매한다.
  - 코드리뷰 자체를 지원하는 강의들도 있다. (넥스트 스텝, 코드숨)
  - 강의가 없다면 강의 자료 만들듯이 샘플 프로젝트와 블로그 글을 만든다.
- 어떤 방식이 제일 잘 맞나
- 24시간 중 언제 가장 집중이 잘 되는가
- 어떤 환경에서 가장 집중이 잘 되는가

- 학습 주제
  - 우리한테는 1년 뒤의 문제일 것이다.
  - 회사 업무에서 만난 문제를 연구 정리 해결해서 커뮤니티에 공유하고 피드백을 받는다.
  - 당장 직면한 문제를 해결하고 주변 동료들에게 인정받고 그 외의 분야로 공부하는 것이 중요하다.
  - 이것이 결국 스노우볼 시너지를 불러온다.
  - 회사일을 빠르게 끝내고 스스로의 성장에 더 집중할 수 있게 된다.
  - 회사일과 공부를 따로 두지 말자!!

- 산만함 관리하기
  - 잦은 컨텍스트 스위칭을 하다보면 점점 산만해지는 자신을 발견하게된다.
  - 하지만 서비스 회사를 다니다보면 생길 수 밖에 없다.
  - 집중이 잘 되는 환경 구성하기
  - 출근전 1~2시간 집중하고 출근하기
  - 점심, 저녁시간 산책하기
  - 주 2~3회 운동하기

- 거인의 어깨에 올라타서 배우기
  - 뛰어난 사람 옆에서 배우기
  - C(CTO, CEO)레벨, 테크 리드와 가까이 일할 수 있는 것은 큰 기회!
  - 실무를 배우지는 않겠지만, 어떻게 커뮤니케이션하고, 어떻게 팀원들의 신뢰를 얻고 조직의 문화를 만들어가는지, 어떤 기준으로 결정을 내리는지 

- 보상
  - 줌에서는 나만 남고 다 퇴사
    - 일단 버티고 봤더니 최고참이되어 사람을 직접 면접하는 기회도 겪어보고 좋은 문화를 상상하며 만들어갈 수 있었다.
  - 배민에서는 정산 보정을 엄청 어렵게 했는데 이걸 하려고 내가 개발자했나라는 생각
    - 일단 버티고 봤더니 포인트 시스템 TF 리드라는 직책을 맡게 되었다.
  - 시련 뒤에는 항상 보물이 기다리고 있었다.

- 경험해봤으니 이번엔 **다른 선택**하기
- 남을 설득하는 방법 배우기
- 만약 팀원들이 매번 내 의견을 반대한다면 완벽한 논리가 중요한 게 아니다.
- 어떻게 협업을 하면서, 이 사람들과 함께 성과를 낼것인가, 어떻게 나를 인정하게 만들 것인가, 어떻게 이 사람들과 유대감을 만들 것인가
- 내가 잘하면 너네가 따라오겠지 마인드는 위험하다.
- 개발 실력이 중요하다고 해서 나머지가 오케이 되는 건 아니다.
- 그래서 소프트 스킬이 중요하다.

- 모든게 좋은데, 그 중 하나만 별로하면?
  - 그걸 얻어내는 방법을 모르면 매번 퇴사하는 것 외에는 방법이 없다.
  - 팀장만 별로고 나머지 다 좋은 회사라면 팀장을 내 사람으로 만드는 것이 중요하다.
  - 이런 것들을 지금 우테코 가장 낮은 수준의 환경에서 배울 수 있었으면 좋겠다.

- 내가 만약 단기전을 잘하는 사람이 아니라면 길게 보고 끝에서 잘되는 사람이 되어야지라고 생각하자.

- 학습 키워드 : 그때그때 방향을 바꾸지는 않고 깊게 파고드는 것 보다는 짧은 시간을 투자해서 끝냈다.
  - 지금 필요한 내용까지만 학습하고 다음으로 넘어간다.
  - 키워드를 정해진 시간 안에 끝내고 넘어가도록 하자.

- 꾸준함의 기준을 잘 잡아야 한다.
  - 그냥 단순하게 책을 정리해서 올리는 등의 글은 꾸준함이 아니다.
  - 정도는 상관 없다. 그저 조금씩이라도 나아지고 있는가? 가 꾸준함으로 보여질 수 있다.

- 대기업은 10%밖에 안된다.
  - 나머지 90%는 프론트, 데브옵스, 백엔드, 인프라 전부 다뤄야한다.
  - 어떤 분야의 개발자라고 생각하지말고 그냥 개발자라고 생각하자.
  - 문제를 해결하기 위해 가장 좋은 해결방법을 찾겠다.
  - 한 분야의 성을 쌓을 것인가?
  - 아니면 여러 분야를 두루 쌓아서 고객에게 사랑받는 상품을 만드는 경험을 해볼 것인가?
   
- 사파리 북스 번역을 돌려서 책을 보는 편이다.
- 실제 사람들이 사용할 수 있는 서비스를 만드는 것이 핵심
- 원대한 꿈이나 목표보다는 어떤 것을 얼마나 꾸준하게 최선을 다해서 할 수 있는지를 고민해보자.
- 어떻게 하면 더 프로그래밍을 재미있게 할 수 있을까를 고민했으면 좋겠다.

## 23.04.20
### 패캠 실습 강의
- 변수 넘겨받기
  - pathVariable
  - queryParam

### 2단계 PR 요청
안녕하세요 범블비, 히이로입니다!
지난 번에 리뷰 달아주셧던 부분들에 대해서는 이전 PR에 답글을 달아두었는데 한 번 확인해주시면 감사하겠습니다! 🙇
혹시 해당 부분에 대한 추가 피드백이 있다면 다음 리팩토링 시 반영해보도록 하겠습니다.

이번 2단계 미션을 진행하며 집중했던 부분은 다음과 같습니다.
(말씀해주셨던 대로 일단은 테스트에 대한 부분은 다음으로 넘겨두고 진행했습니다. )


- 각 계층 사이에서 어떤 객체와 데이터를 전송하는가에 대해 자신만의 기준을 확립해 보고자 했습니다.
  - controller와 service, 즉 Presentation Layer와 Business Layer 간에는 Request, Response 객체가 필요한 데이터를 전송하는 책임을 지도록 했습니다. 하지만 웹 서비스 상 직관성을 위한 네이밍일 뿐 수행하는 역할은 Dto와 동일했습니다.
  - service와 repository, 즉 Business Layer와 Persistence Layer 간에는 Domain 객체를 주고 받을 수 있도록 했습니다. 여기서 repository는 service 입장에서 객체의 컬렉션과 같이 동작하는 상태 값처럼 생각하고 구현했습니다. 그래서 service는 단순히 domain객체를 repository에 저장하고, 가져올 수 있는 양상을 가지게 되었습니다.
  - repository와 Dao, 즉 Persistence Layer 내부의 구성 요소 객체 간에는 Entity를 주고 받도록 했습니다. 여기서 Entity는 테이블에 추가되는 auto generated key 등과 같이 기존 Domain 객체는 가질 수 없는 데이터 또한 상태값으로 가질 수 있습니다. 결과적으로 Entity는 DB 테이블과 1:1 맵핑되어 DB에 데이터를 저장하거나 조회할 때 사용됩니다.

- Repository의 추상화
  - 미션 요구사항 중 기존 콘솔 프로그램 또한 동작하도록 해야하며 웹과 콘솔 기반 프로그램이 가진 중복된 로직을 제거하는 것이 있었습니다.
  - 저는 웹, 콘솔 기반 프로그램이 모두 공통된 Service 객체를 통해 비즈니스 로직을 수행할 수 있도록 리팩토링을 진행했습니다.
  - 해당 과정에서 Service가 가지는 Repository에 대한 의존성을 주입해줘야 했으나 스프링이 해주는 것이 아닌 직접 생성해서 주입해줘야 했습니다.
  - 그래서 콘솔 기반 프로그램은 DB와 연동하는 요구사항이 없었기에 RacingCarRepository를 추상화하고 Dao를 사용하지 않는 ConsoleRacingCarRepository를 구현하여 이를 수행하도록 했습니다.

  
이번 2단계에서도 여전히 스프링과는 친숙해지기 어려운 것 같습니다. 최대한 키워드에 대한 학습을 진행하며 미션을 수행했는데 만족스럽지는 않으나, 어떤 것 때문에 만족스럽지 못한지 모르는 상태가 지속되는 기분입니다... 😂 제가 놓치거나 부족한 부분 잘 짚어주시면 리팩토링 열심히 해보겠습니다!


## 23.04.21
### 웹 자동차 경주 피드백 2
- 레벨2의 목표는 무엇인가?
  - 아직 잘 모르는 기술을 가지고 내가 원하는 기능을 만들 수 있도록 하는 연습
  - 최우선 목표를 달성하기 위해 일단 미션에 집중해서 어떻게든 구현해서 제출한다. 그 과정에서 드는 의문들은 그때그때 따로 정리해둔다. 
  - 이후 정리해뒀던 의문들에 대해 학습을 진행한다. 해당 과정에서 어떻게 학습하는 것이 가장 효율적인지 찾아보도록 한다.

- 계층화
  - 서비스 레이어는 왜 나눴는가?에 대한 질문을 많이 받았을 것이다.
  - 이번 미션은 콘솔과 웹 기반 서비스를 동시에 제공하는 것이었다.
  - 두 플랫폼을 구현하는 코드에서 중복되는 비즈니스 로직과 데이터 로직이 발생했을 것이다.
  - 데이터 로직 부분을 InmemoryDao, JdbcDao 등으로 분리했을 것이다.
  - 비즈니스 로직 부분을 Service로 분리했을 것이다.
  - 계층화는 물리적인 구분보다는 논리적인 구분이다. 보통 패키지로 나워주는 것이 일반적.
  - 관심사를 분리하는 것이 계층적으로 나타난 것.
  - Presentation - domain - data
  - 변경에 대한 취약성을 보호하기 위해 코드를 분리한다.
    - presentaion, persistence 부분에 대한 변경이 있어도 domain로직 자체는 동일한 것을 사용하는 구나!
  - 이러한 계층 구조가 너무 자연스럽게 사용하다보니 지나치게 되는데 한 번 다시 의심해볼 필요가 있다.
  - 만약 서비스에서 Dao를 생성하고 호출하는 것만 수행한다면 그것은 잘 계층화를 한 것일까?
    - 서비스가 자신만의 책임을 지고 있는 것인가?
  - 도메인 로직이 복잡한 미션을 진행하게 되면 도메인 자체 로직을 풍부하게 할 것인지, 아니면 서비스 차원에서 수행하는 코드를 더 풍부하게 할 것인지 고민하게 될 것이다.
  - 무지성으로 계층화를 진행하지 말고 각 계층이 현재 어떤 책임을 지고 있는지 잘 생각하면서 진행했으면 좋겠다.

- validation
  - 값의 검증을 어떤 계층에서 확인해야 하는가?
  - 자동차 이름이 5자 이하여야 한다는 검증 로직은 자동차 경주 도메인에 국한된 것이다.
    - 이런 부분은 도메인에서 진행해주는 것이 적절해 보인다.
    - 콘솔과 웹 기반 서비스를 모두 제공하는 환경에서 이를 도메인에서 검증하지 않으면 각 컨트롤러마다 중복 검증 로직을 구현해줘야 한다.
  - 그런데 시도 횟수가 0보터 커야 한다와 같은 타입 검증 등은 어디에서 하는게 좋을까?
    - 이런 부분도 도메인에서 검증해줘야 하나?
    - 정답은 없지만 고민해야 할 부분은 각 계층이 어떤 역할을 해야하는가이다. 그래야 내가 생각하는 적합한 설계를 진행해볼 수 있다.
  - 레벨1과는 달라진 도메인 로직 작성 방법을 가져가게 될텐데 값에 대한 검증을 어디에서 진행해줄 것인지, 예외는 어떻게 처리해줄 것인가 고민해보자.
  - 누누의 Dto와 도메인에서 모두 검증해줘야 하는가에 대한 레퍼런스
    - https://stackoverflow.com/questions/20091826/should-dto-and-entity-both-have-input-validations
  - 프레임워크 의존적인 설계가 괜찮나?
    - 현실적으로 그 의존적 설계가 문제가 되는 경우는 거의 없었던 것 같다.
    - 프레임 워크가 바뀌면 프로젝트를 아예 새로 시작하기 때문이다.
    - 그래서 스프링의 검증기능을 사용해도 문제는 없을 것이라 생각해주면 좋겠다.
    - 솔라의 답변
      - 현업에서는 같은 기능을하는데 아예 새로운 프로그래밍 언어로 하도록 변경하거나, 아예 새로운 웹 프레임워크를 쓸 정도의 작업은 ‘리팩토링’보다는’porting’에 해당하는 작업으로 정의합니다. 
      - 보통 포팅에서는 기존 코드를 최대한 재활용하는 이점보다 새로운 언어나, 프레임워크를 선택하는 이점이 더 크다고 판단해 선택하는 경우가 많아서, 기존코드의 언어적, 프레임워크적 특징이 담긴 코드를 못가져가는것은 당연히 감수해야하는 것으로 생각하긴 했습니다.

- 계층화된 아키텍처 안에서도 관심사가 같은 컴포넌트들을 묶는 경우도 있다.
  - 레이어드 아키텍처에서 갖고 있는 문제점이라고 한다.
  - 호이의 레퍼런스 https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html
  - 실제로 persistence 계층에 값이 하나 추가되서 모든 계층에 변경이 일어나게 되는 경우도 발생한다.

- DB가 도입되면서 무엇이 객체지향인지 모호해진 것 같다.
  - 브라운 왈 : 잘 학습하고 있는 것이다.
  - 왜 객체지향의 개념이 모호해지는지 생각해보고 어떤 기준을 세우고 프로그래밍할 것인지 결정해보자.

### 코수타 정리
- 평균의 종말, 객체지향 개구리 책 좋다.
- 레벨1에서 어떤 것을 잘 학습하지 못했던 느낌이 들어서 힘들 수 있는데 이를 잘 구체화시켜봐야 한다.
- 레벨2만의 목표와 계획을 잡아보라는 것이 이를 해결하기 위한 의도이다.

### 패캠 강의 수강 (우플비)
- Json 데이터를 살펴보면 중괄호와 대괄호를 사용하는데 중괄호는 {} 객체를 나타내며, 대괄호는 [] 배열을 나타낸다.
- RequestBody 어노테이션을 통해 HTTP 바디를 객체에 맵핑할 때 ObjectMapper 모듈을 이용하게 된다.
  - 기본적으로 자바는 Camel Case를 사용하고, Json은 SnakeCase를 사용하기 때문에 이 변수명들이 매칭되지 못한다.
  - ObjectMapper 또한 기본적으로 SnakeCase를 찾아서 Mapping 해주기 때문에 이를 맵핑해주기 위한 작업이 따로 필요하다.
    - @JsonProperty라는 어노테이션을 선언해 어떤 SnakeCase 변수명을 맵핑할 지 직접 정해주는 것으로 사용할 수 있다.
    - 개발을 진행하다보면 snake 케이스도 아니고 camel 케이스도 아닌 변수명을 사용하게 되는경우가 발생하는데 이럴 떄 특정 변수명을 JsonProperty 어노테이션을 사용해서 해결할 수 있다.


## 23.04.22
### 웹 자동차 경주 미션 2차 코드 리뷰
- 래퍼 클래스를 사용해주신 이유가 있을까요?
  - Primitive 타입 변수를 사용하면 null값이 들어와도 기본적으로 0 값이 저장된다는 것을 알게 되었습니다.
  - Request 메세지에서 항상 값이 제대로 들어올 것이란 보장은 없을 것이라고 생각했기에 null이 들어오는 경우는 0이 아니라 null을 받을 수 있도록 해야 한다고 생각했습니다.
  - 하지만 기존 코드는 null 값이 들어오는 경우 이를 검사해서 Exception 처리를 해주지는 못합니다.
  - 그래서 WebRacingController에 Exception Handler를 구현해서 이를 처리할 수 있도록 했습니다.
  - 다만 Request Message로 넘어오는 값들의 검증으로 인해 발생하는 예외와 도메인 로직에서 발생하게 되는 로직은 구분해서 넘겨줘야 할 것 같다는 생각이 들었습니다.
  - 지금은 도메인쪽에서 IllegalArgumentException만 발생하는 간단한 경우지만 좀 더 규모가 커질수록 어떠한 방식으로 예외처리를 진행해주는 것이 좋을지 감이 쉽게 잡히지 않는 것 같습니다.
  - Controller 단과 Service단에서 발생하는 Exception에 대한 처리를 어떻게 하면 효과적으로 분리해서 처리할 수 있는지 여쭤보고 싶습니다!

>- 요구사항을 가장 잘 충족시키는 가장 심플한 것을 찾으라. ... 복잡한 것이 나쁘고 잘못된 것이기 때문이다.
- 토비님이 예전에 남겼던 글의 일부입니다. 복잡한 아키텍처를 도입하는 건 그 아키텍처가 아니면 복잡성을 풀어낼 수 없을 때입니다. 
- 먼저 가장 심플하게 풀어낼 방법을 찾고 해결이 안 되면 복잡한 방법을 찾는 습관이 좋은 개발자를 향한 한 걸음이 아닐까 싶네요 😄
  - 좋은 말씀입니다. 동의되지 않는 기술과 원칙에 쉽게 굴복하지 말아야 하는데... 학습하는 사람의 입장에서 정말 쉽지 않은 것 같습니다.
  - 조금 더 주관을 가지고 최대한 간단한 방법으로 문제를 해결하는 습관을 남은 기간동안 연습해봐야겠습니다. 감사합니다~!!

- 생성자가 여러개일 경우 생성자 체이닝을 활용하는 편이 좀 더 일관성 있는 프로그램을 만드는 방법이 될 수 있습니다.
  - 객체의 모든 프로퍼티를 초기화하는 생성자를 주 생성자로 두고 나머지 생성자들은 주 생성자를 체이닝 하도록 하면 더 깔끔한 클래스 상단부를 만들 수 있겠네요!
  - Entity 뿐만 아니라 도메인 쪽에서도 추가된 생성자들을 함께 정리했습니다.

- 크게 남길 코멘트가 없어서 이런 부분까지 얘기해보자면,
  지금 구현이 동시성이나 여러 대의 서버가 뜨는 상황에서 안전한 프로그래밍 방식은 아닌 것 같아요. 
- 보다보니 콘솔 레포에 id 값이 없어도 될 것 같은데 히이로 생각은 어떠신가요?
  - 콘솔 기반 프로그램에는 이력 저장 등의 요구사항이 없었기에 ConsoleRacingCarRepository는 단순하게 생성된 게임 객체를 그대로 저장하게 했습니다.
  - 그 과정에서 map의 key값으로 id를 사용하도록 했습니다. 깊게 고민하지 않았던 부분이라 동시성에 대한 문제는 생각하지 못했던 것 같습니다.
  - 아직 학습해본 부분은 아니지만 스프링을 사용하는 프로젝트라면 @Transactional 키워드를 사용해 이러한 문제를 다룰 수 있을 것 같습니다.
  - 다만 지금은 콘솔 기반 프로그램이므로 해당 방법을 적용하긴 힘들어 보입니다.
  - 범블비가 말씀해주신대로 키를 없애고 단순히 List로 관리하게 되면 당장 프로그램 요구사항은 만족하고 동시성 문제도 해결할 수 있을 것 같아요.
  - 그런데 만약 콘솔 기반에서도 동시성을 고려하면서 id가 필요해지는 기능이 추가되어야 한다면 어떻게 해야할까요?
  - 그 순간이 DB를 연동해야만 하는 타이밍인지, 아니면 순수 자바 기반 프로그램에서도 이런 트랜잭션의 기능을 구현할 수 있는지 궁금해지네요...!

## 23.04.23
### 패캠 실습 강의
- @JsonProperty 어노테이션을 이용해 하나의 프로퍼티에 대해 웹으로 넘어오는 데이터를 맵핑할 수 있다.
- 혹은 @JsonNaming 어노테이션을 클래스에 붙여서 클래스 전체 프로퍼티에 이름 규칙을 적용할 수 있다.
  - @JsonNaming(value = PropertyNamingStrategies.SnakeCaseStrategy.class)
- @RestController를 사용하면 내부에 @ResponseBody 태그가 같이 붙어있기 때문에 리턴하는 원시타입은 그대로 반환하고 객체는 자동으로 Json화 하게 된다.
  - 하지만 @Controller를 사용하면 반환되는 String의 경우 resources 디렉토리 내부에서 이름이 일치하는 html 파일을 찾아서 반환하는 것을 우선순위로 동작하게 된다.
  - @JsonInclude 어노테이션을 활용하면 반환하는 객체의 property 값이 null일 때 이를 자동으로 제외하고 역직렬화 시켜 반환할 수 있다.
  - 일반적으로 API를 설계할 때 직접 페이지를 반환하기 보다는 Json으로 데이터를 주고받는 경우가 많기 때문에 보통은 @RestController를 사용한다.
  - 하지만 page Controller를 직접 사용해야 하는 경우라면 @Controller 어노테이션을 사용한다. 
  - 일반적으로 Page Controller는 Page만 반환하고 @RestController는 API 호출에 따른 값을 넘겨주는 식으로 구현해서 서비스를 제공한다. (서로의 역할을 분리해서 많이 사용한다.)

- ObjectMapper
  - ObjectMapper를 이용해 json(text)를 Object화 할 수 있고, Object를 json(text)화 할 수 있다. 
    - ObjectMapper는 Object를 Json화 할 때 해당 Object 내에 선언된 getter 메서드를 사용하여 수행한다. (ObjectMapper.writeValueAsString)
    - ObjectMapper는 Text를 다시 Object화 할 때 해당 Object의 기본 생성자를 필요로 한다. (ObjectMapper.readValue)
  - 범하기 쉬운 실수!!!
    - ObjectMapper에서 사용하는 객체에 순수 getter 외에 내부의 어떤 결과 값을 반환하는 메서드에 get을 붙이는 경우가 있다.
    - 이렇게 되면 ObjectMapper가 Object를 Text로 변환하는 과정에서 에러가 발생하게 되므로 이를 반드시 지양해야 한다.

- IOC, DI

## 23.04.25 
### 스프링 테스트 강의
- 현업에 들어가면 회고고 나발이고 피처 치는데 급급해질 수 있는데 지금 개발자로서 살아가면서 성장에 필요한 것들을 경험할 수 있었으면 좋겠다.
- 이번 미션에는 전 구간 기능 테스트 구현에 집중해보자.
- 학습 자체를 주도적으로, 능동적으로 해야된다.
- 자기객관화가 안되면 학습이 힘들 수 있다.
  - 레벨2에서 학습하는 활동 목적이 추상적이고 모호해서 끝이 없는 학습을 하고 있는 건 아닌지?
  - 방향성과 목표가 중요하다.

주간회고 - 레벨2의 목표와 계획 세워보기

한번 세운 목표와 계획은 끝까지 가야하나?
아니다. 계속 생각하고 개선이 필요하다.
- 레벨2 끝날 때 내가 세운 목표를 달성했을 때 내 모습이 만족스러울까?
- 계획을 완수하면 목표를 달성하는 것인가?

#### Spring MVC with template engine
- 기존 Json이나 데이터를 내려주던 엔진과 다르게 페이지를 내려주는 템플릿 엔진에 대해 알아볼 것이다.
  - 첫 미션에서는 Spring MVC Annotation을 이용해 웹 요청/응답을 해보는 경험 + Exception 처리 경험 등을 해봤을 것이다.
  - 사실 이 부분은 학습할 양이 굉장히 많아 보이는데 어느정도 사용방식에 대한 것들이 정형화되어 있기 때문에 익숙해지면 괜찮아진다.
  - 컨트롤러에서 어떤 페이지를 보여줄 지 정하고 해당 페이지를 view로부터 받아와서 브라우저에 응답을 쏴준다.
  - 디스패처 서블릿을 학습하면서 다시 알게되겠지만 어떻게 페이지를 만들고 싶은지에 따라 뷰는 달라진다. (템플릿 엔진도 달라진다.)
  - 템플릿 엔진과 뷰가 헷갈릴 수 있다.
    - 뷰는 render라는 메서드가 있는데 이 결과물로 HTML 형식의 페이지가 나온다.
    - 컨트롤러에서 String을 반환하면 선택된 뷰는 여러 템플릿 엔진 중 어떤 엔진을 사용해 페이지를 렌더링할 것인지 찾게 된다.
      - templates 하위 탐색
    - 템플릿 엔진은 렌더링 완료된 페이지를 다시 view로 넘긴다.
  - 만약 학습 테스트트를 찾아봤는데 못찾았다. 어떻게 해야하지
    - 공식 문서 등에서 코드로 다루지 않는 부분들이 많다. 직접 고민하고 왜쓰는지 생각해보고 코드로 작성해본 경험을 해야 기억에 오래 남고 내것이 된다.
    - 무조건 혼자 해결하려고 생각하는 것보다는 주변 사람들에게 도움을 받아보려고 하는 것이 좋다.
    - 예제코드가 없는 경우 학습하는 입장에서는 굉장히 어려울 수 있다.
      - 이론과 실습간의 밸런스가 무너진 상태라 학습이 어려운 상태인데 일단 그 시점에서 놔두는 것을 추천한다.
      - 다른 개념들을 공부하고 시간을 좀 더 들이다보면 다시 이해할 수 있는 시기가 돌아올 것이다.
      - 어떤 내용인지에 따라 달라질 수 있지만, 예제 코드 자체가 없는 내용이라면 지금 ‘사용’ 측면에서 학습할 주제가 맞나 의심이 될 것 같긴 하네요 ㅎㅎ (브리)
- Test with Spring

- 미션 진행하면서 CRUD API 설계에 대한 고민과 삽질을 많이 해와라 + 2단계에서는 인증 관련 기능 구현 삽질 많이 해보기
- 레벨2는 프리코스 없이 바로 미션을 하다보니 달랐는데 이제는 스프링을 어떻게 잘 짤 수 있을지에 대한 고민을 해보면 좋겠다.
- 가장 먼저 떠오르는 방법은 테스트 코드를 짜서 내 코드에 대한 확신을 챙기는 것이다.
- 레벨1에서는 Junit 기반의 콘솔 테스트를 진행했었다.
  - 컨트롤러 서비스 dao로 웹 어플리케이션을 나눈다면 어디가 가장 테스트를 먼저 작성해야 할까?
  - 계층 부분부분마다 진행해야 하는 테스트도 있지만 부분 통합 테스트, 전체 통합 테스트가 필요해지는 경우도 있다.
  - 이번 시간에는 클라이언트 대상으로 요청을 하고 응답을 받는 과정에 대한 테스트를 학습한다.
  - 어떤 테스트인지에 대한 용어에 집착하지 말고 목적과 점증 대상에 집중하라!
- 요청하는 대상을 테스트 코드로 구현하고
- 테스트 웹 어플리케이션을 작성해서 여기에 보내서 받는 것을 테스트한다.

- 웹 어플리케이션을 띄우는데 여러가지 객체들을 빈으로 등록하는데 @SpringBootTest를 테스트 메서드에 사용하면 이러한 테스트 환경을 쉽게 구축할 수 있도록 해준다.
- webEnvironment
- Random_port, Defined_port를 사용하면 실제 웹 서버가 뜬다.
- NONE : 등록된 스프링 빈만 가지고 테스트를 진행하겠다.
- Mock : 실제 서버를 띄우지는 않는다. 하지만 실제처럼 요청을 처리해주는 가짜 웹 환경을 구성해준다.
  - 이번 미션에서는 실제 서버를 띄워서 테스트를 진행한다.
  - 관심 있으면 학습 자료에 소개된 키워드를 찾아보자.

- WebMvcTest 어노테이션을 사용하면 presentation 레이어 객체들만 띄워서 테스트 환경을 구축하는 방식을 사용할 수 있다.

- 우리는 restAssured를 사용할 것이다. (웹 서버에 보내는 테스트 코드 객체를 만드는 역할)
given에는 헤더, 바디값 설정 등 메세지 전송 전 처리해야 하는 작업들
when에는 어떤 정보가 담긴 메세지를 보낼 것인지
then에는 요청에 대한 응답 결과를 받는다.

요청에 대한 결과값을 검증하는 방식으로 테스트를 진행할 수 있다.
왜 부분이 아닌 전체를 검증할까? 부분 vs 전체 무엇이 더 중요할까?


## 23.04.27
### 패캠 강의 정리
- @Component를 붙여서 스프링 빈으로 관리할 수 있다.
  - 인터페이스 타입을 인자로 받아서 어떤 빈이 주입되어야 하는지 모호한 경우 @Qualifier 어노테이션을 통해 기본적으로 생성될 빈의 이름을 설정해줄 수 있다.
- 클래스에 @Configuration 어노테이션을 사용하면 해당 클래스 내 메서드를 정의해서 빈을 직접 등록해줄 수 있다.
  - 내부 정의 메서드에 @Bean 어노테이션을 붙이면 반환하는 객체 타입을 빈으로 등록해 사용할 수 있게 된다.


## 23.04.28
### 웹 API 디자인 (장바구니 피드백 1 강의)
- 오늘은 피드백 위주로 진행할 것이다.
- 저희는 미션 상 DB에 데이터를 저장하고 있습니다. 그런데 ResponseEntity에서 created 메서드를 사용하면 생성된 데이터의 URI를 반환하도록 하더라구요.
- 이런 경우에는 어떤 URI를 반환하도록 하는 것이 좋은가요?
  - HTTP 명세 중 Location이라는 헤더를 다루는 것들이 있는데 이를 학습해보면 좋을 것 같다.
  - 허브는 상세보기 페이지를 만들어서 해당 URI를 리턴하는 방식으로 했다는 것 같다.


- 웹기반 서비스를 구축한다고 했을 때 클라이언트와 서버라는 계층이 나눠져있다.
- 그 사이에 리퀘스트, 리스폰스 행위로 데이터를 주고 받는다.
- 리퀘스트 리스폰스를 잘 설계하는 것이 왜 중요할까?
  - 혼자서 클라이언트와 서버를 모두 개발하는 것이 아니라면 소통이 중요하기 떄문이다.
- API 설계란?
  - 일련의 규칙을 만드는 것.
- http1.1 에 대한 명세를 보고 싶다면 RFC 2616 문서를 본다.
  - 그 중에서도 header와 관련된 내용을 더 보고 싶다면 RFC header라고 검사해본다.
- HTTP가 있는데 굳이 왜 API 설계를 따로 해줘야되나?
  - 우리 서비스에 알맞은 규약(프로토콜)은 정의되어 있지 않다.
  - 그래서 HTTP 명세만으로는 클라이언트가 원하는 정보를 제공해주기 부족하다.
  - 우리는 그래서 HTTP를 이용해서 API를 설계하는 것이다.
  - HTTP 외에도 다른 프로토콜들도 많이 존재하기 때문에 나중에 이를 이용해서도 설계할 수 있다.

- 좋은 API 설계란?
  - 왜 API설계를 꼭 잘해야 하는걸까?
  - 그냥 서버와 클라이언트가 약속을 잘 하면 되는 거 아닌가?
    - 한 번 정해진 API는 바꾸기가 쉽지 않다.
      - API 변경에 클라이언트가 영향을 받기 때문이다.
    - 항상 새로운 데이터 요소와 비즈니스 규칙이 계속 추가될 가능성은 존재한다.
    - 이럴 때 잘 설계된 API는 커뮤니케이션 비용등을 절감시켜준다.
  - 이미 IT 대기업들이 잘 설계해둔 API를 따라가면 안되나?
    - 실제로 이러한 API들을 많이 참고하기는 한다.
    - API 설계를 표준화하려는 시도를 하기는 했었으나 각 서비스들마다 요구사항이 다르고 환경이 다르기 때문에 포기되었다고 한다.
    - 보통 API를 설계할 떄는 자신들만의 설계를 원하는 경향이 있다.
- REST란?
  - 웹과 같은 시스템이 어떤 방식으로 동작해야 하는지 몇 가지 제약 조건으로 정리해둔 것.
  - 실제 REST는 RFC 문서보다 더 높은 수준의 추상화를 다룬다.
  - HTTP 명세가 어떤 것이고 이를 기반으로 어떻게 API를 설계할 것인지 생각하는 것이 더 중요하다.
  - Rest API 또는 Restful API 규칙이라고 불리우는 것은 참고만 하기
- 용어 설명
  - 리소스
    - 우리가 구현하는 자바 객체와 DB에 저장된 테이블과 리소스는 다를 수 있다.(즉 같을 때도 있다는 소리)
    - 서비스가 어떤 자원을 제공할 수 있는지에 집중한다고 생각하면 된다.
    - 리소스는 서버로부터 얻을 수 있는 데이터 혹은 페이지 등이 될 수 있다.
    - 자원이라는 것은 URI로 식별이 가능해야 한다.
    - 리소스는 네트워크 데이터 개체로 클라이언트가 얻길 원하는 것으로서 서버가 내려줄 수 있어야 한다.
  - URI
    - path와 query로 구성된다.
      - path는 계층적 형태로, query는 비계층적 형태로 구성된 데이터이다.
  - 리소스의 표현?
    - 우리는 레이싱카가 저장된 URI로 데이터를 요청한다고 해서 실제 레이싱카를 전달받는 것이 아니다.
    - 서버는 레이싱 카의 상태를 표현한 정보를 보내준다.
    - 헤더의 content-type 등을 통해서 클라이언트가 리소스에 get요청을 보냈을 떄 서버는 그 리소스를 나타내는 방법을 제공해야 한다.
    - 만약 여러개의 표현이 있는 리소스라면?
      - 클라이언트가 어떤 타입의 데이터를 원하는지 명시한 Accept 헤더 값을 확인해서 값을 반환한다.
    - 컨텐츠 협상 : 내가 원하는 데이터가 뭔지 알리고 받는 개념인데 추가 학습해보면 좋다.
    - 나중에 유명한 API들을 살펴보다 보면 왜 그렇게 설계했는지 생각하면서 봐보자.
  - 많이 사용하는 API 설계
  - 리소스 네이밍 가이드를 참고해서 진행해보자.
    - 다만 무조건적으로 따르지 말고 왜 이렇게 하는지 생각을 해보자.
    - restfulapi.net 페이지를 참고해서 진행했다고 한다.


### 우플비 패캠 실습 강의 수강
- AOP (Aspect Oriented Programming)
  - 관점 지향 프로그래밍
  - 프로그램을 개발할 때 서로 다른 기능들에 대해서 혹은 서로 다른 벤더사에 대해서 공통적인 관심사가 생길 수 있는데 이를 횡단 관심이라고 한다.
  - Method Parameter Log, 실행시간 Log, Parameter Encode 등의 작업들을 예로 들 수 있다.

- 주요 어노테이션
  - @Aspect : 자바에서 널리 사용하는 AOP 프레임워크에 포함되며, AOP를 정의하는 클래스에 할당한다.
  - @PointCut : 기능을 어디에 적용시킬지, 메소드, annotation 등 AOP를 적용시킬 지점을 설정한다.
  - @Before : 메소드를 실행하기 이전에 수행되는 것
  - @After : 메소드가 성공적으로 실행되거나 예외가 발생하더라도 실행된다.
  - @AfterReturning : 메소드 호출 성공 실행 시 수행하는 기능
  - @AfterThrowing : 메소드 호출 실패 예외 발생 시 수행하는 기능
  - @Around : Before/After 모두 제어



















