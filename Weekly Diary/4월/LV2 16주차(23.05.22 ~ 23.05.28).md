# LV2 16주차 (23.05.22 ~ 23.05.28)

---

## 23.05.24
### 지하철 미션 step2 구상
- 최단거리 경로 조회를 위해 필요한 외부 라이브러리를 어떻게 설정하고 사용할 것인지 고민해보자.

- 프로그래밍 요구사항
  - 프로덕션과 테스트 DB 설정을 분리한다.
    - 프로덕션 DB는 로컬에 저장될 수 있도록 설정한다.
    - 테스트용 DB는 인메모리로 동작하도록 한다.

- 기능 요구사항
  - 경로 조회 API 구현
    - 출발역과 도착역 사이 최단 거리 경로를 구하는 API를 구현한다.
    - 최단 거리 경로와 함꼐 총 거리 정보를 함께 응답한다.
    - 한 노선에서 경로 찾기 뿐만 아니라 여러 노선의 환승도 고려한다.
  - 요금 조회 기능 추가
    - 경로 조회 시 요금 정보를 포함해서 응답하도록 수정
  - 요금 계산 기능
    - 기본 운임(10km)이내 : 1,250원
    - 추가 운임 부과 규정
      - 10~50km : 5km 까지마다 100원 추가
      - 50km 초과 : 8km 까지마다 100원 추가

- 도메인 객체 구성을 또 너무 현실의 직관에 맞추려고 해서 어려웠나?
  - PathFinder 만으로 경로를 탐색하고 반환하는 기능 수행은 충분히 할 수 있다.
  - 그런데 굳이 Subway라는 객체가 또 필요할까?
- API / 도메인 / 테이블 간의 괴리감을 어떻게 다뤄야 할지 몰랐던 것 같다.
  - 그러다보니 도메인이 반드시 테이블과 일치해야 하고 다른 상태 값을 가지면 안된다는 생각이 무의식중에 있었던 것 같다.
  - 또한 API에서 나타내는 resource와 도메인 및 테이블 간의 괴리 또한 수행하는 기능이나 가지는 상태값을 동일하게 해서 해결하려고 했었다.
  - 이런 부분을 어떻게 해결해야 하지?

- PathFinder를 조회 명령을 수행할 때마다 초기화 해주는 것은 매우 비효율적이라고 생각했음
  - 그런데 이를 어떻게 관리해야 할 지 감이 안잡힘
  - PathFinder를 빈으로 등록해서 관리? -> 상태를 가지는 bean은 어떤 방식으로 관리해야 하는지 모르겠음, 도메인이 bean으로 관리되어도 되나?
  - PathFinder 인스턴스를 싱글톤으로 관리하는 SimpleFactory 클래스를 만들어볼까 생각해봄. 
  - 그래도 이 팩토리 클래스를 서비스에서 상태 값으로 유지하거나 빈으로 등록해서 유지하지 않는 한 요청마다 초기화를 해줘야 하는 것은 동일함
  - 일단은 시간 부족 이슈와 방법을 선택하지 못하겠어서 조회 명령 시마다 재생성해주는 것으로 구현

- 2단계에서는 pathFinder에서 Path를 반환하는 것으로 구현했음 왜냐하면 그것으로도 충분히 요구사항을 충족할 수 있기 떄문
- 그런데 3단계 요구사항을 충족 시키기 위해서는 station으로써의 경로가 아니라 Section으로써의 경로가 필요하게 됨
  - 왜냐하면 section이 가지고 있는 라인 정보가 필요해졌기 때문
- 생각한 방법은 pathFinder에서 최단 경로 역 리스트와 최단 경로 거리를 따로 반환하도록 메서드를 분리하고 서비스 단에서 Path를 생성해주는 것으로 변경하는 것
  - Path를 생성하기 전에 최단 경로 역 리스트를 가지고 다시 section으로 만들어서 넣어주는 방식으로 리팩토링하면 되지 않을까?
  - 그게 아니면 path로 반환하고 서비스 단에서 요금 계산 시 path 내부의 List<Station>을 가지고 따로 계산할 수 있도록 구현하는 방법도 있을 듯
- 왜 외부 라이브러리에서 사용하는 타입을 상속해서 사용할 생각은 못했을까...! 진짜 유레카다.. 감사합니다 하디...

---

- 객체지향에서 이야기하는 책임은 무엇인가?
  - 객체지향에서 책임은 유지보수할 이유를 말함
  - 객체가 지하철 역과 관련된 책임을 수행하는 단일 책임 객체로 바라봐야 할지 / 아니면 지하철 역 생성, 제거, 조회 세 가지의 책임을 지고 있는 객체로 바라봐야 할지 => 정답이 없는 문제?
- 단일 책임의 원칙은 무엇이고, 왜 지켜야 하는가?


- 도메인, 엔티티, VO, DTO
- 리뷰를 받고 도메인, 엔티티, VO, DTO에 대한 개념과 정의를 다시 정립해보았습니다.
  - 도메인 : 우리가 문제를 해결하고자 하는 문제영역
    - 문제 영역을 클래스화한 것이라면 모두 도메인에 속한다.
    - VO, Entity, Domain Service, POJO Domain 객체 등이 문제 영역을 클래스화한 것이라면 모두 도메인에 속할 수 있다.
  - 엔티티 : 식별자를 가지고 있는 개체
    - 여기서 말하는 식별자란 DB의 id 값만을 의미하는 것은 아님. 비즈니스적으로 어떤 도메인을 해석했을 때 두 도메인이 다르다라고 판단할 수 있게 해주는 근거가 식별자이다.
    - 엔티티를 사용해야 하는 시점은 해당 객체가 어플리케이션의 전체 맥락에서 고유한 정체성을 부여받아서 유지하는 경우이다.
      - 엔티티의 일부 상태 값이 변경된다고 하더라도 식별자가 유지되는 한 해당 객체의 고유 정체성이 유지되어야 한다.
    - 비즈니스 로직을 포함하는 도메인 엔티티 / DB 처리를 위한 영속성 엔티티로 나뉘어 질 수 있다.
  - VO : 특정한 값을 표현하기 위한 객체로 별도의 식별자를 가지지 않는다.
    - 객체 고유의 정체성을 유지하기 위한 식별자를 가지지 않으므로 값을 표현하는 프로퍼티의 일부가 변경된다면 아예 다른 객체가 된다.
    - 그렇기 때문에 한 번 생성된 값 객체는 불변 객체로 정의되어 처음 나타내고자 했던 값이 변경되지 않음을 보장해야 한다.
    - 만약 프로퍼티가 변경되어야 한다면 새로운 값을 표현하는 VO가 생성되어야 한다.
  - DTO : 서로 다른 계층 간 데이터를 묶어서 전달하기 위한 객체
    - 전달하는 데이터를 받기 위한 getter 외의 비즈니스 로직은 일체 수행하지 않는다.

- 현구막이 리뷰해주신 내용에서 엔티티를 관리하기 위한 id 동등성 부여와 비즈니스 정책에 의한 중복 검증이 동일시 될 필요가 있는지에 대한 질문에 대해 많이 고민해봤습니다.
  - 일단 id를 상태 값으로 가지는 station, line, section 객체에 대해 왜 이런 고민을 하게 되었는지에 대해서 생각을 해봤어요.
  - 결론적으로 Domain 객체에게 Entity와 VO로써의 성격을 모두 부여하려고 해서 생긴 문제와 고민들이라고 정리되었습니다.
    - station, line, section 모두 같은 타입의 각 객체 간 모든 상태값이 동일하면 안된다는 비즈니스 로직이 있었습니다.
      - 저는 이 부분에서 객체의 상태 값이 모두 같다면 같은 객체로 바라봐야 한다고 생각하고 VO로서의 성격을 부여하려고 했던 것 같습니다.
      - 그래서 equals & Hashcode 메서드를 재정의하는 부분에서 계속 객체 간 상태 값이 같다면 동등성이 부여되어야 한다는 생각까지 이어졌습니다.
  - 지하철 어플리케이션의 전체 맥락에서 line, station, section은 한 번 객체가 생성되면 고유한 식별자를 부여받고 어플리케이션 컨텍스트 상에서 내부 상태 값이 바뀌더라도 처음에 부여된 그 정체성을 유지해야 합니다.
    - 따라서 값 객체가 아니라 엔티티로 구현되어야 하며 엔티티로서 부여받는 identifier인 id 값만으로 equals를 통한 동등성 비교가 가능하도록 해야한다고 결론을 내릴 수 있었습니다.
    - 또한 각 객체 간 프로퍼티 중복 검증 기능은 객체의 기능으로서 수행할 수 있도록 수정했습니다.

- 서비스 단에서 간단하게 수행할 수 있는 검증 로직을 엄격하게 도메인으로 밀어넣으려고 하다보니 문제들이 발생
  - 엔티티들은 equals 메서드 재정의 시 id만으로 동등성이 판단되도록 구현해야 함
  - 그런데 클라이언트가 새롭게 추가하는 정보로 생성된 도메인 객체의 경우 아직 영속화 과정을 거치지 않아 id가 부여되지 않은 상태로 생성되게 됩니다.
  - 서비스에서 Dao를 이용해 이를 판단하는 것이 아니라 도메인 객체를 매번 완성시켜 도메인 객체에서 이를 검증하도록 구현
    - 예를 들어 Station을 생성하는데 동일한 이름을 가진 Station이 있는지 검증하는 기능이 필요하다고 하면
      - StationService에서 StationDao에 직접 물어보고 판단하는 것이 아니라 다음과 같은 로직으로 수행됩니다.
        - StationDao에서 일단 기존 전체 역들을 받아와서 Stations 객체를 완성시킨다.
        - Stations에서 영속화 과정을 거치지 않은 Station과 동일한 이름의 역이 있는지 확인한다.
        - 중복 로직을 통과하면 영속화 과정을 거치지 않은 station이 추가된 stations를 그대로 영속화.
      - 그런데 재정의된 equals에서 id만을 가지고 동등성을 판단하기에 id가 null인 객체들로 인해 equals를 사용하는 자바 API 코드가 모두 깨지기 시작했습니다.
    - 그래서 equals 메서드를 재정의할 때 최우선적으로 id 간 비교를 하게끔 하고 비교 대상 id 값 중 null이 존재한다면 도메인 로직 상 식별자로 사용될 수 있는 property 조합으로 동등성을 검사할 수 있도록 했습니다.

- 위 방식으로 진행하려고 하면 equals와 hashcode 간 괴리감이 생겼습니다.
  - lineName과 lineColor가 동일하다는 가정하에 영속화가 진행된 객체와 영속화가 진행되지 않은 객체가 있는 상황을 생각해봤습니다.
  - 이 경우 equals는 한 객체의 id가 null이기에 lineName과 lineColor를 이용해 동등성을 비교하게 되고 결과값으로 동등하다고 판단하게 됩니다.
  - 그런데 hashcode의 경우 id가 null일 때 lineName과 lineColor로 hashcode를 만들게 하면 equals에서 동등하다고 판단했던 객체들이 hashcode결과가 다르다는 괴리가 발생하게 되었습니다.

- 이 모든 문제들이 도메인 객체에게 Entity로서 id를 부여해놓고 도메인 로직 상에서 영속화가 진행되지 않은 객체를 사용하려고 하다보니 발생한다고 생각이 되었습니다.
- 도메인 객체들이 엔티티가 되어야 하는 이유?


- 서비스와 도메인의 책임을 어떤 기준으로 나눠줘야 할까?

- id값 포장 시 얻을 수 있는 장점?
- Null 처리
  - 포장 객체를 사용하면 id 값이 null일 수 있는 상황에서 null 처리를 더욱 명확하게 할 수 있습니다. 
  - Long 타입의 id 필드를 직접 사용하는 경우, null 값인지 확인하거나 예외 처리를 수행해야 할 수도 있습니다. 
  - 하지만 포장 객체를 사용하면 null 값을 명시적으로 표현하고 처리하기 쉬워집니다.
- 불변성
  - 포장 객체는 일반적으로 변경 불가능한(immutable) 객체로 설계됩니다. 
  - 이는 id 값의 불변성을 보장할 수 있고, 식별자의 값이 변경되지 않도록 합니다. 
  - 이는 식별자가 개체의 핵심 속성 중 하나이며, 변경되면 개체의 동등성 비교와 식별성에 영향을 줄 수 있는 경우에 중요합니다.
- 추가 기능 제공
  - 포장 객체는 기능을 추가하거나 커스텀 로직을 적용하기 쉽게 만들 수 있습니다. 
  - 포장 객체를 사용하면 id 값을 포함한 다양한 메서드를 추가할 수 있습니다. 
  - 예를 들어, 포장 객체에서 id 값의 유효성을 검증하거나 특정한 형식으로 포맷팅하는 등의 추가 기능을 제공할 수 있습니다.
- 유연성
  - 포장 객체를 사용하면 추후에 식별자 타입을 변경하거나 확장하는 데 유연성을 제공합니다. 
  - 예를 들어, Long 타입의 id 값을 다른 타입으로 변경하려는 경우, 해당 포장 객체를 수정하고 관련된 코드를 변경함으로써 전체 시스템에 쉽게 적용할 수 있습니다.
- 이러한 장점들을 고려하면, 객체에 부여된 Long 타입의 id 값을 포장 객체로 포장해주는 것은 코드의 가독성, 안정성, 유연성을 향상시킬 수 있는 좋은 설계 선택일 수 있습니다.


- LineSections 리팩토링
  - 책임 분리?
  - LineSections에서 지금 graph 자료구조로 데이터를 관리할 필요가 있어?
  - List<Section> 으로 처리하는 로직들을 sections로 분리하면 어떨까?
    - 구체적인 section 생성, 삭제 로직을 sections에 부여하고 LineSections에서는 이를 사용하도록 하는 방향을 고려해보자

- 노선에 지하철 역을 등록하는 기능을 객체(클래스)로 분리할 나만의 기준을 세워보자.
  - 현구막은 객체지향을 하는 이유가 나중에 기능을 변경하거나 유지보수할 때 살펴보고 이해해야 할 코드의 수를 줄이기 위함이다.
  - 그렇지 않으면 로직을 하나 수정해야 할 때마다 연관(의존)된 모든 클래스 파일을 이해해야하는, 살아있는 레거시가 되기 때문이다.
- 한편으로는 절차지향적인 코드를 객체지향적으로 바꿔야만 하는지에 대해서는 의문을 가질 필요가 있다.
  - 절차적인 검증 로직들이 유지보수 하는데 큰 어려움이 없고, 오히려 전체적인 검증 플로우를 이해하는데 도움을 줄 수도 있다.
  - 이런 관점에서 오히려 절차지향적인 코드가 객체지향적인 코드보다 유지보수와 이해에 더 도움이 될 때가 있다.


- 서버 입장에서 프론트의 책임을 고민해줄 필요가 있을까요?
  - 현재 프로젝트에 프론트 외 다른 클라이언트(모바일, TV, 차량용 등)가 추가될 때마다 책임을 고민해주어야 하는 걸까요? 🤔
=> 요건 DM으로 질문드리기




- 도메인에서 엔티티와 VO를 분리하기
  - 도메인은 VO로써 유지 : equals & hashcode 상태 값으로 비교하게끔 변경
  - Entity 새로 만듦 : 그러면 client에게 id가 포함된 데이터를 넘겨야 하는 경우 어떻게 해야 할까?
  - repository에서는 db id를 갖는 entity를 반환한다.
  - service에서 도메인 로직을 수행하기 위해 entity들을 POJO 도메인으로 변환한다.
  - 도메인 로직을 수행한다.
  - 저장할 때는 불러왔던 entity를 이용해 DB에서 기존 값들을 삭제한다.
  - 그 뒤 비즈니스 로직이 수행된 도메인 객체들을 다시 Entity화 해서 삽입한다.
  - 지금은 비즈니스 로직 상 한번에 수정될 객체들이 많지 않아서 이렇게 했는데 나중에 데이터가 정말 많아지면 어떤 방식으로 처리해야 하는지 궁금하다...

- UUID를 비즈니스 단에서 발급해서 영속 계층에도 이를 ID로 사용하게끔 하는 방법
  - 위 방식대로 POJO 도메인 객체와 엔티티를 엄격하게 구분하면 다시 영속화하는 과정에서 처리해줘야 할 사항이 많아진다는 문제가 발생
  - 그래서 id값을 포장해서 UUID를 비즈니스 단에서 부여해 사용하고, DB에서도 이를 key로 사용하도록 수정
  - 왜냐하면 이 방법이 현재 최소한의 수정을 이루면서 문제를 해결할 수 있다고 생각했기 때문이다.


## 23.05.26
### 인프라 강의 2
- 들어가기 전에
  - 이번 1단계에서 팀원들과 했어야 할 논의가 무엇이었을까?
  - 왜 HTTPS를 지원하려고 했나?
  - CORS 설정을 웹서버에 해주는게 좋을까? 각 서버에 해주는게 좋을까?

- spring boot external configuration : DB 접속 시 필요한 ID, 비밀번호 등 민감한 정보등을 설정하는 방법.
  - private repo를 서브모듈로 사용하는 방법도 있다고 한다.
- 백그라운드 작업을 조회하려면 jobs 명령어를 사용하면 된다.
  - 백그라운드 작업은 shell 단위로 생성되기 때문에 다른 shell에서는 조회할 수 없다.
  - ps -ef 명령어로는 조회 가능

- nohup은 시그널을 무시하겠다는 명령어
  - 터미널에서 jar파일을 실행하면 해당 터미널의 자식 프로세스로 생성된다.
  - 이 경우 해당 터미널을 종료하면 해당 터미널의 자식 프로세스들에게도 부모 프로세스가 죽었다는 시그널을 보내게 된다.
  - nohup을 사용해서 이 시그널을 받지 않겠다는 것.


## 23.05.27
### 지하철 미션 피드백 정리
- Sections와 LineSections 그리고 단일 책임 원칙
  - 기존 271줄 가량 되는 LineSections를 어떻게 하면 유지보수성을 향상 시키고 코드 가독성을 높일 수 있을지 고민했습니다. 
  - 맨 처음 LineSections를 설계할 때 jGrapht 라이브러리 사용을 염두에 두고 상태를 관리하기 위한 방법을 결정했습니다.
    - List<Sections>가 아닌 map<Station, List<Section>>을 사용했었습니다.
  - 하지만 실제로 step2를 진행하면서 해당 책임은 PathFinder에게 위임되었고 결과적으로 map으로 LineSections의 상태를 관리하는 이유가 없어졌습니다.
    - 또한 List가 아닌 Map을 통해 상태를 관리하게 되면서 부가적인 로직을 수행하기 위한 코드들도 불필요하게 많이 작성되었습니다.
  - 그래서 리팩토링 과정에서 LineSections의 상태를 관리하기 위한 방법으로 다시 List<Section>으로 변경하였습니다.
    - 또한 List<Section>에 수행되어야 하는 작업들을 분리해서 다시 Sections 객체에게 책임을 부여했습니다.
  - 결과적으로 분리된 책임을 객체별로 정리하면 다음과 같았습니다.
    - LineSections : 한 노선에 포함된 구간들에 대해 수행되어야 하는 기능들을 책임진다. (생성, 삭제)
    - Sections : 구간의 Collection에 대해 수행되어야 하는 기능들을 책임진다.

- 단일 책임 원칙
  - 현구막이 말씀해주신대로 단일 책임 원칙은 단일 객체에게는 하나의 책임만을 부여하여 추후 유지보수성을 높이기 위함이라고 이해했습니다.
  - 여태까지는 객체지향이 기능을 구현할 때 객체별로 딱 compact하게 떨어지는 이쁜 코드를 작성하는 것이라고 추상적으로만 생각해왔던 것 같아요.
  - 이전의 LineSections는 270줄 가량 되는 길이를 가졌었고 노선에 포함되는 구간들을 관리하기 위한 여러 책임들을 갖고 있었습니다.
    - 그 중에서도 노선과 상관 없이 여러 구간들 자체에 대해 수행해야 하는 기능들도 존재했습니다.
    - 그래서 이를 Sections라는 Section 객체에 대한 일급 컬렉션으로 분리했습니다.
    - 결과적으로 노선에 포함되는 구간들에 대한 책임은 LineSections가, 일반적인 구간들의 집합에 대해서 수행되어야 하는 책임은 Sections가 지도록 할 수 있었습니다.
  - 이 책임이라는 것이 사람마다 생각하는 범위가 모두 달라서 어떤 기준을 두고 책임을 생각해야 하는지는 아직 정립하기는 힘든 것 같아요.
  - 조금 더 경험을 쌓아가면서 해당 부분에 대한 기준을 세울 수 있도록 해보겠습니다...!

- 그리고 절차지향적인 로직을 어떻게 하면 객체지향적으로 풀어낼 수 있는지에 대해서도 질문을 드렸었습니다.
  - 현구막이 달아주신 답변을 듣고 생각을 해본 결과 절차지향적인 코드가 언제나 나쁜 것만은 아니라고 생각이 들었어요.
  - 지하철 노선에 역을 추가해서 구간이 새로 생성되는 로직은 자체적으로 이미 절차지향적인 성격을 가지고 있습니다.
  - 그래서 억지로 이 로직들을 분리하는 방법을 찾아서 코드를 쪼개는 것이 좋은게 아니라고 판단했습니다.
    - 오히려 절차지향적인 역 추가 로직을 그대로 나타내는 것이 더 가독성과 유지보수성에 도움이 될 수 있을 것이란 생각이 들었습니다.
    - 물론 아직 제가 이런 복잡함을 풀어내는 객체지향적인 디자인 패턴에 대해서 익숙하지 않아서 방법을 찾아내지 못한 것일 수 있을 것 같아요.
  - 이번 프로젝트에서는 해당 로직을 구현한 코드는 어느정도 절차지향적인 성격을 가지도록하는 것이 적합하겠다고 결정했습니다!

- 도메인 객체에서 Entity와 VO의 분리
  - 해당 부분은 생각해본 결과 비즈니스 로직을 수행하는 부분에서는 확실히 VO로써의 도메인 객체만으로 충분할 것이라 판단하여 이를 분리하였습니다.
  - 비즈니스 로직 수행 이후 다시 Entity화 하는데 필요한 ID로 UUID를 사용할까 고민을 해봤습니다.
    - 현재 비즈니스 로직에서는 VO의 값들로도 충분히 처리가 가능하다고 판단하여 따로 UUID를 부여하지는 않았습니다.
    - 대신 해당 VO를 구분짓는 상태 값의 조합으로 Entity mapping이 가능하도록 구현하였습니다.
  - 리팩토링하는 과정이 마냥 쉽지는 않았지만... 결과적으로 비즈니스 로직을 수행할 때는 영속화를 거치지 않은 entity가 생길 위험에 대한 걱정 없이 유연하게 수행할 수 있게 된 것 같습니다.






