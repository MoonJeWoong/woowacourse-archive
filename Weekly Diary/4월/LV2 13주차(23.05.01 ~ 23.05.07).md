# LV2 13주차 (23.05.01 ~ 23.05.07)

---

## 23.05.01
### 장바구니 step1 피드백 정리
- [x] RestController / Controller 분리하기
  - controller : 도큐먼트는 단수형으로 표현한다는 Rest 규칙에 따라 네이밍
    - AdminController
    - IndexController
  - RestController
    - ProductsController
- [x] ResponseStatus 대신 ResponseEntity 반환하기
  - 개인적으로 코드 양이 많아지게 되었을 때 메서드가 어떤 값을 반환하는지 명시되어 있는 스타일이 더 이해하기 편하다고 생각한다.
  - ResponseStatus로 HTTPStatus를 결정하게 되면 언제 기능이 수행되어 상태 값이 반환되는지 관리하기 힘들어진다고 생각한다.
- [x] Product 도메인 객체 내에서는 price를 int로 관리하기 혹은 돈과 관련된 값이라면 BigDecimal 사용하기
- [x] domain 테스트 진행하기

## 23.05.02
### Authentication & Spring MVC Configuration 강의
- 이번 미션에서는 가볍게 맛만 보는 정도로 인증을 다룰것인데 이게 얼마나 위험한지 한 번 생각해보고 다음레벨 프로젝트 진행 시 심화단계를 진행하면 좋겠다.

#### 인증
- 요구사항이나 뚜렷한 목적 없이 인증을 학습하게 되면 맹목적으로 적용하게 되서 기술을 위한 적용이 될 가능성이 농후하다.
- 어떤 기능을 구현할 떄 인증이 필요하겠다는 필요성을 확실하게 느끼고 적용할 수 있으면 좋겠다.
- 인증과 인가
  - 인증 : 누군지 판별
  - 인가 : 권한이 있는지 확인
  - 인증과 인가 방식은 프로젝트에서 어떤 기능을 구현하는지에 따라서 다르게 적용할 수 있다.
- 인증 방법
  - 인증과 인가는 어떤 자원을 요청했을 떄 내가 그 자원을 진짜 접근할 수 있는지 확인하는 과정이다.
- 모든 서버가 나의 상태를 모르는 것은 아니다.
  - 구현된 서버 방식이나 네트워크 설계상 상태를 가지고 있는 경우도 있다.
  - 지금은 우리가 사용하는 HTTP가 무상태성을 취하기 때문이다.
  - 우리는 서버가 다음에 들어올 요청이 이미 이전에 한 번 요청해본 사용자인지 확인하는 방법에 대해 얘기할 것이다.

- basic Auth
  - 헤더에 id와 password를 담아서 보내는 방식
  - 단순하게 데이터를 인코딩해서 보내는 방식
- 쿠키와 세션
  - 세션방식을 사용하면 인증과정을 거치고 세션ID를 반환하게 된다.
  - 세션ID가 반환될때는 쿠키에 담아서 반환하게 된다.
    - 이 부분은 특정 헤더에 담아서 보낸다는 의미로 받아들이면 될 것 같다.
  - 토큰은 세션과 다르게 별도로 서버쪽에 공간이 존재하지는 않는다.
- 학습 테스트에서 preemptive가 뭔지 모르겠다...
  - 그러면 테스트에서 preemptive를 빼고 보내보자.
    - 그러면 테스트가 실패한다. 헤더에 base64로 인코딩한 값이 사라지게 된다.
    - 원래는 일반적인 요청을 보내고 인증 정보를 서버가 요구하면 그때 인증정보를 담아서 요청하는 핑퐁이 이뤄져야 한다.
    - 그런데 preemptive를 붙여주면 최초 요청을 보낼때 어떤 인증방식을 서버가 요구하는지 파악하는 과정이 생략된다.
    - 일단은 학습테스트에서 basic방식을 사용할 때 어떤 인증방식을 서버가 취하는지 파악하는 과정이 필요한데 이를 생략시켜준다고 생각해주면 될 것같다.


### SpringMVC Configuration
- spring MVC에서는 어노테이션만 단순하게 제공하는게 아니라 여러가지 기능(컴포넌트)들을 제공한다.
- 인터셉터 등을 구현해서 헤더의 값을 뽑아내는 작업을 맡길 수 있다.
- WebMvcConfigure가 이러한 동작을 가능하게 해준다.
  - 내부 코드에서 어떤 것들을 구현해서 사용하는지 찾아보자.
- 기본적인 키워드를 학습하고 나서 이 키워드를 기반으로 확장해서 계속 학습해나가는 방식으로 사고를 해보자.
- 인증과 관련된 기능을 어떻게 패키지화 할 것인가, 다른 프로젝트에서도 사용할 수 있도록 확장성을 갖게 하기 위해서는 어떻게 할지 고민해보자.


## 23.05.03
### 장바구니 미션 기록
- sql 쿼리문에서 where 절에 변수를 맵핑해서 여러번 수행할 수 있는 In 키워드를 알게됨.
- API에서 생성기능이 가장 먼저 구현되어야 한다.
  - 조회기능을 먼저 구현했더니 테스트를 하기가 너무 번거로워졌다...
- api에서 페이지 요청과 api 요청의 path를 구분하는 방법?
  - prefix(접두사)를 활용 : /api/users, /users
  - 서브도메인 활용
- Cart 테이블 설계
  - Cart 테이블
    - cart_id
    - user_id (Foreign Key)
  - Cart-items
    - cart_id
    - product_id
- 기능 명세서를 이제는 API 명세서로 바꿔야겠구나...!
- rest API에서 동일한 HTTPMethod와 URI에 대해서 다른 기능을 수행하기 위해서 parameterMapping을 통해 받아온 변수 값에 따른 메서드 내부 분기를 사용할 수 있다.
- /carts uri로 post를 수행하는게 직관에 맞지 않는다고 생각했었다.
- 그래서 cart 테이블을 member_id와 product_id 를 맵핑하는 테이블로 설계하려 했다.
  - 이렇게 하면 사실 member 한 명당 하나의 장바구니만을 가짐에도 불구하고 해당 정보를 저장하는 테이블이 존재하게 되는 기현상이 발생하게 된다.
  - 원래대로 cart테이블이 member.id와 product.id를 저장하도록 하고 URI를 '/cart?product-id=?' 처럼 쿼리 파라미터를 이용해서 구분하도록 했다.

- /api/cart/items 로 get 메서드 요청을 하면 전체 아이템이 나와야 할 것 같은데... 이걸 해결하고 적절한 URI를 설계할 방법이 없나...?


## 23.05.04
### 학습 테스트 설문
- Authentication 학습 테스트로 익힌 3가지 인증 방식(basic, session, token) 중, 프로젝트를 한다면 어떤 인증 방식을 도입하는게 좋을까요? 
- 이 방식을 택한 이유는 무엇인가요?
  - basic 방식은 너무 단조롭기 때문에 인증방식으로 사용하기에는 적절하지 않다는 생각이 들었습니다.
  - 고려사항으로 세션과 토큰 방식이 남는데 개인적으로 특별한 경우가 아니라면 토큰 방식을 사용할 것 같습니다.
  - 그 이유는 세션의 경우 세션 id가 탈취되었을 때 사용자 개인 정보가 쉽게 노출될 수 있다는 단점이 있다고 생각하기 때문입니다. 
  - 반면 토큰은 노출이 되어도 서버 측에서 토큰에 대한 유효성 검증을 진행하기 때문에 상대적으로 좀 더 안전하다고 생각했습니다.
  - 세션방식의 경우 동시 접속자 차단과 같은 기능에서 세션 관리가 필요할 때 중요한 정보를 노출시키지 않는 선에서 사용할 수 있을 것 같습니다.

### mvc-handlerInterceptor
- HandlerMapping => URL에 핸들러를 맵핑하기 위함
- 디스패처 서블릿은 HandlerAdapter를 통해 실제로 메서드를 호출한다.
- interceptor는 request를 가로채고 이를 처리한다.
  - 로깅이나 인증과 같은 반복적인 handler 코드를 피하기 위함이다.

#### SpringHandlerInterceptor
- 스프링 interceptor는
  - HandlerInterceptorAdapter 클래스를 상속하거나
  - HandlerInterceptor 인터페이스를 구현하는 것 중 하나이다.
- Handler Interceptor는 다음과 같은 세 가지 주요 메서드를 포함한다.
  - preHandle() : 실제 핸들러 수행 이전에 호출된다.
    - preHandle() 메서드 반환 값은 boolean인데 true이면 스프링에게 request 수행을 속행시키고 false이면 중단한다. 
  - postHandle() : 실제 핸들러가 수행 완료된 이후 호출된다.
    - request가 처리되고 view가 렌더링 되기 전에 수행된다.
    - 예를 들어 로그인 한 사용자의 아바타를 model에 추가하는 등의 기능을 수행할 수 있다.
  - afterCompletion(): request수행이 완료되고 뷰가 생성되고 나서 호출된다.
    - request처리가 끝나고 커스텀 로직을 수행할 수 있도록 해준다.
- interceptor 구현이 끝나면 해당 interceptor를 WEbMvcConfigurer를 구현한 configuration 클래스에서 addInterceptors 메서드를 오버라이딩 해서 등록한다.


### 장바구니 미션을 진행하며...
- 도메인 객체를 먼저 설계하도록 하자.
- Persistence 계층 설계를 먼저 생각하고 도메인을 설계하려고 하니 굉장히 생각이 복잡해졌다.
  - 다음부터는 도메인을 먼저 설계하고 여기에 다른 로직들을 맞추도록 하자.













