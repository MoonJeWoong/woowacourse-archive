# LV2 15주차 (23.05.15 ~ 23.05.21)

---

## 23.05.15
### 3주차 지하철 노선도 미션

## 23.05.14
### 지하철 미션 1차 코드리뷰 정리
- 객체지향 생활체조 규칙 다시 적용시켜 보기
- 지하철 역 애플리케이션을 통해 하고 싶은 것, 즉 use-case가 무엇인지 파악하지 않고 직관에 따른 도메인 설계를 진행
  - 이렇게 설계된 domain에 어플리키에션의 use-case를 맞추려고 해서 어긋난 부분들이 많다.
  - 해결책은 해결해야 하는 요구사항에 맞춰서 도메인 모델을 나누는 것.
  - 앞으로는 도메인을 위한 도메인 혹은 우리의 직관에 따른 도메인이 아니라 요구사항을 충족시키기 위한 도메인을 설계해야 함을 잊지말자...!
- 현재 요구사항에 존재하지 않는 API들이 많이 구현되어 있다.
  - 비즈니스 요구사항을 기술적으로 풀어내는 것이 최우선순위.
  - 기술이 어려워서 비즈니스 요구사항을 충족시키지 못하는 상황은 없어야만 한다.
- 고객이 원하는 기능을 고객이 원하는 시점에 전달하는 것. 개발자 뿐만 아니라 돈을 받으며 일을 하는 프로로서 당연히 지켜야 할 원칙이다.
  - 아무리 급해도 항상 80~90점 짜리 소프트웨엉를 일정 내에 개발할 수 있는 방법을 연구하고, 연마해야 한다.
  - 이것이 바로 경력이고, 잠밥이고, 생산성이다.
  - 실력이 뛰어난 개발자들은 본인만의 원칙을 기준으로 빠르게 의사결정을 진행한다.
  - 그동안 경험을 통해 여러가지 확고한 원칙을 세웠기 때문에 대부분의 경우 빠르게 결정을 내릴 수 있고, 정말 설계가 필요한 부분에 대해서만 깊은 고민을 진행할 수 있게 된다.
  - 이렇게 되면 일정은 일정대로 지켜지고, 퀄리티가 정말 중요한 부분에서도 퀄리티를 챙길 수 있게 된다.



- 이번 미션에서 API 기능 요구사항의 use-case를 고려하지 않고 우리의 직관대로 도메인을 설계한 것이 어려움의 큰 요인이었다.
  - 다시 API 기능 요구사항을 기반으로 설계를 변경하기 위해 API 통합 테스트를 먼저 확인하고 수정하자.
  - 어디까지가 프론트의 책임이고 백엔드의 책임인지 모호한 것 같다. 일반적으로 팀 회의를 통해 결정해서 팀마다 그 기준이 상이할 것이라 생각한다.
  - 이번에 페어와 미션을 진행하면서 프론트 입장에서는 이미 어떤 역들이 어떤 순서로 노선을 구성하는지에 대한 정보를 알고 있는 상태로 역에 대한 작업을 수행할 것이라 생각했다.
  - 그래서 삽입/삭제 하고자 하는 역이 중간에 있는 역인지, 종점인지, 노선에 처음 추가되는 역인지 알고 요청을 할 수 있다고 가정했었다.
  - 그런데 현구막은 왜 처음 API를 봤을 때 백엔드의 책임이 프론트의 책임으로 넘겨둔 것이라고 느꼈는지 그 이유에 대해 질문드리고 싶다.

- 이번 미션에서 복잡했던 것은 생성로직이였다고 생각이 듭니다. 이 생성로직을 차근차근 다시 분리하며 정리해보니 굉장히 절차지향적으로 정리가 되는 것 같습니다.
- 그런데 이런 절차지향적인 코드를 객체지향으로 풀어내는 것이 정말 감이 안잡히는 것 같습니다. 이럴 때 개발자는 어떤 방법으로 접근해봐야 할까요?
- [x] 새로운 구간을 생성한다.
  - [x] 노선에 처음 역이 추가되는 경우
    - [x] `상행 종점 - 하행 종점`으로 구간이 생성된다.
  - [x] 노선의 기존 역을 기준으로 추가되는 경우
    - [x] 상행 방향 역이 신규역인 경우
      - [x] 구간 사이에 역이 추가될 때
        - [x] 하행 방향 역이 포함된 해당 노선의 구간을 찾아서 두 구간으로 나눠준다.
          - [x] `신규역 - 기존 하행 방향 역`, `기존 상행 방향 역 - 신규역` 구간을 추가한다.
          - [x] `기존 상행 방향 역 - 기존 하행 방향 역` 구간을 삭제한다.
        - [x] 종착 구간 마지막에 역이 추가될 때
          - [x] 상행 방향 역이 포함된 해당 노선의 구간을 찾아서 두 구간으로 나눠준다.
            - [x] `기존 상행 방향 역 - 신규역`, `신규역 - 기존 하행 방향 역` 구간을 추가한다.
            - [x] `기존 상행 방향 역 - 기존 하행 방향 역` 구간을 삭제한다.
        - [x] `새로운 역과 기존 역 사이 거리 >= 구간의 기존 거리` 인 경우 예외처리한다.
    - [x] 하행 방향 역이 신규역인 경우
      - [x] 구간 사이에 역이 추가될 때
        - [x] 기존 하행 방향 역이 포함된 노선 구간이 1개인지 확인해서 상행 종착 구간인지 확인한다.
        - [x] 상행 종착 구간임이 확인되면 입력된 `신규역 - 기존 상행 종착 역` 구간을 추가한다.
      - [x] 종착 구간 마지막에 역이 추가될 때
        - [x] 기존 상행 방향 역이 포함된 노선 구간이 1개인지 확인해서 하행 종착 구간인지 확인한다.
        - [x] 하행 종착 구간임이 확인되면 입력된 `기존 하행 종착 역- 신규역` 구간을 추가한다.
      - [x] `새로운 역과 기존 역 사이 거리 >= 구간의 기존 거리` 인 경우 예외처리한다.
    - [x] 상행역과 하행역이 이미 노선에 존재하는 경우 예외처리한다.

- SectionController에서 Post 명령을 수행할 때 생성된 구간의 id를 포함시켜서 CreatedURI를 메세지 헤더에 담아서 보내는 것이 일반적이라 생각.
  - 그런데 section이 한 요청으로 여러개 생성되어 버리는 경우는 어떻게 해야 하는지...? 도메인 로직 상 CreatedURI를 반환하지 않거나
  - 다른 리소스의 URI를 반환하는 경우도 있는지 궁금합니다. (이번 같은 경우 지하철 노선의 전체 역을 조회할 수 있는 URI?)


## 23.05.16
### 지하철 미션 피드백1 + COnfiguration 학습 테스트
- 프로젝트 규모가 커지면서 테스트는 어떻게 해야할 지, 구조는 어떻게 가져가야할 지 고민들이 되었을 것이다. 
- Dto는 어느 레이어에 속하게 하는 게 좋을까?
  - 어떤 계층간의 transfer가 이루어지는가?
    - 컨트롤러에서 정의한 DTO를 presentation Layer에서 클라이언트 단까지 사용할 수 있다.
    - 서비스에서 정의한 DTO를 컨트롤러 혹은 클라이언트까지 사용할 수 있다.
    - 정답은 없기 때문에 본인의 관점과 근거를 잘 얘기할 수 있도록 해보자.
- 이번 미션에서 section의 도메인 책임이 계속 커진다는 피드백을 받은 사람들이 있을 것이다.
  - 어떻게 설계를 했는지, 설계를 변경했다면 그 근거는 무엇인지 정하자. 정답은 없다.
- 단위 테스트 중복?
  - 레이어별로 만들어 놓은 단위 테스트가 같은 기능을 검증하는 것 같음
  - 컨트롤러 테스트에서 세부적인 비즈니스 규칙을 모두 검증할 필요가 있을까?
  - 검증하고자 하는 대상이 무엇인지에 집중
  - 테스트 코드나 이름은 중복될 수 있어도 테스트 하는 대상에 따라 검증하는 내용이 달라질 수 있다.
  - 컨트롤러는 클라이언트의 요청을 받아서 응답을 내려주는 것이 주된 역할이다.
    - 그런데 컨트롤러 테스트에서 비즈니스 로직 부분의 검증이 수행되어야 할까?
  - 통합테스트도 어떤 것을 목적으로 잡고 수행할 것인지에 따라 달라지게 된다.
    - 비즈니스 로직 별로 통합테스트를 진행할 것인지, 아니면 전체적인 기능의 정상 동작만을 진행할 것인지에 따라 달라질 것이다.
  - 상황에 따라 UI test / Integration Tests / Unit Tests 로 나눌 수 있는데 UI tests가 비용이 가장 높다.
    - 이번 미션처럼 비즈니스 로직이 복잡한 경우 Unit Tests의 비중이 가장 큰 피라미드 형식의 그림이 나온다.
    - 반대로 Json 상하차만 하는 API의 경우 반대로 UI TESTs가 가장 비중이 큰 역피라미드형이 나올 수 있다.
- 테스트에서만 사용되는 프로덕션 코드?
  - 최대한 지양하되 우리의 정신건강을 위해 일부 허용을 하자!
  - 테스트를 위한 생성자 추가 등...
  - 테스트가 작성하기 어려운 모멘트를 만났을 때 고민할 거리들 (리플레이 찾아보기 28분 ~ 30분 즈음)
- Configuration (40분 즈음)

- Datasource

- profile
  - 상황에 따른 application context를 다르게 설정해줄 수 있다.
  - 실제 프로덕션 컨텍스트에서는 내장 DB를 사용하게 하고 테스트 컨텍스트에서는 인메모리 DB가 동작하도록 설정할 수 있다.
  - 환경 별로 활성화할 profile을 선택해서 활성화 시킬 수 있다.
  - @Profile 설정과 @Configuration 어노테이션이 둘 다 없으면 어떤게 더 우선순위가 되는지? 등등...
  - 


## 23.05.18
### 지하철 미션 step2 구상
- 최단거리 경로 조회를 위해 필요한 외부 라이브러리를 어떻게 설정하고 사용할 것인지 고민해보자.

- 프로그래밍 요구사항
  - 프로덕션과 테스트 DB 설정을 분리한다.
    - 프로덕션 DB는 로컬에 저장될 수 있도록 설정한다.
    - 테스트용 DB는 인메모리로 동작하도록 한다.

- 기능 요구사항
  - 경로 조회 API 구현
    - 출발역과 도착역 사이 최단 거리 경로를 구하는 API를 구현한다.
    - 최단 거리 경로와 함꼐 총 거리 정보를 함께 응답한다.
    - 한 노선에서 경로 찾기 뿐만 아니라 여러 노선의 환승도 고려한다.
  - 요금 조회 기능 추가
    - 경로 조회 시 요금 정보를 포함해서 응답하도록 수정
  - 요금 계산 기능
    - 기본 운임(10km)이내 : 1,250원
    - 추가 운임 부과 규정
      - 10~50km : 5km 까지마다 100원 추가
      - 50km 초과 : 8km 까지마다 100원 추가

- 도메인 객체 구성을 또 너무 현실의 직관에 맞추려고 해서 어려웠나?
  - PathFinder 만으로 경로를 탐색하고 반환하는 기능 수행은 충분히 할 수 있다.
  - 그런데 굳이 Subway라는 객체가 또 필요할까?
- API / 도메인 / 테이블 간의 괴리감을 어떻게 다뤄야 할지 몰랐던 것 같다.
  - 그러다보니 도메인이 반드시 테이블과 일치해야 하고 다른 상태 값을 가지면 안된다는 생각이 무의식중에 있었던 것 같다.
  - 또한 API에서 나타내는 resource와 도메인 및 테이블 간의 괴리 또한 수행하는 기능이나 가지는 상태값을 동일하게 해서 해결하려고 했었다.
  - 이런 부분을 어떻게 해결해야 하지?

- PathFinder를 조회 명령을 수행할 때마다 초기화 해주는 것은 매우 비효율적이라고 생각했음
  - 그런데 이를 어떻게 관리해야 할 지 감이 안잡힘
  - PathFinder를 빈으로 등록해서 관리? -> 상태를 가지는 bean은 어떤 방식으로 관리해야 하는지 모르겠음, 도메인이 bean으로 관리되어도 되나?
  - PathFinder 인스턴스를 싱글톤으로 관리하는 SimpleFactory 클래스를 만들어볼까 생각해봄. 
  - 그래도 이 팩토리 클래스를 서비스에서 상태 값으로 유지하거나 빈으로 등록해서 유지하지 않는 한 요청마다 초기화를 해줘야 하는 것은 동일함
  - 일단은 시간 부족 이슈와 방법을 선택하지 못하겠어서 조회 명령 시마다 재생성해주는 것으로 구현

- 2단계에서는 pathFinder에서 Path를 반환하는 것으로 구현했음 왜냐하면 그것으로도 충분히 요구사항을 충족할 수 있기 떄문
- 그런데 3단계 요구사항을 충족 시키기 위해서는 station으로써의 경로가 아니라 Section으로써의 경로가 필요하게 됨
  - 왜냐하면 section이 가지고 있는 라인 정보가 필요해졌기 때문
- 생각한 방법은 pathFinder에서 최단 경로 역 리스트와 최단 경로 거리를 따로 반환하도록 메서드를 분리하고 서비스 단에서 Path를 생성해주는 것으로 변경하는 것
  - Path를 생성하기 전에 최단 경로 역 리스트를 가지고 다시 section으로 만들어서 넣어주는 방식으로 리팩토링하면 되지 않을까?
  - 그게 아니면 path로 반환하고 서비스 단에서 요금 계산 시 path 내부의 List<Station>을 가지고 따로 계산할 수 있도록 구현하는 방법도 있을 듯
- 왜 외부 라이브러리에서 사용하는 타입을 상속해서 사용할 생각은 못했을까...! 진짜 유레카다.. 감사합니다 하디...

---

- 객체지향에서 이야기하는 책임은 무엇인가?
  - 객체지향에서 책임은 유지보수할 이유를 말함
  - 객체가 지하철 역과 관련된 책임을 수행하는 단일 책임 객체로 바라봐야 할지 / 아니면 지하철 역 생성, 제거, 조회 세 가지의 책임을 지고 있는 객체로 바라봐야 할지 => 정답이 없는 문제?
- 단일 책임의 원칙은 무엇이고, 왜 지켜야 하는가?


- 도메인, 엔티티, VO, DTO
- 리뷰를 받고 도메인, 엔티티, VO, DTO에 대한 개념과 정의를 다시 정립해보았습니다.
  - 도메인 : 우리가 문제를 해결하고자 하는 문제영역
    - 문제 영역을 클래스화한 것이라면 모두 도메인에 속한다.
    - VO, Entity, Domain Service, POJO Domain 객체 등이 문제 영역을 클래스화한 것이라면 모두 도메인에 속할 수 있다.
  - 엔티티 : 식별자를 가지고 있는 개체
    - 여기서 말하는 식별자란 DB의 id 값만을 의미하는 것은 아님. 비즈니스적으로 어떤 도메인을 해석했을 때 두 도메인이 다르다라고 판단할 수 있게 해주는 근거가 식별자이다.
    - 엔티티를 사용해야 하는 시점은 해당 객체가 어플리케이션의 전체 맥락에서 고유한 정체성을 부여받아서 유지하는 경우이다.
      - 엔티티의 일부 상태 값이 변경된다고 하더라도 식별자가 유지되는 한 해당 객체의 고유 정체성이 유지되어야 한다.
    - 비즈니스 로직을 포함하는 도메인 엔티티 / DB 처리를 위한 영속성 엔티티로 나뉘어 질 수 있다.
  - VO : 특정한 값을 표현하기 위한 객체로 별도의 식별자를 가지지 않는다.
    - 객체 고유의 정체성을 유지하기 위한 식별자를 가지지 않으므로 값을 표현하는 프로퍼티의 일부가 변경된다면 아예 다른 객체가 된다.
    - 그렇기 때문에 한 번 생성된 값 객체는 불변 객체로 정의되어 처음 나타내고자 했던 값이 변경되지 않음을 보장해야 한다.
    - 만약 프로퍼티가 변경되어야 한다면 새로운 값을 표현하는 VO가 생성되어야 한다.
  - DTO : 서로 다른 계층 간 데이터를 묶어서 전달하기 위한 객체
    - 전달하는 데이터를 받기 위한 getter 외의 비즈니스 로직은 일체 수행하지 않는다.

- 현구막이 리뷰해주신 내용에서 엔티티를 관리하기 위한 id 동등성 부여와 비즈니스 정책에 의한 중복 검증이 동일시 될 필요가 있는지에 대한 질문에 대해 많이 고민해봤습니다.
  - 일단 id를 상태 값으로 가지는 station, line, section 객체에 대해 왜 이런 고민을 하게 되었는지에 대해서 생각을 해봤어요.
  - 결론적으로 Domain 객체에게 Entity와 VO로써의 성격을 모두 부여하려고 해서 생긴 문제와 고민들이라고 정리되었습니다.
    - station, line, section 모두 같은 타입의 각 객체 간 모든 상태값이 동일하면 안된다는 비즈니스 로직이 있었습니다.
      - 저는 이 부분에서 객체의 상태 값이 모두 같다면 같은 객체로 바라봐야 한다고 생각하고 VO로서의 성격을 부여하려고 했던 것 같습니다.
      - 그래서 equals & Hashcode 메서드를 재정의하는 부분에서 계속 객체 간 상태 값이 같다면 동등성이 부여되어야 한다는 생각까지 이어졌습니다.
  - 지하철 어플리케이션의 전체 맥락에서 line, station, section은 한 번 객체가 생성되면 고유한 식별자를 부여받고 어플리케이션 컨텍스트 상에서 내부 상태 값이 바뀌더라도 처음에 부여된 그 정체성을 유지해야 합니다.
    - 따라서 값 객체가 아니라 엔티티로 구현되어야 하며 엔티티로서 부여받는 identifier인 id 값만으로 equals를 통한 동등성 비교가 가능하도록 해야한다고 결론을 내릴 수 있었습니다.
    - 또한 각 객체 간 프로퍼티 중복 검증 기능은 객체의 기능으로서 수행할 수 있도록 수정했습니다.

- 서비스 단에서 간단하게 수행할 수 있는 검증 로직을 엄격하게 도메인으로 밀어넣으려고 하다보니 문제들이 발생
  - 엔티티들은 equals 메서드 재정의 시 id만으로 동등성이 판단되도록 구현해야 함
  - 그런데 클라이언트가 새롭게 추가하는 정보로 생성된 도메인 객체의 경우 아직 영속화 과정을 거치지 않아 id가 부여되지 않은 상태로 생성되게 됩니다.
  - 서비스에서 Dao를 이용해 이를 판단하는 것이 아니라 도메인 객체를 매번 완성시켜 도메인 객체에서 이를 검증하도록 구현
    - 예를 들어 Station을 생성하는데 동일한 이름을 가진 Station이 있는지 검증하는 기능이 필요하다고 하면
      - StationService에서 StationDao에 직접 물어보고 판단하는 것이 아니라 다음과 같은 로직으로 수행됩니다.
        - StationDao에서 일단 기존 전체 역들을 받아와서 Stations 객체를 완성시킨다.
        - Stations에서 영속화 과정을 거치지 않은 Station과 동일한 이름의 역이 있는지 확인한다.
        - 중복 로직을 통과하면 영속화 과정을 거치지 않은 station이 추가된 stations를 그대로 영속화.
      - 그런데 재정의된 equals에서 id만을 가지고 동등성을 판단하기에 id가 null인 객체들로 인해 equals를 사용하는 자바 API 코드가 모두 깨지기 시작했습니다.
    - 그래서 equals 메서드를 재정의할 때 최우선적으로 id 간 비교를 하게끔 하고 비교 대상 id 값 중 null이 존재한다면 도메인 로직 상 식별자로 사용될 수 있는 property 조합으로 동등성을 검사할 수 있도록 했습니다.

- 위 방식으로 진행하려고 하면 equals와 hashcode 간 괴리감이 생겼습니다.
  - lineName과 lineColor가 동일하다는 가정하에 영속화가 진행된 객체와 영속화가 진행되지 않은 객체가 있는 상황을 생각해봤습니다.
  - 이 경우 equals는 한 객체의 id가 null이기에 lineName과 lineColor를 이용해 동등성을 비교하게 되고 결과값으로 동등하다고 판단하게 됩니다.
  - 그런데 hashcode의 경우 id가 null일 때 lineName과 lineColor로 hashcode를 만들게 하면 equals에서 동등하다고 판단했던 객체들이 hashcode결과가 다르다는 괴리가 발생하게 되었습니다.

- 이 모든 문제들이 도메인 객체에게 Entity로서 id를 부여해놓고 도메인 로직 상에서 영속화가 진행되지 않은 객체를 사용하려고 하다보니 발생한다고 생각이 되었습니다.
- 도메인 객체들이 엔티티가 되어야 하는 이유?


- 서비스와 도메인의 책임을 어떤 기준으로 나눠줘야 할까?

- id값 포장 시 얻을 수 있는 장점?
- Null 처리
  - 포장 객체를 사용하면 id 값이 null일 수 있는 상황에서 null 처리를 더욱 명확하게 할 수 있습니다. 
  - Long 타입의 id 필드를 직접 사용하는 경우, null 값인지 확인하거나 예외 처리를 수행해야 할 수도 있습니다. 
  - 하지만 포장 객체를 사용하면 null 값을 명시적으로 표현하고 처리하기 쉬워집니다.
- 불변성
  - 포장 객체는 일반적으로 변경 불가능한(immutable) 객체로 설계됩니다. 
  - 이는 id 값의 불변성을 보장할 수 있고, 식별자의 값이 변경되지 않도록 합니다. 
  - 이는 식별자가 개체의 핵심 속성 중 하나이며, 변경되면 개체의 동등성 비교와 식별성에 영향을 줄 수 있는 경우에 중요합니다.
- 추가 기능 제공
  - 포장 객체는 기능을 추가하거나 커스텀 로직을 적용하기 쉽게 만들 수 있습니다. 
  - 포장 객체를 사용하면 id 값을 포함한 다양한 메서드를 추가할 수 있습니다. 
  - 예를 들어, 포장 객체에서 id 값의 유효성을 검증하거나 특정한 형식으로 포맷팅하는 등의 추가 기능을 제공할 수 있습니다.
- 유연성
  - 포장 객체를 사용하면 추후에 식별자 타입을 변경하거나 확장하는 데 유연성을 제공합니다. 
  - 예를 들어, Long 타입의 id 값을 다른 타입으로 변경하려는 경우, 해당 포장 객체를 수정하고 관련된 코드를 변경함으로써 전체 시스템에 쉽게 적용할 수 있습니다.
- 이러한 장점들을 고려하면, 객체에 부여된 Long 타입의 id 값을 포장 객체로 포장해주는 것은 코드의 가독성, 안정성, 유연성을 향상시킬 수 있는 좋은 설계 선택일 수 있습니다.


- LineSections 리팩토링
  - 책임 분리?
  - LineSections에서 지금 graph 자료구조로 데이터를 관리할 필요가 있어?
  - List<Section> 으로 처리하는 로직들을 sections로 분리하면 어떨까?
    - 구체적인 section 생성, 삭제 로직을 sections에 부여하고 LineSections에서는 이를 사용하도록 하는 방향을 고려해보자

- 노선에 지하철 역을 등록하는 기능을 객체(클래스)로 분리할 나만의 기준을 세워보자.
  - 현구막은 객체지향을 하는 이유가 나중에 기능을 변경하거나 유지보수할 때 살펴보고 이해해야 할 코드의 수를 줄이기 위함이다.
  - 그렇지 않으면 로직을 하나 수정해야 할 때마다 연관(의존)된 모든 클래스 파일을 이해해야하는, 살아있는 레거시가 되기 때문이다.
- 한편으로는 절차지향적인 코드를 객체지향적으로 바꿔야만 하는지에 대해서는 의문을 가질 필요가 있다.
  - 절차적인 검증 로직들이 유지보수 하는데 큰 어려움이 없고, 오히려 전체적인 검증 플로우를 이해하는데 도움을 줄 수도 있다.
  - 이런 관점에서 오히려 절차지향적인 코드가 객체지향적인 코드보다 유지보수와 이해에 더 도움이 될 때가 있다.


- 서버 입장에서 프론트의 책임을 고민해줄 필요가 있을까요?
  - 현재 프로젝트에 프론트 외 다른 클라이언트(모바일, TV, 차량용 등)가 추가될 때마다 책임을 고민해주어야 하는 걸까요? 🤔
=> 요건 DM으로 질문드리기









### Facade 패턴 패캠 강의 정리
- Facade는 건물의 앞쪽 정면이라는 뜻을 가진다.
  - 여러 개의 객체와 실제 사용하는 서브 객체의 사이에 복잡한 의존관계가 있을 때, 중간에 facade라는 객체를 두고, 여기서 제공하는 인터페이스만을 활용해서 기능을 사용하는 방식이다.
  - Facade는 자신이 가지고 있는 각 클래스의 기능을 명확하게 알아야만 한다.
  - 개발하면서 여러개의 객체를 사용해서 기능을 수행해야 할 때 주로 많이 사용한다.
  - 예를 들어서 FTP client가 있다고 가정해보자.
    - client 객체는 FTP, Writer, Reader 객체마다 connection을 열고 닫아주는 코드들을 사용해야한다.
    - 이로 인해 client 객체 내부에서 각 객체들의 connection을 관리하는 코드들이 혼재하게 되서 복잡해진다.
    - 이런 복잡한 코드를 facade 객체를 둬서 client 객체에서는 facade 객체에 정의된 인터페이스만 활용해서 기능을 사용할 수 있도록 한다.
    - 이렇게 함으로써 client는 단순하게 작업을 수행할 수 있게 되고 복잡한 코드들은 facade 객체에게 위임할 수 있었다.


## 23.05.19
### 지하철 미션 step2 피드백 및 ATDD
이번 특강에서 얘기하고 싶은 부분들
- 인수 테스트가 무엇인지
- 인수 테스트 주도 개발이 무엇이고 왜 하는지
- TDD를 조금 더 잘하기 위해서 인수 테스트를 어떻게 활용하는지

간혹 개발을 하다보면 길을 잃을 때가 있다.
- 세부적인 기능을 구현하다보면 궁극적으로 무엇을 구현하려고 했었던 건지 방향성을 잃게 되는 경우가 있다.
- 현업에서 일을 할 때 요구사항 자체를 잘못 파악하게 되는 경우도 있다.

ATDD란?
- **테스트가 가능한 요구사항**으로 소프트웨어를 개발하는 프로세스
- **요구사항을 검증하는 테스트**로 소프트웨어를 개발하는 프로세스
- **인수테스트**로 소프트웨어를 개발하는 프로세스

ATDD를 하는 이유?
- 생산성의 증가
  - 구현 전에 인수 테스트를 진행하는 경우 팀의 생산성이 두 배가 된다. (요구사항과 개발 사이 오인으로 인한 불필요한 프로세스를 줄일 수 있다.)

TDD VS ATDD
- TDD는 작은 단위의 요구사항에 대해서 테스트를 만들고 이를 통과시키기 위한 코드를 구현한다.
- ATDD는 시나리오 형태의 요구사항에 대해 (인수)테스트를 만들고 이를 통과시키기 위한 코드를 구현한다.
- 각 방식에서 테스트가 우리가 개발해야하는 방향을 제시하는 역할을 하게 된다.

브라운이 생각하는 ATDD 장점
- 작업의 시작과 끝을 명시한다.
  - 이 인수테스트가 통과하는 순간 작업의 끝남을 보장한다.
- 빠른 피드백 
- 귀찮은 작업을 프로세스로 강제
  - 테스트 작성 및 문서화 작업까지 어느정도 강제할 수 있다.
- 이러한 장점들을 들었을 때 그냥 받아들이지 말고 직접 사용해보고 경험을 통해 이를 받아들였으면 좋겠다.


(extreme 프로그래밍에서의) 인수테스트란?
- TDD 싸이클에 진입하기 전에 작성하는 테스트가 있는데 이를 인수 테스트라고 한다.
- 사용자 스토리를 검증하는 기능 테스트
- 사용자 스토리로 테스트할 시나리오를 지정한다.
- 명세나 계약의 요구사항이 충족되는지 확인하기 위해 수행되는 테스트 

테스트 종류는 용어에 집중하지 말고 무엇을 어떻게 테스트하는지에 초점을 맞춰야 한다.
- 단위 테스트
- 통합 테스트
- E2E 테스트

- 인수테스트를 작성할 때 모든 기능을 전체 한 사이클에 다 넣어서 돌리려고 하면 굉장히 힘들다.
  - 그렇기 때문에 하나의 기능에 대해서도 상대적으로 과정이 적은 것에 대해서부터 구현해나가는 것이 좋다.
  - 예를 들면 인수테스트에서 비정상적인 시나리오에 대한 테스트가 상대적으로 스텝이 적다.

인수테스트는 어떤 경우는 단위테스트 같아보이고 어떤 경우는 API 테스트, E2E 테스트, 통합 테스트처럼 보일 떄도 있다.
- 인수 테스트는 테스트 의도에 따라 구현 방법이 달라진다!!
- 시나리오를 작성하고 검증하는 과정에서 사용자가 어떤 레벨까지 접근해서 사용하는지에 따라 달라질 수 있다는 것이다.

린 애자일 기법을 활용한 (인수) 테스트 주도 개발
- 인수 테스트의 개념은 테스트 의도에 따라 정해지는 것이지 테스트를 어떻게 구현하는지에 따라 정해지는 것이 아니다. 
- 유닛 레벨, 통합 레벨, 사용자 인터페이스 레벨에서 인수 테스트를 적용할 수 있다.
- 더 나아가, 인수 테스트를 유닛이나 컴포넌트가 의도한 동작을 하는지 확인하는 설계 검증 테스트로 사용할 수도 있다.
- 어떤 경우에서든 인수 테스트는 사용자에게 애플리케이션이 인도될 수 있는 지를 확인한다.

이번 특강에서 말하는 인수 테스트
- 백엔드 개발자가 단독적으로 적용해서 실천해볼 수 있는 범위.
- 고객은 프론트엔드 개발자 혹은 API 활용하는 사람을 대상으로 함
- API 접점에서 테스트하는 E2E 테스트 
- API의 request / response 정보 이외에 내부 정보는 최대한 가리는 블랙 박스 형식의 테스트 


- 인수 테스트는 블랙 박스 테스트의 성격을 가지고 있다. 
  - 클라이언트는 결과물의 내부 구현이나 사용된 기술을 기반으로 검증하기 보다는 표면적으로 확인할 수 있는 것으로 인수 테스트를 하기를 바란다.
  - 실제로 어플리케이션을 사용하는 상황의 시나리오를 바탕으로 요구사항을 작성한다.
  - 내부 구현이나 기술에 의존적이지 않은 블랙 박스 테스트

JsonPath를 사용하면 ResponseDto로 다시 만들지 않아도 바로 응답 메세지를 확인할 수 있다는 장점을 취할 수 있다.

인수테스트 격리
- DirtiesContext : 궁극적인 목적은 격리를 시켜주기 위함
  - 테스트를 돌려보면 하나의 테스트마다 스프링 컨테이너, 즉 스프링 컨텍스트가 새로 생성되고 있다.
  - 설정이 같으면 컨텍스트를 재사용한다.
    - 스프링 컨텍스트 상에서 관리되는 빈들의 상태가 있는데 이 상태가 테스트 메서드를 거치고 변경된다면 해당 컨텍스트는 오염되어 재사용할 수 없는 것으로 판단한다.
    - 예를 들어 테스트에서 @MockBean을 사용하게 되면 한 번이라도 메서드를 사용하게 되면 내부 값이 바뀌어 버리므로 컨텍스트를 새로 생성하게 된다.
  - @DirtiesContext를 활용하여 캐시 기능을 사용하지 않게 설정한다.
  - 매번 Context를 새로 구성하다보니 테스트 시간이 많이 걸리게 된다.
- 그래서 Datasource를 이용해 DB 테이블 명을 모두 가져와서 JdbcTemplate으로 모두 truncate, delete시켜줘서 dirtiesContext가 동작하지 않도록 하는 방법도 있다. (테스트 후 컨텍스트 초기화)

서비스 기획 (구체적인 ATDD 사이클)
- 원래 서비스를 기획할 때는 이 소프트웨어를 통해서 어떤 문제를 해결하고 싶은지를 판단해야 한다.
- 이 소프트웨어를 통해서 사용자에게 어떤 도움을 줄 수 있는지 판단하면 사용자 스토리가 나온다.
- 사용자 스토리가 나오면 이를 통해 인수 조건과 인수 테스트가 나오는 식으로 사이클이 돌아가게 된다.
- 일반적으로 개발자가 서비스를 기획하게 되면 기술지향적으로 설계하게 된다.
  - 간단한 기능으로 서비스를 만들어 문제를 해결할 수 있는데 어려운 기술을 공부해서 서비스를 만들어야겠다고 생각하는 경우가 많다.
  - 만약 엘라스틱 서치를 이용해야만 내가 원하는 기능을 제공할 수 있는 성능이 나온다고 했을 때 그 때 공부해서 적용하고 문제를 해결하는 것만이 기억에 남고 나의 경험이 된다.

인수 테스트 주도 개발은 어떻게 해야하나?
- 기술을 배우기 위해 경험을 하는 것은 의미가 없다. 경험을 하기 위한 도구로 사용해야한다.
- 인수 테스트 사이클을 반드시 정확하게 돌릴 필요는 없다.
  - 인수 조건 정의
  - 인수 테스트 작성
  - 기능 구현
  - 이런 수순으로 사이클을 돌려도 충분하다.

E2E 테스트와 인수 테스트 차이는 무엇인가?
- 테스트의 구분은 항상 용어가 아니라 검증하는 대상에 따라 구분해야 한다.
- E2E 테스트는 엔드포인트를 검증해야 한다.
- 인수 테스트는 요구사항(시나리오)대로 동작하는지를 검증한다.
- 형태가 같을 수 있으니 엄격하게 구분할 필요는 없다.

## 23.05.23
### 배포 관련 강의
- https://awsx100.signin.aws.amazon.com/console (해당 링크로 로그인하기)
  - 구글 계정 + 변경한 비밀번호로 로그인하기
- 보안자격증명 - 멀티 팩터 인증 설정 (2차인증)
- ssh -i key-hiiro.pem ubuntu@13.124.87.248










