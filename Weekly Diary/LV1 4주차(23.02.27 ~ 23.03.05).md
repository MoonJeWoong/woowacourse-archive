# 레벨 1 - 4주차 (23.02.27 ~ 23.03.05)

---

# 23.02.28

## 문자열, 블랙잭 미션
- String 생성 방법?
  - 일반적으로 new와 리터럴을 사용한다.
  - 생성자만 찾아봐도 생성 방법은 굉장히 많다.
- show bytecode를 인텔리제이에서 찾아 볼 수 있다.
- String에 intern이 왜있지? 
- 스트링 풀이 왜있지?
- GC가 뭐지? -> 왜 예전에는 스트링이 Gc 대상이 아니었지? -> 왜 지금은 gc 대상이지?
- 원래 스트링 + 연산을 수행하면 스트링빌더로 바꿔서 연산을 수행해줬는데 자바9 이후에는 StringConcatFactory.makeConcatWithconstants 으로 바뀌었다.
  - 그러면 왜 바뀌었을까?
  - 스트링 빌더는 동기화가 되고 스트링 버퍼는 동기화가 안된다고 보통 얘기한다.
  - 스트링 빌더는 객체이므로 매번 생성되고 나면 GC가 작동될 수 있다.
  - 그래서 static인 concatFactory로 대체되었고 내부적으로 buffer로 처리를 하고 스트링빌더가 생성되지 않는구나... -> 어느정도 차이가 있을까?
- 내가 사용하는 코드와 api가 어떻게 구현됐는지 어떤 배경에서 나왔는지, 어떻게 사용하는지 등 새로운 지식을 학습하는 방법을 고민해봤으면 좋겠다.
  (강의 다시보고 정리해보자 주말에...)

# 23.03.01 

## 테코톡 발표 준비


# 23.03.02

## 글쓰기 강의

- 글을 쓰는 행위는 나의 생각을 표현하는 일이다.
  - 생각하고 작성하고 고치는 등의 과정
  - 내가 쓴 글을 다른 사람이 봤을 때 쉽게 이해할 수 있어야 한다.
- 코드를 작성하는 과정과 글을 쓰는 과정은 크게 다르지 않다.
- 왜 글쓰기가 중요한가?
  - 자신의 생각과 감정을 자신의 손을 통해 문자로 정리하고 표현하는 방법
  - 글에는 쓴 사람의 생각과 감정이 담긴다.
  - 나의 생각들을 글로 써야 진정으로 내것이 된다.
  - 글로 표현하지 않는 생각과 감정은 결국 사라진다. (내가 지금 든 생각 / 감정이 정말 내 것인가?)
  - 지식이든 감정이든 다른 생각이든 단기 기억에 담겨있다가 사라지게 된다.
- 글을 쓰는 것이 두려운가?
  - 잘 써야겠다는 욕심을 버리자
  - 자신이 쓸 수 있는 수준에서 언제나 써보자
  - 글쓰기는 공부의 과정이지 결과로 생기는 것이 아니다.
  - 책을 많이 읽는다고 글쓰기 실력이 늘어나는가?
  - 글은 결국 많이 써봐야 더 잘쓰게 된다.
  - 공부를 하면서 글을 쓰는 과정이 같이 병행되어야 한다.
- 글을 쓰는 것이 두려운가?
  - 자기 암시
    - 남들은 내 글에 생각보다 관심이 없다.
    - 언젠간 글이 써지는 순간이 온다.
  - 습관의 힘을 활용하자.
    - 일정한 시간에 일정한 장소에서 글을 써보자.
- 글쓰기의 시작
  - 일단 한문장이라도 써놔라 시작이 반이다.
  - 어떤 내용을 쓸지 늘 고민하라.

- 학습목표
  - 각 레벨 별로 한 편의 글을 완성하도록 한다.
  - 한 편의 글에 자신의 생각과 감정을 논리적으로 담도록 한다.
  - 독자가 이해하기 쉬운 글을 작성한다.
- 글쓰기 규칙
  - 능동형 문장을 쓰도록 한다.
    - 글의 생동감을 살릴 수 있도록 한다.
    - 포비 캡틴의 강의가 진행되었다.
    - 포비 캡틴이 강의를 진행했다.

## 블랙잭 미션
- 추상클래스 / 인터페이스...?
- Enum 클래스에 대한 인터페이스
- Enum 클래스의 getter 구현...?
- 추상 클래스를 TDD 하는 방법...?

## 제네릭 미션
- 리스트와 같이 다양한 종류의 데이터를 관리하는 경우 데이터의 타입을 특정 타입으로 고정할 수 있다.
- 장점
  - 특정 타입으로 제한함으로써 타입 안정성을 제공한다.
  - 타입 체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.
- 제네릭
  - 리스트 사용시 형변환 문제 발견을 런타임에서 컴파일 타임으로 가져온다.


# 23.03.05

## 자바의 문자열 강의 재수강
- 문자와 문자열
  - 기본적으로 예전 언어에서는 문자열을 표현하기 위해 문자 배열을 사용했다. 하지만 자바에서는 문자열을 위한 클래스를 제공한다.
  - 문자열은 자바 프로그램이 실행되는 동안 가장 많이 생성되는 객체
  - 문자열은 문자 배열을 클래스화 한 것이다.
  - 그래서 문자열은 객체이지만 각각의 문자의 나열로 구성된다.
- String 생성 방법은?
  - String은 특별한 객체이다.
  - 일반적으로 생성할 때 new 연산자, 리터럴, StringBuilder, valueOf, char[] 등을 사용해 생성할 수 있다.
 - ~~~ java
   final String a = "a";
   final String b = new String("a");
   final String c = new String("a").intern(); // 새롭게 생성된 문자열 객체의 리터럴을 문자열 풀에서 찾아보고 있다면 해당하는 기존 객체를 반환하고 없다면 새롭게 생성된 객체가 문자열 풀에 추가된 이후 자신의 주소값을 반환
   ~~~
 - 레퍼런스
   - [String.intern() 개념](https://simple-ing.tistory.com/3)
   - [String.intern in native (어렵당...)](https://www.latera.kr/blog/2019-02-09-java-string-intern/)
   - [String 생성 방식 별 소요 시간 실험 결과](https://blog.ggaman.com/918)

 - 바이트 코드를 뜯어보며 해당 코드들의 동작 방식 차이를 알아보자
   - LDC는 JVM 명령어 set 중 하나로 아이템을 런타임 상수풀에 push 한다는 명령어이다.
     - [공식문서](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.ldc)
   - bipush는 즉시 바이트가 int 값으로 부호 확장된 이후 operand stack으로 push된다.
   - invokestatic 은 클래스의 static 메서드를 invoke한다.
   - 정수형 데이터에서 byte, short 범위에 해당하는 정수 리터럴들은 런타임 상수풀에 push되지 않는다.
     - short 범위를 벗어나는 정수 리터럴 값들이 사용될 경우에만 LDC 명령어를 통해 상수풀에 할당된다.
     - [레퍼런스](https://stackoverflow.com/questions/29875430/why-in-jvm-integer-is-stored-as-byte-and-short)
     - [byte,short,Integer가 precached된 이유?](https://stackoverflow.com/questions/20394116/java-why-is-constant-pool-maintained-only-for-string-values)
     - byte와 short는 미리 캐싱이 되어있기 때문에 바로 operand stack에 push된다.(bipush, sipush)
- chat GPT 센세에게 물어본 내용들 정리
  - constant pool
    - Constant pool은 Java 클래스 파일에서 상수를 저장하는 테이블입니다. 이 테이블에는 클래스의 이름, 상수 필드 및 메소드의 이름, 타입, 문자열 값 등이 저장됩니다. 
    - 예를 들어, 클래스의 static final 상수들은 이 constant pool에 저장됩니다. 이를 통해 클래스 파일에서 상수들을 빠르게 참조할 수 있습니다.
    -  Constant pool은 클래스 파일에서 상수를 저장하는 테이블입니다.
  - String pool
    - String pool은 Java에서 문자열 리터럴을 저장하는 특별한 영역입니다. 문자열 리터럴은 프로그램에서 동일한 문자열이 여러 번 사용될 경우 메모리를 절약하기 위해 하나의 인스턴스만을 유지합니다. 
    - 즉, String pool은 문자열 리터럴의 중복을 제거하여 메모리 사용을 최적화합니다.
    - String pool은 문자열 리터럴을 저장하는 특별한 영역입니다.
  - 자바 바이트 코드에서 bipush, sipush, LDC를 이용한 정수 저장 방식에는 어떤 차이가 있어?
    - 자바 바이트 코드에서 bipush, sipush, LDC는 모두 상수를 저장하는 데 사용되는 명령어입니다. 이들 명령어는 정수를 저장하는 데 사용됩니다. 
    - bipush는 1바이트 정수 상수를 스택에 직접 push하는 명령어입니다. 즉, -128에서 127까지의 값을 직접 스택에 push할 수 있습니다. bipush는 바이트 코드 크기를 줄일 수 있으며, 작은 정수 상수를 push하는 데 유용합니다. 
    - sipush는 2바이트 정수 상수를 스택에 직접 push하는 명령어입니다. 즉, -32768에서 32767까지의 값을 직접 스택에 push할 수 있습니다. bipush와 달리 더 큰 범위의 정수를 push할 수 있습니다. 
    - LDC는 상수 풀(constant pool)에서 정수 상수를 로드하여 스택에 push하는 명령어입니다. 상수 풀에 저장된 값은 4바이트 또는 8바이트 정수일 수 있습니다. LDC는 모든 정수 상수를 push할 수 있습니다. 또한, LDC는 문자열, 클래스, 인터페이스 등 다양한 상수 타입을 로드할 수 있습니다. 
    - 따라서, bipush는 작은 정수 상수를 push할 때 사용하고, sipush는 더 큰 범위의 정수 상수를 push할 때 사용합니다. LDC는 모든 정수 상수를 push할 수 있으며, 다른 상수 타입도 로드할 수 있습니다.

  - 자바 Integer pool에는 어떤 값이 저장돼?
    - 자바 Integer pool은 자주 사용되는 int 값들을 캐시하는 영역입니다. 이를 통해 메모리를 절약하고, 같은 값을 가진 Integer 객체를 공유하여 성능을 개선합니다. 
    - Integer pool에는 -128부터 127까지의 int 값들이 저장됩니다. 이 범위 내에서 Integer.valueOf() 메서드를 사용하여 Integer 객체를 생성하면, 이 값들에 대해서는 이미 생성된 객체를 반환합니다.
    - 그 외 리터럴은 Integer pool에 저장되지 않습니다. 이 값은 해당 코드가 실행될 때 메모리의 스택 영역에 임시적으로 저장됩니다. 따라서 동일한 값을 가지는 Integer 객체를 생성하려면 Integer.valueOf(4000)을 사용해야 합니다
    - [레퍼런스](https://escapefromcoding.tistory.com/127)

  - 자바에서 string pool과 integer pool 작동 방식 차이는 뭐야?
    - 자바에서 String Pool과 Integer Pool은 각각 다른 방식으로 작동합니다. 
    - String Pool은 String 객체를 생성할 때 생성자에 전달된 문자열 값이 이미 String Pool에 존재하는 경우, 새로운 객체를 생성하지 않고 기존 객체의 참조를 반환합니다. 즉, 문자열 리터럴이 이미 String Pool에 존재하는 경우, 해당 리터럴을 참조하는 String 객체를 생성하지 않고, 이미 존재하는 String 객체를 참조하게 됩니다. 
    - Integer Pool은 Integer 객체를 생성할 때, 생성자에 전달된 값이 -128에서 127사이의 정수인 경우, 새로운 객체를 생성하지 않고 기존 객체의 참조를 반환합니다. 이는 Integer 객체의 생성 비용을 줄이고, 성능 향상을 도모하기 위한 것입니다. 
    - 따라서, String Pool과 Integer Pool의 작동 방식은 유사하지만, 사용되는 데이터 타입과 값의 범위 등에 따라 차이가 있습니다.
  - Integer pool에는 String Pool 과 다르게 새로운 값을 추가할 수 없는거네?
    - 네, 맞습니다. Integer pool에는 런타임 시점에 값을 추가하거나 수정할 수 없습니다. Integer pool은 자바에서 미리 정의된 일부 정수 값만 저장할 수 있습니다. 
    - 따라서 Integer pool에 존재하지 않는 int 값은 항상 새로운 객체로 생성됩니다.

  - 자바7 ~ 8 사이에서 변경된 메모리 영역에 관련해서 알아봐야 할 듯 하다.
    - [레퍼런스1](https://8iggy.tistory.com/230)
    - [레퍼런스2](https://8iggy.tistory.com/229)
    - [레퍼런스3](https://www.nakjunizm.com/2017/07/25/String_Pool/)

- 문자열에서 intern 메서드가 왜 있지? -> 스트링풀이 왜 있지? -> 없으면 어떻게 되지?
  - gc가 뭐지? -> 왜 예전에는 String이 gc 대상이 아니었지?

- 자바에서 문자열 덧셈 연산에서 java 9 이전까지는 StringBuilder를 사용해 진행됐다면, 이후부터는 StringConcatFactory.makeConcatWithConstants를 사용한다.
  - 왜 최적화를 진행했을까?
  - StringBuilder로 했는데 왜 이젠 아니지? -> StringBuilder가 매번 생성 되는구나 -> GC가 돌 수 있구나(성능이슈)
  - 내부적으로 buffer로 처리하고 StringBuilder가 생성되지 않는구나 -> 어느정도 차이가 있을까?
  - 동시성 이슈를 해결하려고 했다는 것 같은데... -> 뭘 해결하려 한거지? -> StringBuilder는 가변상태를 만든다. -> 그러면 StringBuffer를 사용하면 되는거 아닌가?
    - [레퍼런스](https://12bme.tistory.com/42)






















