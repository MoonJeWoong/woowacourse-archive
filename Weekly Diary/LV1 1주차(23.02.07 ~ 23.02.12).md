# 레벨 1 - 1주차 (23.02.07 ~ 23.02.12)

---

## 23.02.07 화요일
# 우테코 OT
코스 전반적인 소개, 코치 소개, 온보딩 미션 소개 등등
밥 먹고 와서 4시반까지는 각 과정별로 모여서 진행

캡틴 포비의 우테코 소개
비전목표
소프트웨어 교육을 통해 사람들에게 변화를 만든다.
소프트웨어는 도구에 불과, 도구를 통해 사람들이 변화하는 것이 주됨.
학습, 성장하는 것에 대한 즐거움을 느끼고 변화할 수 있다면 좋겠다.

교육목표1. 일반 사용자용 소프트웨어 개발회사의 1년 경력에 준하는, 웹 백엔드/프론트엔드/ 모바일 안드로이드 역량을 갖춘 개발자.
교육목표2. 개발 프로세스를 지키면서 프로젝트를 진행하고 협업 경험을 가진 개발자.
교육목표3. 자기 주도적으로 학습하고, 지속적으로 성장할 역량이 있는 개발자.

## 과정 소개
우테코가 오프라인을 강제하는 이유 :
사람의 의지력을 신뢰하지 않는다. 온라인으로 즉 개인의 의지만으로 하루 8시간 학습을 지속하는 것은 굉장히 힘든 일이다.
그렇기 떄문에 의지보다 환경이 더 중요하다. 몰입할 수 있는 환경을 조성한다면 누구나 성장할 수 있다.

# 교육 진행 방식
- 미션 수행
- 오프라인 강의 (라이브 강의)
- 피드백 / 코드리뷰 (1대1 코드리뷰 추가)

과제를 먼저 수행하고 그에 대한 피드백을 나중에 주는 것이 학습효과가 가장 좋다고 믿는다.

프로그래밍 코스
- 레벨 1~5
- 각 레벨은 8~9주로 구성 (레벨 5는 4주로 구성)
- 각 레벨 완료후 1주 혹은 2주 방학

레벨 1은 프로그래밍 언어 하나에 대해 깊게 학습하는 기간, 프리코스와 비슷하게 진행할 것
레벨 2부터는 스프링 웹 프레임워크를 활용하여 직접 개발하는 경험을 하게 될 것
레벨 3는 팀 프로젝트를 진행한다.
레벨 4 기간동안 유지보수 진행.
레벨 5 취준기간, 리쿠르팅 데이, 우형 등 회사 채용 프로세스 진행

프로그래밍 기관이지만 소프트 스킬을 중시한다. 소프트 스킬은 글쓰기와 말하기라고 생각하고 레벨 별로 A4 용지 1장 분량의 글을 쓰고 피드백까지 완료해야한다.
최근 sns 등의 영향으로 글을 점점 짧게 쓰게되는 경향이 있다. 그래서 기본적으로 장문을 작성하는 연습을 주로 한다.
우아한 테크 채널에 테코톡을 10분 분량의 발표를 진행해야 한다.
레벨 인터뷰 : 스스로 각 레벨을 잘 진행했는지 체크해볼 수 있는 기회

레벨 1 3월 31일 ~ 4월 10일 방학식
팀 단위로 몇 주 간격으로 캠퍼스를 계속 바꿔가며 교육을 진행하게 될 것.

# 생활 가이드
시간 약속 지키는 것은 기본
송파구에서 일을 더 잘하는 11가지 방법
월요일 1~6시, 화~금 10~6시 진행

출결
전체 과정 중 3번 이상 무단 결석 시 퇴소!
경조사, 병가 등 결석 및 조퇴가 불가피한 경우 반드시 사전 공유!
예비군훈련 등은 미리 코치에게 사전에 얘기하고 대처하도록 한다.

출입증
출입통제 시스템에 출입증 태그 및 해제 후 출입
출입증 항시 소지! (파손 및 분실 시 10000원 지불)

8시 ~ 11시 까지 이용 가능, 11시 전에는 회관에서 나가야 한다!!

우테코 교육생들 뿐만 아니라 교육 운영진을 포함한 우형 직원들 또한 함께 사용하는 공간임을 명심!

# 온보딩 미션 소개
팀을 이뤄 연극을 해야한다.
연극을 하는 이유 : 아이스 브레이킹, 우테코에서 처음 맞는 팀 프로젝트, 우테코가 다루는 것들에 대한 이해도 증진, 소프트 스킬 증진, 창의적 아이디어 발상
여러가지 연극에 대한 요구사항을 제시할 것이고 이를 충족시키기 위해 노력해야 할것.
프로그래밍과 관련된 주제를 정해 연극을 진행
주제를 잡고 어떤 형식으로 표현할지 고민하고

예시주제 : 깃은 어떻게 동작하는가, 미리보는 우테코 생활, 3년후 나는 어떤 개발자?

최대 6명이 한팀, 팀당 최소 4분~최대 5분까지 진행
5분이 지나면 종을 치고 무대에 모두가 나올 수 있게 역할을 부여해야 한다.
기획, 연출, 작사, 디제이, 게스트, 내레이션, 배우 등을 맡을 수 있다.
사람들의 기억에 남을 유행어를 만들고 사용한다.

2월 8일 ~ 13일 월요일 오전 10시 매일 데일리 미팅
2월 8일 오후 6시 주제 제출
2월 13일 오후 2시 연극 진행
5시 연극 회고 진행

# 데일리 미팅
하루를 시작할 때 20분 정도 데일리 미팅 진행
하루를 시작하는 본인의 현재 감정 상태 공유
어제 학습한 내용, 오늘 계획하고 있는 내용, 어제 학습하면서 어려웠던 점이나 깨달은 점.

조원 중 한 명이 데일리 미팅 퍼실리테이터(진행자) 역할
현재 조원들의 상태에 따라 가장 필요한 행동을 해라. 맹목적이고, 무의미한 데일리 미팅을 지양한다.

# 회고
학습도 애자일하게 학습을 할 수 있다면 어떨까, 빠르게 피드백을 얻어 학습의 방향을 재설정한다.
즉흥 연기 - 본인의 업무 역량을 증진하는데 도움이 된다.


# 온보딩 조
공통 교육 - 2023의 팀 프로젝트 - 연극 에서 확인할 수 있다.



# 오후 교육
첫 주차 미션은 자동차 경주 미션
프리코스 과제 미션보다 더 쉬울 것이다.
첫 주차는 온 보딩 기간이기 때문에 우테코 자체에 익숙해지는 시간으로 보내주면 좋겠다.
우테코 싸이클에 익숙해진다 + 연극에 집중하라는 의미
(인간 디도스 공격 ㅋㅋㅋㅋ)

학습목표
도메인에 집중할 수 있는 환경에서 자바 학습에 좀 더 집중하는 과정이다. 데이터베이스를 활용한 콘솔 애플리케이션을 개발하는 경험을 한다.
추구하는 최종 목표는 프로그래밍이 얼마나 재미있는 활동인지, 앞으로 어떻게 개발자로서 살아갈 것인지 자신만의 프로그래밍 방법 또한 고민해보는 단계이다.

리뷰요청 주기 - 리뷰어에 따라 매일 피드백을 해주신다면 매일 해도 된다.
미션이나 리뷰 내용은 블로그에 작성하기 전에 리뷰어 분에게 여쭤보고 포스팅하도록 하자.
미션 관련된 것은 포스팅해도 괜찮다.

# 페어 프로그래밍
드라이버는 코드를 작성하며 말로 설명하며 코드를 작성한다.
네비게이터는 드라이버의 의견을 듣고 자신의 의견을 제시하며 진행해야 한다.
절대 쉬운 작업은 아닐 것이다. 단 두 사람이 의견을 맞춰서 진행하는 것 조차도 힘들구나를 느끼게 될 것.
하다보면 자신만의 노하우가 쌓일 것이다. 페어 프로그래밍도 하나의 기술이기 때문에 스킬 연습을 해줘야 한다.

왜 페어 프로그래밍을 하는가? => 직접 해보면 더 의문이 들것이다. 코드리뷰를 통해 얻어야 할 것들을 페어 프로그래밍 함으로써 자연스럽게 얻게 된다.
사람은 본질적으로 무언가를 만드는데 매몰되도록 설계되어 있다. 그래서 페어를 통해 이를 방지하고 좁은 시야를 방지하기 위함이다.

페어간에 역량 차가 많이 난다고 걱정할 수 도 있는데 페어 프로그래밍을 진행하면서 지금 내 생각이 상대방의 생각과 결이 맞는지 항상 생각해야 한다.
마틴 파울러 컴퓨터가 이해하는 코드는 누구나 짤 수 있지만 우리는 사람이 이해할 수 있는 코드를 구현해야 한다.
코드를 구현하기 전에 말로서 페어에게 나의 생각을 이해시킬 수 있어야 함.

교체 주기는 페어 간 합의를 통해 이루어지게 된다.
10~15분 이상을 넘기지 않도록 한다. 최대한 자주 바꿔주며 한 사람에게 매몰되지 않도록 한다.

# 목적의식 있는 연습
아마추어와 프로의 결정적 차이 - **목적의식 있는 연습**에 얼마나 많은 시간을 투자했는가?

의식적인 연습의 7가지 원칙
1. 효과적인 훈령기법이 수립되어 있는 기술 연마
2. 개인의 컴포트 존을 벗어난 지점에서 진행, 자신의 현재 능력을 살짝 넘어가는 작업을 지속적으로 시도
    - 자신이 조금이라도 성장할 수 있는 부분을 스스로 찾아서 계속 적용해보려 하는 노력이 반드시 필요하다!!
3. 명확하고 구체적인 목표를 가지고 진행.
4. 신중하고 계획적이어야 한다. 개인이 온전히 집중하고 '의식적'으로 행동할 것을 요구
5. 피드백과 피드백에 따른 행동 변경을 수반
6. LMS 페이지 참고...

만약 요구사항 자체가 어렵지 않다면 자체적으로 노력해서 난이도를 조절해야 한다.

# 객체지향 생활 체조 원칙
- 규칙을 지키려다 보면 아무리 생각해도 각이 안보이는 부분들이 있을 것이다. 끝까지 계속 고민하는 것이 중요하다.
- 처음 부터 모든 것을 지키는 것은 굉장히 어려울 것이기 때문에 해당 단계에서 요구하는 수준만큼 준수하면 된다.

# 테스트
- 테스트 코드는 스스로에게 줄 수 있는 가장 빠른 피드백이다.



# 소프트웨어 장인으로 가는 길
- 평생을 학습하며 성장하기 위해 가장 중요한 것은?

최소한의 제약 안에서 자유롭게 행동하리라는 믿음으로 이루어진다 우테코는.

어떤 개발자가 되고 싶은가? - 프로그래밍 역량에 대해서 생각을 바꿔보자
개발자가 해야 하는 많은 일들 중 하나일 뿐이라고 생각하는 자세
프로그래밍 역량 외에도 테스트, 배포 자동화, 고객/구성원들과 관계 유지 등...

레거시 코드에 대한 생각 변화
- 레거시 코드를 바라볼 때 짜증나고 고통스러운 일로 바라보기 보다는 재미있고 도전적인 문제로 바라보는 자세로 바꿔보자.

무리한 일정과 업무 요청에 대한 생각의 변화
- 무리한 일정과 변경 요구에 무조건적인 '예'보다는 아니오라는 말을 하고 대안을 제시하는 자세로 바꾸자
  실제 상황에서는 설득하는 것보다 그냥 개발하는게 더 빠를 수 있다. 그러나 포기하지 않아야 한다.

자기 성장에 대한 생각의 변화
- 회사나 선배 개발자가 성장 시켜주기를 바라기 보다

성장에 대한 생각의 변화
- 나 혼자 성장하는 것에만 관심을 가지기보다, 후배들을 키우고, 커뮤니티를 통해 같이 학습하려는 자세를 함양해야 한다.

고객(또는 고용주)을 바라보는 생각의 변화
고객 또는 고용주를 적대적 관계로 보기보단 좋은 결과물을 만들어 프로젝트를 성공시킬 생산적인 동반자적 관계로 바라보는 자세가 필요하다.

우리가 소프트웨어 장인이 되어야 하는 이유
=> 우리가 더 행복하고, 자유롭고 즐겁게 일하기 위함이다
우리가 특정 회사, 고용주에게 종속되지 않고 인간으로서 존엄성을 유지하며 살아가기 위함이다.

책에서 제시한 내용만이 정답만은 아니다. 본인만의 기준을 꼭 세워보길 추천한다!!

# 추천도서
- 책 목록 중 좋은 코드, 나쁜 코드는 레벨 1 끝나고 방학때쯤에 읽어보는 것을 추천한다.
- SQL 첫걸음은 레벨1 마지막에 사용하는 부분이 있으므로 참고하면 좋을 것이다.
-

기능 설계 만들어오기!! + 페어 프로그래밍 하면서 해보고 싶은 것 생각해보기

# KDT 안내
- 출결만 신경쓰면 지원금 다 받아갈 수 있다.
- 2월 8일부터 출결 시작하면 된다.
- 확정 신고 2월 13일 진행 예정
- 기본 훈련 장려금 월 11만 6천원 + KDT 특별 훈련수당 (월 20만원 한도 내 출석 일수 * 1만원)
- 무조건 훈련 출석률 80% 이상
- 2월 8일 ~3월 7일 / 3월 8일 ~ 4월 7일 한 달 단위

출결방식
입실 / 퇴실 처리만 하면된다.
월요일 13시 ~ 18시
화~금 10시 ~ 18시

경조사, 예비군 등 불가피하게 출석하기 힘든 경우 미리 백엔드는 리사에게 얘기하자!
직권 입력은 사유 발생일로부터 하루 내로만 가능하다.

9시 45분에 zoom에 접속해서 KDT관련해서 출결 같이 진행해볼테니 일찍와라

---

## 23.02.08 수요일
# # 23.02.08
페어프로그래밍
페어 프로그래밍도 기술이기 떄문에 어떻게 하면 더 잘할 수 있을지 계속 고민해보면 좋을 것 같다.

오늘 강의 내용
- 우테코에 임하는 자세
- 단위테스트 코드품질

## 우테코에 임하는 자세
- 목표 설정하기
    - 우테코에서 얻고자 하는 본인 만의 목표가 있을 것이다. 각자가 생각하는 목표가 다르기 때문에 자연스럽게 그 목표를 이루는 방법또한 다를것이다.
    - 그러면 어떻게 하면 **서로 다른 목표를 가진 사람들이 모여있는 한 공간**에서 내 목표를 이룰 수 있을까에 대한 의문을 해결해야 한다.
    - 우테코는 목표를 이루는 법을 알려주는 것이 아니라 **목표를 달성할 수 있는 환경**을 제공해줄 뿐이다.
    - 코치들에게 뭔가를 질문하면 코치들은 거의 다시 질문을 던질 것이다. (나는 개인적으로 이것이 질문에 대한 **답을 찾아가기 위한 필수적인 과정**이라고 생각하고 코치님들이 이를 알려주기 위해 물어보는 것이라 생각한다.)
    - **그래서 자신의 목표를 위해서 어떤 환경이 더 필요한지 생각해보고 조성하는 것이 중요하다!**

## Junit 학습하기
- 얼마나 작게 테스트를 해야 하는가?
    - 테스트를 작성하는 이유? => 내가 작성한 코드에 대해 가장 빠르게 피드백을 받아보기 위함이다.
    - 메서드 작성을 작게 해야하는 이유?
      - (나의 의견) 메서드 단위가 작아야지만 단위 테스트를 진행하는 범위도 작아질 수 있기 때문이다.
        - 단위 테스트를 너무 큰 범위에 대해 한번에 적용하려고 하면 테스트 코드 작성 자체가 많이 어려워지고 이해하기 힘들어 질 수 있다고 생각한다.
        - 작게 기능을 쪼갤수록 해당 기능의 로직을 이해하기 쉬워진다.
      - 작다고 생각하는 기준은 사람마다 다르다 => 페어와 잘 맞춰가보기

- display name 과 테스트 메소드 자체 네이밍 모두 중요한가?
  - 테스트 메소드 네이밍을 한글로 하지 못하는 경우가 생길 수 있다.(외국인과의 협업 가능성)
  - @DisplayName 어노테이션에는 이모지나 특수문자 등의 사용이 자유로워 메소드 네이밍보다 가독성을 높이기가 훨씬 수월하다.
  - @Nested 어노테이션으로 테스트 클래스 그룹핑을 하고자 할 때 클래스도 작성해야 하는데 @DisplayName을 통해 클래스 네이밍에도 가독성을 쉽게 향상 시킬 수 있다.
  - 저는 반대 의견은 아니지만 @DisplayName은 메서드 단위가 아닌 클래스 단위에도 사용할 수 있어서 어떤 클래스 테스트인지 알 수도 있다고 생각합니다
  - Display name 어노테이션은 누락되어도 실행 오류가 안나서 누락될 경우 메소드 이름을 확인해야 할 것 같아요
  - 디스플레이 닉네임에 다 넣지 못한 정보를 좀 더 추가하는 용도로 메서드 명을 사용하는 것은 어떤가요?

- 왜 테스트를 main 메소드를 사용해 진행하면 안될까?
    - 많은 단점들이 존재
        - 프로덕션 코드에 테스트 코드가 포함된다.
        - 규모가 커지면 코드의 길이가 감당하기 힘들어진다.

- 테스트 케이스를 늘리는게 능사가 아니다.
    - **실패하는 테스트를 먼저 작성합니다.**
      - 그리고 이를 통과할 수 있도록 비즈니스 로직을 구현한다. (TDD)
    - 경계값을 잘 찾아야 한다.
        - 검증하고자 하는 로직이 무엇인가?
        - 경계값 케이스들이 어떤 상황에서 문제를 일으킬 수 있을지 생각해본다. => 단위 테스트가 된다.
        - **더 자세하게 케이스를 나눠서 더 작은 단위 테스트를 진행한다.**
        - 개인적인 사고에 의존하지 않고 경계값을 더 잘 찾는 방법이 있을까요?
            - Integer.max 와 같은 숫자들을 테스트 케이스로 넣어본다.
            - 로또의 경우 45 46번 등...
    - 모든 경우를 다 테스트하는 것은 불가능하다.
        - 그래서 나는 어디선까지 테스트 하겠다라는 기준 또한 다르기 때문에 기준선을 잘 정해야한다.
        - **네오의 기준선은 내가 불안하지 않고 내 코드에 확신이 생기는 정도라고 한다.**
    - 단위 테스트를 작성하는 이유 중 하는 **분할 정복의 의미**도 존재한다.
        - 즉 작게 기능을 구현하면 **문제가 간단해질 확률이 높아진다.**
- 코드를 작성하다가 아 이 코드 중복되서 줄이고 싶은데 와 같은 의문이 든다면
    - 누군가 같은 생각을 하고 뭔가를 만들어 둔게 있지 않을까? 하고 찾아본다.
    - 없다면 그냥 놔둔다 (내가 생각을 바꾼다.)
    - 불편하다면 내가 만들어 쓴다.
- 테스트 코드를 짜기 위해 프로덕션 코드를 수정하는 것 또한 테스트 코드 작성의 장점이다.
- 메소드 실행 순서
    - 중간에 테스트 메소드들이 실행되는 순서가 랜덤이다?? => 직접 실행해보기!!!

- 하마드 : 저는 메소드를 분리 하면서 private으로 선언한 메소드를 테스트를 위해 public으로 바꾸곤 했는데, 테스트를 위해 public을 선언했다는 점이 아쉬웠습니다. 이것도 선택의 영역일까요?
    - public 메서드를 통해서 테스트를 진행해본다.
    - 의존관계가 많거나 테스트가 힘들다 => 그러면 따로 분리되어야 하지 않을까?
    - private을 테스트를 위해 public으로 바꾸는 것은 많이 아쉬운 부분이 맞다
      - 해결방법은 각자 찾아보도록 하자.


강의 자료 밑에 답해보기 질문들을 스스로 생각해보기! => 나중에 코치님들이 물어보신다.
다른 크루들에게도 붙잡고 물어보기!

노션 혹은 깃헙 레포에 정리해보자!


## 코드 품질
- 코드의 품질을 위해 단위 테스트를 작성한다.
- 코드의 가독성과 심미성은 다른 범주이다.
    - 가독성은 읽고 이해하기 쉬운 코드이고 심미성은 딱 봤을 때 보기 좋은 코드이다.
- 서비스는 1차 완성 이후가 진짜 시작이다.
- 미션을 진행하다 의문점이 생기면 다시 돌아와서 읽어볼 수 있도록 하자.
- 너무 많은 것을 시도하려고 하지는 말자
- **어떤 부분을 성장시키기 위해 이 미션을 진행하는가에 대해 정리하고 README에 정리한 후 시작한다.**
    - 너무 많이 적용해보려고 하다보면 오히려 적게 얻어가는 경우가 많다.
    - 각자 상황을 고려하여 최적의 코드를 작성하는 것이 훌륭한 프로그래머이다.



---
## 23.02.09 목요일

- 아코랑 원격 저장소 바꿔서 push해보는 연습해보기 (6시 마감이니까 5시에는 마무리하고 PR 링크 올리는 것 목표)
- 일급 컬렉션을 사용하는 것이 옳은 선택인지 고민해보기
  - https://limdingdong.tistory.com/14
  - https://github.com/orgs/woowacourse-precourse/discussions/1177
  - https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/
  - isMovable의 주체는 생각해보면 Car인데 굳이 RacingGame에 구현할 필요가 있을까?
    - Car 클래스 내부에 isMovable을 구현하고 인스턴스 변수 position을 변화시킬 수 있도록 하면 어떨까
    - Cars 클래스는 MoveEachCar 메소드를 구현하여 내부 모든 자동차를 한 번씩 움직인다.
      - Cars 객체에 저장된 모든 자동차의 현재 위치를 숫자 리스트로 반환하는 메소드 작성.
      - Cars 객체에 저장된 모든 자동차들 중에서 가장 큰 position 값을 구하는 메소드 작성.
      - Cars 객체에 저장된 모든 자동차들 중에서 특정 position에 위치하는 모든 자동차 이름을 구하는 메소드 작성.
    - 그렴 RacingGame에서는...
      - round를 받아서 검증하고 인스턴스 변수로 저장
      - List<String>을 RacingGame 생성자 인자로 같이 받아서 내부에서 Cars를 생성
      - 이후 round 수만큼 반복문을 돌면서 Cars.MoveEachCar 메소드 실행
      - 모든 round 수행 후 Cars 객체로부터 자동차들의 위치 결과 값을 반환 받는 메소드 실행하여 controller로 반환.

<br/><br/>

일급 컬렉션을 사용하는데 getter 메소드가 남발된다면... 해당 getter 메소드가 필요한 기능이 일급 컬렉션 내부로 이관되어야 하지는 않는지 생각해봐야 한다.
- racingcar 미션을 진행하는 중 게임을 진행하는 기능을 수행하는 RaceGame 클래스에서 한 라운드 게임을 진행하는 메소드가 있었다. 
- 이를 위해서는 cars 일급 컬렉션 클래스에서 element인 car 인스턴스들을 외부에 getter로 넘겨주어야만 했다.
- 하지만 '한 라운드 게임을 진행하는 기능'을 '모든 자동차를 한 번씩 전진 시도를 하는 기능'으로 기능 명세를 수정하고 Cars 클래스 내부로 이관하였다.
- 그 결과 Cars 클래스 외부로 Car 인스턴스 값들을 내보낼 필요가 없어져서 getter 사용을 피할 수 있었다.

<br/><br/>

- 페어 프로그래밍 중 scanner관련 이슈
- https://nongue.tistory.com/152

<br/><br/>

- 네오가 데일리 미팅 때 @DisplayName에 대해 얘기해준 사항
  - 왜 Junit4에서는 존재하지 않던 @DisplayName이 Junit5로 넘어오면서 새로 추가되었을까?
  - Junit4를 제작했을 당시에는 DisplayName이 필요가 없었을까? 왜 구현하지 않았었을까?
    => Junit4 와 Junit5 차이를 알아보자!

---

# 23.02.10 금요일

## 포비의 전달사항
다음주 부터는 매주 금요일마다 포수타 진행 예정
우리 인생에 있어서 정말 중요한 시간이기 때문에 출석에 대한 압박이 있다.
지하철 연착 등의 사유로 인해 지각할 것 같다면 미리 연락을 한다면 참작을 해준다.
몸이 아픈 경우에도 진단서 끊어오면 되니까 그런 부분은 너무 무리하지 말라.
생활비 관련해서 문의
국민취업지원제도 일부 생활비 지원이 가능하다
3월부터는 생활비 지원을 위한 계약서를 쓰게 될 것이다. 한달마다 50만원 생활비 지원 (소득으로 잡힌다.)
KDT 1달 채우면 30만원 정도 지원금 나온다.


## 자동차 경주 피드백
네오가 드라이버가 되고 우리가 네비게이터 처럼 수업을 진행
(일단 요구사항을 보면서 돌아가는 코드를 바로바로 작성하고 후에 리팩토링하면서 생각하는 시간을 가지도록 노력해보자)

처음엔 요구사항 기능목록 작성

주어진 요구사항을 그대로 쓰는게 아니라 나의 언어로 다시 재정리해본다.
설계를 할떄 많은 것을 고민하는 것은 좋지만 너무 많으면 시간이 너무 소요될 수 있으므로 우선순위를 잘 정해서 넘어갈 수 있어야 한다.
기능 목록 작성에 추후 고려사항을 만들어서 그 때 그 때 생각나는 것들을 정리해두면 좋을 것 같다.

기능목록 작성 완료 후 핵심 비즈니스 로직으로 판단되는 부분부터 구현하기 시작한다.

만약 기능 구현 -> 테스트 과정으로 개발을 진행하다 리팩터링 할 것이 생각난다면 이는 바로 고치려 하지말고 따로 정리해두고 완성 이후에 적용해보려고 노력해보자.
ToDo 주석을 활용할 수 있다. => 검색해보기

테스트를 하다보면 랜덤한 값 때문에 테스트 할 수 없다는 생각이 들게 된다.
랜덤 값을 그러면 외부에서 매개변수로 넣어주는 것은 어떨까? 라는 생각을 해본다.
기존코드는 놔두고 기능을 수정한 새로운 메소드를 추가해서 작성한 다음 완료되면 이전 것을 삭제하는 방식으로 진행하자.

메소드의 매개변수를 작성할 때 외부에서 넘어오는 변수가 어떤 의미의 변수인지 알 수 있도록 네이밍을 신경 쓰는것이 좋다.

커밋을 하는 기준은 상황에 따라 선택하는 것이 좋다.
상황이 여유롭다면 메소드를 구현 직후, 기능 수정한 메서드를 새로 구현한 후, 리팩터링한 후 모두 커밋을 남겨둘 수 있다.
없다면 위 사항 모두 한 커밋으로 남긴다.

설정 - gradle - test 환경을 인텔리제이로 바꾸면 어떤 테스트가 통과되었는지 조회가 가능하다.

테스트 코드에서 예외상황을 던지는 것을 테스트해야 할 때
글렌 - assertThatCode, doesNotThrowAnyException 메서드를 사용하는건 어떻게 생각하시나요?

예외 발생시 던지는 메세지를 확인하는 테스트로서 타입과 발생 메세지를 같이 확인할 수 있다. (.hasMessage)
뭔가 모르는게 발생했을 떄 바로 구글링하지말고 자동완성기능을 통해 코드를 작성해서 어떻게 동작하는지 확인해보고 찾아보는 습관을 들이자.
사용한 메소드의 구현 파일을 들어가서 찾아보는 것이 좋다.

ToString을 구현하면 테스트 이후 에러 메세지가 뭔지 모르는 내용으로 출력된다 싶을 때 도움이 될 수 있다.=> 검색해보고 사용해보자.

테스트를 위해 생성자를 추가하는 등의 행위를 할 때 도메인적 관점에서 정말 테스트만을 위한 코드인가라고 생각해보는 것이 좋다.
이것은 개인의 선택인 부분이 많다.(무조건 지양하는 것은 피해보도록 하자.)

객체 내부에서 외부로 데이터를 반환해줘야 할때 도메인 관점으로 내부 클래스를 정의해서 거기에 담아서 넘겨주는 것도 한 방법이다.
외부에서 인자로 객체를 받을 때는 내부적으로 보호하기 위해 새로 복사해서 저장하는 것이 좋다.

여우 : 어떤어떤 이유로 이 move() 메소드는 테스트하지 않습니다’ 라는 내용을 어딘가에 적어두면 동료분들이 보고 이해할 수 있을 것 같은데 어디에 적어두면 좋을까요? :0
=> RacingGame 클래스에서 구현된 move() 메소드는 car의 move() 메소드를 이용하는 방식이다. 그런데 이미 car의 move() 메소드를 단위 테스트 완료한 상황이라면 굳이 테스트하기 애매한 RacingGame의 move() 메소드를 그냥 놔두는 것도 하나의 방법이다.
=> 저는 개인적으로 테스트 클래스에 명시를 해주는 편이 좋다고 생각이 들어요. 도메인 로직 자체에 대한 설명이 아니라 테스트 코드 미작성의 이유이기 때문에 해당 내용을 읽는 사람이 테스트 코드를 생각하며 볼 때 읽을 수 있도록 하는 것이 제일 효과적일 것 같습니다.

여우 : 
테스트 클래스에 주석으로 작성할 수도 있고,
~~~
// Car 객체의 move()메소드를 단순위임한 메소드이므로, Cars 의 해당 메소드는 따로 테스트하지 않습니다.
~~~
코드로 작성하고자 한다면 move 메소드를 테스트하는 빈 테스트케이스 메소드를 하나 선언한 후에, @Disabled 어노테이션으로 실제로 동작하지 않게 만들면서 그 이유를 @Disabled의 인자에 명시해두면 통일성있고 편하지 않을까 생각해요.
~~~
@Test
@DisplayName("move 메소드 테스트")
@Disabled("Car 객체의 move()메소드를 단순위임한 메소드이므로, Cars 의 해당 메소드는 따로 테스트하지 않습니다.")
void moveTest() {}
~~~



indent를 분리하기 위해 메소드를 분리하는데 매개변수가 많아서 슬프다면 클래스를 분리하는 것을 고민한다.
=> 이 부분은 어떻게 분리할 수 있다는 것일지 고민해보자..
=> 스플릿과 얘기하며 내린 결론 : 해당 기능을 수행하는 코드 부분을 다른 클래스로 분리한다. 이후 외부에서 매개변수로 주입해서 사용하는 방식으로 분리하는 방법이라고 결론을 내림.


질문 스레드 정리해보기


## 개인적으로 고쳐보고자 생각이 드는 부분
- 왜 코드 파일의 마지막 줄을 비워놔야 할까???

## 제이온 STEP1 피드백
- 도메인이 View를 알게 되면 어떤 단점이 생기게 될까? (도메인이 view를 의존한다 = 도메인 내에서 view에 해당하는 코드가 사용된다.)
  - 단순히 출력을 위한 로직이지만 도메인에 위치하게 된다면 처음 코드를 읽는 사람으로 하여금 "이 부분이 왜 도메인 로직일까?" 라고 생각을 하게 될 소지가 생기게 된다는 것이 단점이라고 생각이 든다.
  - 만약 view가 model에게 알려지게 된다면 이후에 model에서 로직이 수정되어야 할 때 model만 수정해야 하는 것이 아니라 view까지 수정해야 하는 강한 의존성이 생겨버리게 되는 것이 단점이라고 생각된다.

- 단순히 this.cars = cars가 아닌 new ArrayList<>(cars)로 리스트를 재할당한 이유가 있을까요?
  - cars는 현재 외부에서 생성되어 매개변수로 생성자를 통해 객체에게 전달되는 값이다. 지금은 그런 위험이 없지만 이후 프로젝트 규모가 커지게 되면 혹시 외부에서 실수로 Cars 생성자 매개변수로 전달한 리스트를 그대로 놔뒀다가 수정하는 일이 생기면 Cars 내부의 list 변수에도 영향을 줄 것이라 생각했다.

- 오호 unmodifiableList를 사용하셨군요. 단순히 cars를 반환하지 않고, unmodifiableList()는 사용하면 어떠한 장단점이 있을까요?
  - moveEachCar 메소드는 컬렉션 내 모든 car 인스턴스들을 전진 시키고 출력을 위해 반환하는 메소드입니다. 외부에서 경주에 참여한 자동차들을 담고 있는 리스트가 의도치 않게 수정되는 것을 방지하기 위해 unmodifiable을 사용하였습니다.
  - unmodifiableList를 사용하면 외부에서 의도치 않은 원본 컬렉션에 대한 수정 연산을 방지할 수 있는 것이 장점이라 생각합니다.
  - unmodifiable 은 unmodifiable을 통해 반환된 레퍼런스는 원본 컬렉션으로의 수정 연산이 불가능하다. 그러나 원본 컬렉션에 대한 다른 레퍼런스를 통해서는 수정이 가능하다. 즉 원본 컬렉션의 불변을 완벽하게 보장하지는 않는 것이다.
  - 기존에 존재하는 컬렉션을 immutable화 하기 위해서는 기존 컬렉션의 데이터를 새로운 컬렉션으로 복사한 다음, unmodifiable로 수정 연산을 제한하는 것이 일반적이다.
  - ~~~ java
    List<String> immutableList = Collections.unmodifiableList(new ArrayList<String>(list));
    ~~~

- 전략 패턴을 잘 적용해 주셨네요! 추상 메서드가 하나이므로 함수형 인터페이스 어노테이션을 붙여주신 것도 잘하셨습니다
  - 인터페이스 구현시 구현해야 할 추상 메서드가 하나인 경우에는 함수형 인터페이스 어노테이션으로 명시를 해줘야 하는 이유를 찾아보자.

- readCarNames() 메서드를 호출할 때마다 Scanner 객체를 생성하게 되는데, InputView 필드에 Scanner 객체를 두는 건 어떨까요?
  - inputView 내부에 사용자 입력 값 validation기능을 추가하고 나니 이 기능을 테스트하기 위해 불가피하게 Scanner 객체의 scope를 메소드 안으로 넣어줄 수 밖에 없던 상황이었다.
  - 처음부터 입력값 검증 기능을 view에 위임하지 않고 도메인 클래스 내부에서 검증하거나 차선책으로 validation 클래스를 따로 만들어서 테스트를 진행할 수 있도록 했으면 어땠을까 하는 아쉬움이 남는다.

- cars.decideWinner()의 값을 외부에서 받아오는 것은 어떨까요?
  - 어떤 결과를 출력해야 하는 경우 outputView 메소드 매개변수로 객체를 통째로 전달하는 것이 아니라 그 결과를 매개변수로 전달받아 outputView가 사용하도록 하는 것이 좋을 것 같다.

- 요런 식으로 joining()을 활용하시면 맨 끝 delimiter는 사용되지 않아서 winnerNames.length()-2로 subString() 하실 필요가 없습니다 ㅎㅎ
  - ~~~ java
    String result = strList.stream().collect(Collectors.joining(","));
    ~~~


## 다른 크루들의 리뷰
- Math.random과 Random클래스 차이는 뭘까
- 상수가 너무 많은 것이 아니면 그 파일 내부에 선언하는 것이 좋다.
- 테스트를 할 때 private 메서드에 대한 테스트는 그것을 사용하는 public 메서드를 테스트 하는 것으로 충분하다.
- 꼬리재귀를 통한 입력 예외처리는 반복 수가 많아지면 에러가 날 수 있다. 다른 방법을 사용하면 좋겠다. 방법은 잘 찾아봐라.
- 값의 검증 위치
  - inputView와 도메인에서 검증 기능을 두번 수행하도록 프론트와 백 둘 다 진행하는 것이 좋다.
  - 도메인 클래스 객체 생성이 inputview에서만 이루어지는게 아니기 때문이다.
- 파일 끝에는 항상 개행문자를 추가해야 한다.
    - IEEE에서 정의한 UNIX 표준의 행 단위는 개행을 기준으로 만들어진다. 
    - 즉, 행이란 0 또는 개행문자가 아닌 문자들이 나오다가 개행문자로 끝나는 시퀀스를 의미하며, 불완전항 행은 개행문자 없이 하나 이상의 문자들이 존재하는 것을 의미한다.


# 23.02.11 토요일

## git
git fetch 명령어와 pull 명령어에는 차이가 존재한다.
먼저 공통점으로는 git fetch와 git pull 명령어 모두 원격 저장소에 변경사항이 발생했는지를 체크하는 작업을 수행한다는 것이다.
git fetch는 원격 저장소의 최신 메타 데이터를 확인하여 변경사항이 있는지 확인만 수행한다.
반면 git pull은 원격 저장소의 최신 메타 데이터를 확인하여 변경사항이 있는지 확인하고 존재한다면 최신 데이터들을 모두 복사하여 로컬 저장소로 가져온다.

여기서 하나 유념할 것은 사용자의 로컬 저장소 워크스페이스에는 최소 3개 이상의 프로젝트 복사본이 존재한다는 것이다.
1. 사용자의 commit 기록이 있는 사용자의 로컬 저장소 (이미 로컬에서의 작업 내용이 저장된 저장소)
2. 편집 및 작성 중이지만 아직 로컬 저장소에 커밋되지 않은 프로젝트의 복사본
3. 원격 저장소의 로컬에 캐시된(cached) 프로젝트의 복사본 (처음 clone 해온 프로젝트의 복사본일 가능성이 높다.)

원격 저장소에 변경사항이 발생한 상황에서 만약 git pull 명령어를 바로 사용하면 로컬의 브랜치와 프로젝트 복사본들의 작업 내용이 손실될 수 있다.
따라서 항상 git fetch 명령어를 이용해 원격 저장소에 변경사항이 존재하는 지 확인하고 git pull 명령어를 사용하는 것이 중요하다.

git rebase 명령어는 두 개의 공통 base를 가진 branch에서 한 branch의 base를 다른 branch의 최신 커밋으로 branch의 base를 옮기는 작업이다.


## 의존관계 (https://annajinee.tistory.com/39)
A 클래스가 B 클래스를 의존한다는 것은 B 클래스가 변경될 시 A 클래스 또한 변경될 가능성이 존재한다는 것이다.
의존성은(Dependency) 클래스간 의존성과 패키지간 의존성으로 분류할 수 있다.

### 클래스 사이의 의존성
클래스 의존성은 연관관계(Association), 의존관계(Dependency), 상속관계(Inheritance), 실체화관계(Realization) 4가지로 나누어진다.


## 자동차 경주 리팩토링 공통 피드백 정리
- 만약 Car move 메소드의 매개변수로 random 값을 받는다고 해도, 매개변수 명을 randomNumber로 지을 필요는 없다. Car 입장에서는 숫자가 랜덤 값인지 알 필요가 없기 때문이다.
  - [효과적인 이름짓기 레퍼런스](https://remotty.github.io/blog/2014/03/01/hyogwajeogin-ireumjisgi/)

- 구현 순서도 코딩 컨벤션이다.
  - 상수, 클래스 변수, 인스턴스 변수, 생성자, 메서드 순으로 작성한다.

- IDE의 코드 정렬 기능을 적극적으로 활용하자
  - IntelliJ IDEA: ⌥⌘L, Ctrl+Alt+L
  - Eclipse: ⇧⌘F, Ctrl+Shift+F

- final 키워드를 사용해 값의 변경을 막아라
  - 최근에 등장하는 프로그래밍 언어들은 기본이 불변 값이다.
  - **메서드 매개변수에도 final 키워드 사용을 해주도록 하자!**
  - 상태 값이 바뀌지 않을 것이라면 습관적으로 final을 사용해주자.
  ~~~ java
  public class Car {
    private final String name;
    private int position;

    public Car(final String name) {
        this.name = name;
    }

    ...

  }
  ~~~

  
- 객체를 객체답게 사용해라
  - 객체 내부에 상태값을 저장하는 인스턴스 변수에 대해 getter와 setter 사용을 지양한다.
  - **대신 상태 값을 가지는 객체에 메세지(매개변수)를 던지도록 구조를 바꿔 데이터를 가지는 객체가 일하도록 한다.**

- 단위 테스트하기 힘든 코드를 테스트하기
  - Random과 같은 문제로 단위 테스트가 하기 힘들 수 있다. 
  - 먼저 테스트 가능한 코드와 테스트 하기 힘든 코드를 분리한다.
    - ex) 랜덤값을 외부에서 결정해서 받아오는 것으로 랜덤 값 생성 코드를 분리한다.
  - 인터페이스를 사용해 해결한다.

- Collection을 활용한 로직 처리
  - collection을 활용해 로직을 구현할 때 바로 직접 구현하지 말고 먼저 Collection API를 통해 해결할 수 있는 방법이 없는지 먼저 찾아본다.
  - 방법을 찾았는데 해결 방법을 찾지 못한 경우에만 직접 구현한다.

~~~ java
// refactoring 전
public class ResultView {
    private Cars cars = null;

    private String getTopRankedCar(List<Car> carList) {
        String topCarString = "";
        cars = new Cars(carList);
        int maxPosition = getMaxPosition(carList);

        for (int i = 0; i < carList.size(); i++) {
            if (cars.getPosition(i) == maxPosition) {
                topCarString += cars.getCarName(i) + ", ";
            }
        }
        return topCarString.substring(0, topCarString.length() - 2);
    }
  
    private int getMaxPosition(List<Car> carList) {
        int maxPosition = 0;
        cars = new Cars(carList);

        for (int i = 0; i < carList.size(); i++) {
            if (maxPosition < cars.getPosition(i)) {
                maxPosition = cars.getPosition(i);
            }
        }
        return maxPosition;
    }
}
~~~

~~~ java
// refactoring 후
public class ResultView {
    private Cars cars = null;

    private String getTopRankedCar(List<Car> carList) {
        String topCarString = "";
        cars = new Cars(carList);
        int maxPosition = getMaxPosition(carList);
        
        return cars.stream()
                   .filter(car -> car.isAtPosition(maxPosition))
                   .collect(Collectors.joining(","))
    }
  
    private int getMaxPosition(List<Car> carList) {
        int maxPosition = 0;
        cars = new Cars(carList);

        return cars.stream()
            .map(Car::getPosition)
            .max(Integer::compareTo)
            .orElseThrow();
    }
}
~~~

- 테스트 픽스처
  - 테스트 픽스처란 테스트를 반복적으로 수행할 수 있게 도와주고 매번 동일한 결과를 얻을 수 있도록 도와주는 '기반이 되는 환경이나 상태'를 의미한다.
  - 여러 테스트에서 공용으로 사용할 수 있는 테스트 픽스처는 테스트 인스턴스의 변수 혹은 별도의 클래스에 모아두도록 하자.
  - @BeforeEach 어노테이션을 사용하는 경우 각 테스트에서 중복으로 사용하는 테스트 픽스처만 초기화해야 한다.

- 특정 상태를 만들기 위한 반복 코드 제거
  - 우승자 구하는 로직을 테스트를 진행하기 위한 테스트 픽스처 준비
  - 테스트 픽스처를 위해 도메인 클래스에 생성자를 추가할 수 있다.(선택적 사항)


## 2차 미션 진행
- 2차 미션은 자동차 경주 미션 리팩토링이다.
- 핵심 비지니스 로직을 가지는 객체를 domain 패키지, UI 관련한 객체를 view 패키지에 구현한다.
- MVC 패턴 기반으로 리팩터링해 view 패키지의 객체가 domain 패키지 객체에 의존할 수 있지만, domain 패키지의 객체는 view 패키지 객체에 의존하지 않도록 구현한다.
  - 즉 view 클래스 내에서 domain 객체의 코드를 사용할 수 있지만, domain 클래스에서 view의 코드 사용을 지양하도록 하자.








