# 레벨 1 - 3주차 (23.02.20 ~ 23.02.26)

---

# 23.02.20

## 2단계 미션 진행
- TDD를 진행하면서 일급 컬렉션에 대한 테스트 코드를 구현할 때는 요소 값 클래스에 대한 테스트도 같이 진행해줘야 한다.
  - Results 클래스에 대해 TDD를 진행하다보니 Results 내부 컬렉션 요소 값이 Result가 아니라 String으로 구현되었음에도 틀린부분을 생각해내기 힘들었다.
  - 따라서 Results 클래스에 Result 클래스에서 예외 처리되는 테스트를 한 번 더 진행하는 것으로 해결.

- 입력 값이 형식에 맞게 들어왔는지 확인하고 Wrapper 객체들을 만들어서 반환해주는 역할을 하는 클래스가 일급 컬렉션일까?
- 단지 클래스 속성 값으로 컬렉션 하나만 존재한다고 일급컬렉션이라고 생각하지 말자...
- Names : 일급 컬렉션이 아닌데 일급 컬렉션처럼 취급하려고 하니까 값 반환 문제로 골머리를 썩었다.
~~~ java
public class Names {
    private static final String NAMES_DELIMITER = ",";

    private final List<Name> names = new ArrayList<>();

    public Names(String inputNames) {
        splitInputNames(inputNames).stream()
                .map(String::strip)
                .forEach(name -> names.add(new Name(name)));
    }

    public Name getName(int index) {
        return names.get(index);
    }

    public List<String> getValues() {
        return names.stream()
                .map(Name::getValue)
                .collect(Collectors.toList());
    }

    public int size() {
        return names.size();
    }

    private List<String> splitInputNames(String inputNames) {
        return Arrays.asList(inputNames.split(NAMES_DELIMITER));
    }
}
~~~

- Results : Results 클래스도 마찬가지. 입력값을 받아 Result 들을 생성해서 넘겨주는 역할.
~~~ java
public class Results {
    private static final String WRONG_SIZE_RESULTS_ERROR = "[ERROR] 사다리 게임 결과 값의 개수는 전체 사람의 수와 동일해야 합니다.";
    private static final String RESULTS_DELIMITER = ",";

    private final List<Result> results;

    public Results(int playersSize, String inputResults) {
        List<String> results = splitInputResults(inputResults);
        validateRightResultsSize(playersSize, results);
        this.results = results.stream()
                .map(Result::new)
                .collect(Collectors.toList());
    }

    public List<String> getValues() {
        return results.stream()
                .map(Result::getValue)
                .collect(Collectors.toList());
    }

    private void validateRightResultsSize(int playersSize, List<String> results) {
        if(results.size() != playersSize) {
            throw new IllegalArgumentException(WRONG_SIZE_RESULTS_ERROR);
        }
    }

    private List<String> splitInputResults(String inputResults) {
        return Arrays.stream(inputResults.split(RESULTS_DELIMITER))
                .map(String::trim)
                .collect(Collectors.toList());
    }
}
~~~

- 그러면 이 두 클래스의 공통점은 입력값을 받아 검증을 거친 후 Wrapper 객체를 만들어준다.
- 팩토리 패턴이라는 것을 사용해야 할 것 같은데 정확한 개념이 맞는지 물어보자...!
- 팩토리 패턴을 사용한 클래스에서 검증 로직을 수행해도 괜찮은가...?
- 현재 사용한 Names, Results 팩토리 클래스를 그냥 InputView에게 책임을 위임하는 것이 옳을까?
  - 그런 경우라면 입력되는 Result 개수는 플레이어의 수와 동일해야 함을 검증하는 로직도 inputView로 같이 넘어가는데 괜찮을까?


# 23.02.21

## 예외처리
- 자바 Exception
- Exception도 상속 구조를 가지고 있다.
- 각 단계는 무슨 차이가 있는지 고민해보자
- checked unchecked 차이는 컴파일 타임에 에러 발생 여부를 체크 하는지의 차이이다.
- RuntimeException은 unchecked이다 즉 런타임에 체트된다.
- 왜 이렇게 checked, unchecked 로 나눠놨을까? 선택방법이 정리된 것은 매우 애매하다...
- 런타임에 생길 수 있는 문제를 해결하기 위함이 아닐까?
- 컴파일 타임에 미리 알수 있는 예외를 해결하기 위함이 checked이지 않을까?
- 언어가 개발되면서 사람의 생각들은 계속 바뀌고 있다. 대다수의 언어에서 checked exception은 사라지고 있다. 오히려 코드가 지저분해지는 문제가 있을 수 있다. 코틀린에는 없다...
- 런타임 익셉션은 컴파일 시점에 예외가 발생할 지 알 수 없다.
- 둘 다 기능은 같은데 시점만 다른 것
- 어떤 메소드 내에서 이런 에러가 발생할 수 있다는 것을 어떻게 전달할 수 있을까?
  - checked Exception이 어떤 문서나 코드를 직접 읽지 않고도 제일 의도를 잘 전달할 수 있는 방법이 아닐까?
  - throws를 메서드에 붙여서 외부로 넘겨도 결국 처리하는쪽에 달려있다. -> 이게 핵심 포인트
  - 허브 : Checked exception을 사용한다면 코드를 안정적이게 작성할 수 있지만, 네오의 코드를 가져다 사용하는 입장에서는 불편함이 증가할 것 같아요. (스트림 사용 불가, 예외 전환과 같은 throws 처리)
  - 누누 : 대부분의 코드에서 throws 가 붙었을 경우에, 어느 한사람이라도 귀찮아서 throws Exception 을 하게 되면 상위계층에서 이를 제대로 확인하는 의미가 없어지기에, 지저분해지기만 할 수도 있을 것 같아요
  - 후추 : Checked Exception이 안정성을 완벽히 보장하는 것도 아닌 것 같습니다. 결국 사용하는 쪽에서 예외처리를 어떻게 하느냐에 달려 있기 때문입니다.
  - 로이스 : checked Exception으로 메서드 작성자의 의도를 전달하며 강제할 수 있는데, 과연 외부에서 해당 예외를 작성자의 의도대로 처리하는 가에 대한 의문이 있을 것 같습니다.
- 문법적인 내용은 나중에 간단하게 보고 넘길 수 있도록 하자.
- 예외처리를 어떻게 잘 활용할 수 있을까?
  - 복구 : 작성하는 코드에 문제가 생겼을 때 정상 상태로 돌려놓는다. 논리적인 사용 방법
  - 회피 : 예외 처리의 책임을 다른 곳으로 돌리는 것. 회피를 할때는 많은 고민 후 결정한다.
  - 무시 : 무시를 하는 경우는 더 많은 고민이 필요하다. 무시를 의도에 맞게 사용하는 경우도 생각보다 많다.
  - 전환 : checked -> unchecked exception으로 전환할 수 있다. 예제처럼 DBException이 해당계층에서 처리되는게 아니라 도메인까지 넘어가버리면 안되기 때문에 적절한 선에서 끊어주는 역할도 있다.
  - 추상화계층?
    - 뷰가 있고 도메인이 있는데 도메인에서 뷰를 사용하지 말라고 한다.
    - 그 이유가 뭘까?
    - 도메인은 우리의 밥벌이이다. 즉 잘 지켜줘야 하는 부분이다. 잘 숨겨줘야 하는데 뷰는 변화가 굉장히 많은 곳이기 떄문에 뷰의 영향을 도메인이 받으면 안된다.
    - 블루컬러 관점에서 봤을 떄 도메인이 더 중요하다.
    - 뷰가 있고 도메인이 있으면 계층이 존재할 것이다. 뷰,도메인,데이터저장영역 등을 나눠서 사용하게 될텐데...
    - 뷰 영역이 도메인, 데이터 영역에 침범하지 않도록 해줘야 한다. 그 반대로 다른 영역들도 마찬가지이다.
    - 그래서 각 부분에 대해 추상화계층을 만들어서 잘 분리하는 것이 좋다.
    - 코드에서 목적에 맞게 분리하는 것이다.
    - 계층이 나눠지면 소통할 때는 어쨋든 왔다갔다 해야하는데 그런 부분을 잘 생각하고 설계해줘야 하는 부분이 추상화 계층이다. (어려운 개념이다..)
    - 어떠한 부분까지 알게할 것인가... 
    - (내가 내린 결론) 서로 다른 두 계층 간 의존성을 분리하기 위해 두 계층 사이에서 오고가는 메세지를 중개할 수 있도록 하는 역할의 계층을 추상화 계층이라고 한다.
      - 즉 두 계층이 서로 메세지를 주고받기 위해 해야하는 일을 정확하게 명시해주는 계층을 추상화 계층이라고 할 수 있을 것 같다.

## 리스트 이해하기
- 꼭 그림으로 그려가보면서 진행해보자.
- 낯선 개념을 학습할 때 어떻게 동작하는지 이해하기 편한 방법이다.

## 사다리 미션 2단계
- 출력을 위한 getter를 구현해두고 해당 객체의 속성값이 일치하는지 판단하는 메서드는 따로 만드는 것이 옳은가?
  - 예를 들어 주어진 Name 값이 Player의 Name인지 확인하는 isPlayerName() 메서드를 구현해 참/거짓 값을 반환한다.
  - 위 경우처럼 구현하면 객체에 메세지를 던지는 좋은 케이스가 되겠지만... 출력을 위한 getter가 있어서 다른 개발자는 getter를 사용해버린다면...?
  - 처음 의도했던 대로 메서드들이 사용되지 못할 것 같은데 이런 경우는 어떻게 하는 것이 좋은지?

- 이름에 대한 String 원시 값을 포장한 Name 객체간의 비교에서 equals와 hashCode 메서드를 오버라이딩 했다가 리뷰를 받고 삭제했었습니다.
- 그런데 레벨2를 진행하다 보니 Name간 객체 비교를 해야하는 경우가 생겼습니다.
- 일단은 동일한 타입 객체를 인자로 받아 내부 속성값들을 비교하여 참 거짓을 반환하는 메서드를 정의하여 해당 기능을 수행하도록 했습니다.
- 그렇다면 예전에 한 것처럼 equals와 hashCode를 재정의하는 방법이 아니라 객체 내부에서 직접 값을 비교해주는 메서드를 구현해주는 것이 더 나은 방법인지...
- equals와 hashCode를 재정의해야 하는 상황이 따로 존재하는 것인지 궁금하다.
  - 현재 알고있는 것으로는 HashMap 등 사용자 정의 객체를 자료구조를 통해 관리하려고 할 때 재정의해줘야 한다는 것 정도로만 알고있다.

- 단순 Wrapper 클래스와 VO의 차이 [레퍼런스](https://livenow14.tistory.com/37)

- 사다리 라인을 따라 플레이어의 위치를 바꾸는 역할은 누가 수행해야 할까?
  - 당연히 Player 객체들을 요소값으로 갖고 있는 Players에서 하는 게 자연스럽지 않나?
  - 뭐가 문제가 되지 그러면?
    - Position 값을 wrapping하는 클래스 하나 구현
    - Player 클래스 속성값으로 position값 추가
    - 그렇게 했을 떄 swap 기능은 어떻게 할건데?
    - 각 Player가 갖고 있는 position 값을 확인한 후 해당 플레이어끼리 position 교체
    - 에휴... 이러고 구현 들어가는 게 TDD가 맞아??

- Weapping 클래스에 대해서도 출력을 위한 getter를 지양하고 메세지를 던지려 노력하는 것이 맞는 것인지?
  - 맞다고 판단하고 출력을 제외한 비즈니스 로직 쪽에서는 최대한 wrapper 클래스에게 메세지를 던져 해결하는 것으로 결론내림
  - 왜냐하면 그냥 getter로 원시값을 내 줘 버리면 wrapping한 의미가 없어지기 때문에
  - 불가피한 경우는 출력을 위함 밖에 없다...고 생각하자.

- Ladder 클래스가 Players 클래스에게 던져줘야 하는 메세지는 무엇인가?
- 실질적으로 따져보면 List<Boolean> 컬렉션이 필요하다.
- 그러나 현재 Players 클래스가 필요한 List<Boolean>은 Ladder 내부의 Line 객체로 Wrapping 되어 있다.
- 그러면 Ladder 클래스에서 Line을 그대로 넘겨줄 것이 아니라 내부의 List<Boolean> 값을 꺼내서 넘겨줘야 하나?
- 아니면 Line을 그대로 넘겨줘서 Players 클래스에서 List<Boolean> 을 직접 꺼내도록 해야하나?
- 디미터의 법칙은 내가 다루는 객체의 속사정을 몰라야 한다.
- 그런데 Line을 그대로 전달하면 결국 Line 내부의 속성값을 Players가 알아야만 하기 때문에 getter를 사용한 이후 List<Boolean>을 사용하게 된다.
- 이 경우 Players 클래스의 메서드 인자로 넘겨받은 매개변수의 메서드만 사용 가능하다. 그러나 위의 경우는 디미터의 법칙을 깨뜨린다.
- 그렇기 때문에 Line을 그대로 넣어줄 것이 아니라 Line 내 List<Boolean>을 꺼내서 넘겨줘야 한다.
- 








