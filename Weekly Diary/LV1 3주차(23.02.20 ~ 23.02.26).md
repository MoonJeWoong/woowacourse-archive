# 레벨 1 - 3주차 (23.02.20 ~ 23.02.26)

---

# 23.02.20

## 2단계 미션 진행
- TDD를 진행하면서 일급 컬렉션에 대한 테스트 코드를 구현할 때는 요소 값 클래스에 대한 테스트도 같이 진행해줘야 한다.
  - Results 클래스에 대해 TDD를 진행하다보니 Results 내부 컬렉션 요소 값이 Result가 아니라 String으로 구현되었음에도 틀린부분을 생각해내기 힘들었다.
  - 따라서 Results 클래스에 Result 클래스에서 예외 처리되는 테스트를 한 번 더 진행하는 것으로 해결.

- 입력 값이 형식에 맞게 들어왔는지 확인하고 Wrapper 객체들을 만들어서 반환해주는 역할을 하는 클래스가 일급 컬렉션일까?
- 단지 클래스 속성 값으로 컬렉션 하나만 존재한다고 일급컬렉션이라고 생각하지 말자...
- Names : 일급 컬렉션이 아닌데 일급 컬렉션처럼 취급하려고 하니까 값 반환 문제로 골머리를 썩었다.
~~~ java
public class Names {
    private static final String NAMES_DELIMITER = ",";

    private final List<Name> names = new ArrayList<>();

    public Names(String inputNames) {
        splitInputNames(inputNames).stream()
                .map(String::strip)
                .forEach(name -> names.add(new Name(name)));
    }

    public Name getName(int index) {
        return names.get(index);
    }

    public List<String> getValues() {
        return names.stream()
                .map(Name::getValue)
                .collect(Collectors.toList());
    }

    public int size() {
        return names.size();
    }

    private List<String> splitInputNames(String inputNames) {
        return Arrays.asList(inputNames.split(NAMES_DELIMITER));
    }
}
~~~

- Results : Results 클래스도 마찬가지. 입력값을 받아 Result 들을 생성해서 넘겨주는 역할.
~~~ java
public class Results {
    private static final String WRONG_SIZE_RESULTS_ERROR = "[ERROR] 사다리 게임 결과 값의 개수는 전체 사람의 수와 동일해야 합니다.";
    private static final String RESULTS_DELIMITER = ",";

    private final List<Result> results;

    public Results(int playersSize, String inputResults) {
        List<String> results = splitInputResults(inputResults);
        validateRightResultsSize(playersSize, results);
        this.results = results.stream()
                .map(Result::new)
                .collect(Collectors.toList());
    }

    public List<String> getValues() {
        return results.stream()
                .map(Result::getValue)
                .collect(Collectors.toList());
    }

    private void validateRightResultsSize(int playersSize, List<String> results) {
        if(results.size() != playersSize) {
            throw new IllegalArgumentException(WRONG_SIZE_RESULTS_ERROR);
        }
    }

    private List<String> splitInputResults(String inputResults) {
        return Arrays.stream(inputResults.split(RESULTS_DELIMITER))
                .map(String::trim)
                .collect(Collectors.toList());
    }
}
~~~

- 그러면 이 두 클래스의 공통점은 입력값을 받아 검증을 거친 후 Wrapper 객체를 만들어준다.
- 팩토리 패턴이라는 것을 사용해야 할 것 같은데 정확한 개념이 맞는지 물어보자...!
- 팩토리 패턴을 사용한 클래스에서 검증 로직을 수행해도 괜찮은가...?



















