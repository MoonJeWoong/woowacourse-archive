# 레벨 1 - 3주차 (23.02.20 ~ 23.02.26)

---

# 23.02.20

## 2단계 미션 진행
- TDD를 진행하면서 일급 컬렉션에 대한 테스트 코드를 구현할 때는 요소 값 클래스에 대한 테스트도 같이 진행해줘야 한다.
  - Results 클래스에 대해 TDD를 진행하다보니 Results 내부 컬렉션 요소 값이 Result가 아니라 String으로 구현되었음에도 틀린부분을 생각해내기 힘들었다.
  - 따라서 Results 클래스에 Result 클래스에서 예외 처리되는 테스트를 한 번 더 진행하는 것으로 해결.

- 입력 값이 형식에 맞게 들어왔는지 확인하고 Wrapper 객체들을 만들어서 반환해주는 역할을 하는 클래스가 일급 컬렉션일까?
- 단지 클래스 속성 값으로 컬렉션 하나만 존재한다고 일급컬렉션이라고 생각하지 말자...
- Names : 일급 컬렉션이 아닌데 일급 컬렉션처럼 취급하려고 하니까 값 반환 문제로 골머리를 썩었다.
~~~ java
public class Names {
    private static final String NAMES_DELIMITER = ",";

    private final List<Name> names = new ArrayList<>();

    public Names(String inputNames) {
        splitInputNames(inputNames).stream()
                .map(String::strip)
                .forEach(name -> names.add(new Name(name)));
    }

    public Name getName(int index) {
        return names.get(index);
    }

    public List<String> getValues() {
        return names.stream()
                .map(Name::getValue)
                .collect(Collectors.toList());
    }

    public int size() {
        return names.size();
    }

    private List<String> splitInputNames(String inputNames) {
        return Arrays.asList(inputNames.split(NAMES_DELIMITER));
    }
}
~~~

- Results : Results 클래스도 마찬가지. 입력값을 받아 Result 들을 생성해서 넘겨주는 역할.
~~~ java
public class Results {
    private static final String WRONG_SIZE_RESULTS_ERROR = "[ERROR] 사다리 게임 결과 값의 개수는 전체 사람의 수와 동일해야 합니다.";
    private static final String RESULTS_DELIMITER = ",";

    private final List<Result> results;

    public Results(int playersSize, String inputResults) {
        List<String> results = splitInputResults(inputResults);
        validateRightResultsSize(playersSize, results);
        this.results = results.stream()
                .map(Result::new)
                .collect(Collectors.toList());
    }

    public List<String> getValues() {
        return results.stream()
                .map(Result::getValue)
                .collect(Collectors.toList());
    }

    private void validateRightResultsSize(int playersSize, List<String> results) {
        if(results.size() != playersSize) {
            throw new IllegalArgumentException(WRONG_SIZE_RESULTS_ERROR);
        }
    }

    private List<String> splitInputResults(String inputResults) {
        return Arrays.stream(inputResults.split(RESULTS_DELIMITER))
                .map(String::trim)
                .collect(Collectors.toList());
    }
}
~~~

- 그러면 이 두 클래스의 공통점은 입력값을 받아 검증을 거친 후 Wrapper 객체를 만들어준다.
- 팩토리 패턴이라는 것을 사용해야 할 것 같은데 정확한 개념이 맞는지 물어보자...!
- 팩토리 패턴을 사용한 클래스에서 검증 로직을 수행해도 괜찮은가...?
- 현재 사용한 Names, Results 팩토리 클래스를 그냥 InputView에게 책임을 위임하는 것이 옳을까?
  - 그런 경우라면 입력되는 Result 개수는 플레이어의 수와 동일해야 함을 검증하는 로직도 inputView로 같이 넘어가는데 괜찮을까?


# 23.02.21

## 예외처리
- 자바 Exception
- Exception도 상속 구조를 가지고 있다.
- 각 단계는 무슨 차이가 있는지 고민해보자
- checked unchecked 차이는 컴파일 타임에 에러 발생 여부를 체크 하는지의 차이이다.
- RuntimeException은 unchecked이다 즉 런타임에 체트된다.
- 왜 이렇게 checked, unchecked 로 나눠놨을까? 선택방법이 정리된 것은 매우 애매하다...
- 런타임에 생길 수 있는 문제를 해결하기 위함이 아닐까?
- 컴파일 타임에 미리 알수 있는 예외를 해결하기 위함이 checked이지 않을까?
- 언어가 개발되면서 사람의 생각들은 계속 바뀌고 있다. 대다수의 언어에서 checked exception은 사라지고 있다. 오히려 코드가 지저분해지는 문제가 있을 수 있다. 코틀린에는 없다...
- 런타임 익셉션은 컴파일 시점에 예외가 발생할 지 알 수 없다.
- 둘 다 기능은 같은데 시점만 다른 것
- 어떤 메소드 내에서 이런 에러가 발생할 수 있다는 것을 어떻게 전달할 수 있을까?
  - checked Exception이 어떤 문서나 코드를 직접 읽지 않고도 제일 의도를 잘 전달할 수 있는 방법이 아닐까?
  - throws를 메서드에 붙여서 외부로 넘겨도 결국 처리하는쪽에 달려있다. -> 이게 핵심 포인트
  - 허브 : Checked exception을 사용한다면 코드를 안정적이게 작성할 수 있지만, 네오의 코드를 가져다 사용하는 입장에서는 불편함이 증가할 것 같아요. (스트림 사용 불가, 예외 전환과 같은 throws 처리)
  - 누누 : 대부분의 코드에서 throws 가 붙었을 경우에, 어느 한사람이라도 귀찮아서 throws Exception 을 하게 되면 상위계층에서 이를 제대로 확인하는 의미가 없어지기에, 지저분해지기만 할 수도 있을 것 같아요
  - 후추 : Checked Exception이 안정성을 완벽히 보장하는 것도 아닌 것 같습니다. 결국 사용하는 쪽에서 예외처리를 어떻게 하느냐에 달려 있기 때문입니다.
  - 로이스 : checked Exception으로 메서드 작성자의 의도를 전달하며 강제할 수 있는데, 과연 외부에서 해당 예외를 작성자의 의도대로 처리하는 가에 대한 의문이 있을 것 같습니다.
- 문법적인 내용은 나중에 간단하게 보고 넘길 수 있도록 하자.
- 예외처리를 어떻게 잘 활용할 수 있을까?
  - 복구 : 작성하는 코드에 문제가 생겼을 때 정상 상태로 돌려놓는다. 논리적인 사용 방법
  - 회피 : 예외 처리의 책임을 다른 곳으로 돌리는 것. 회피를 할때는 많은 고민 후 결정한다.
  - 무시 : 무시를 하는 경우는 더 많은 고민이 필요하다. 무시를 의도에 맞게 사용하는 경우도 생각보다 많다.
  - 전환 : checked -> unchecked exception으로 전환할 수 있다. 예제처럼 DBException이 해당계층에서 처리되는게 아니라 도메인까지 넘어가버리면 안되기 때문에 적절한 선에서 끊어주는 역할도 있다.
  - 추상화계층?
    - 뷰가 있고 도메인이 있는데 도메인에서 뷰를 사용하지 말라고 한다.
    - 그 이유가 뭘까?
    - 도메인은 우리의 밥벌이이다. 즉 잘 지켜줘야 하는 부분이다. 잘 숨겨줘야 하는데 뷰는 변화가 굉장히 많은 곳이기 떄문에 뷰의 영향을 도메인이 받으면 안된다.
    - 블루컬러 관점에서 봤을 떄 도메인이 더 중요하다.
    - 뷰가 있고 도메인이 있으면 계층이 존재할 것이다. 뷰,도메인,데이터저장영역 등을 나눠서 사용하게 될텐데...
    - 뷰 영역이 도메인, 데이터 영역에 침범하지 않도록 해줘야 한다. 그 반대로 다른 영역들도 마찬가지이다.
    - 그래서 각 부분에 대해 추상화계층을 만들어서 잘 분리하는 것이 좋다.
    - 코드에서 목적에 맞게 분리하는 것이다.
    - 계층이 나눠지면 소통할 때는 어쨋든 왔다갔다 해야하는데 그런 부분을 잘 생각하고 설계해줘야 하는 부분이 추상화 계층이다. (어려운 개념이다..)
    - 어떠한 부분까지 알게할 것인가... 
    - (내가 내린 결론) 서로 다른 두 계층 간 의존성을 분리하기 위해 두 계층 사이에서 오고가는 메세지를 중개할 수 있도록 하는 역할의 계층을 추상화 계층이라고 한다.
      - 즉 두 계층이 서로 메세지를 주고받기 위해 해야하는 일을 정확하게 명시해주는 계층을 추상화 계층이라고 할 수 있을 것 같다.

## 리스트 이해하기
- 꼭 그림으로 그려가보면서 진행해보자.
- 낯선 개념을 학습할 때 어떻게 동작하는지 이해하기 편한 방법이다.

## 사다리 미션 2단계
- 출력을 위한 getter를 구현해두고 해당 객체의 속성값이 일치하는지 판단하는 메서드는 따로 만드는 것이 옳은가?
  - 예를 들어 주어진 Name 값이 Player의 Name인지 확인하는 isPlayerName() 메서드를 구현해 참/거짓 값을 반환한다.
  - 위 경우처럼 구현하면 객체에 메세지를 던지는 좋은 케이스가 되겠지만... 출력을 위한 getter가 있어서 다른 개발자는 getter를 사용해버린다면...?
  - 처음 의도했던 대로 메서드들이 사용되지 못할 것 같은데 이런 경우는 어떻게 하는 것이 좋은지?
  - => 뷰가 도메인에 의존하면 된다. 뷰에서 VO / Wrapping 객체를 벗겨내주자...(맞나?)

- 이름에 대한 String 원시 값을 포장한 Name 객체간의 비교에서 equals와 hashCode 메서드를 오버라이딩 했다가 리뷰를 받고 삭제했었습니다.
- 그런데 레벨2를 진행하다 보니 Name간 객체 비교를 해야하는 경우가 생겼습니다.
- 일단은 동일한 타입 객체를 인자로 받아 내부 속성값들을 비교하여 참 거짓을 반환하는 메서드를 정의하여 해당 기능을 수행하도록 했습니다.
- 그렇다면 예전에 한 것처럼 equals와 hashCode를 재정의하는 방법이 아니라 객체 내부에서 직접 값을 비교해주는 메서드를 구현해주는 것이 더 나은 방법인지...
- equals와 hashCode를 재정의해야 하는 상황이 따로 존재하는 것인지 궁금하다.
  - 현재 알고있는 것으로는 HashMap 등 사용자 정의 객체를 자료구조를 통해 관리하려고 할 때 재정의해줘야 한다는 것 정도로만 알고있다.

- 단순 Wrapper 클래스와 VO의 차이 
  - [레퍼런스](https://livenow14.tistory.com/37) 
  - [equals와 Hashcode는 언제 재정의 해야 하나](https://wisdom-and-record.tistory.com/114)

- 사다리 라인을 따라 플레이어의 위치를 바꾸는 역할은 누가 수행해야 할까?
  - 당연히 Player 객체들을 요소값으로 갖고 있는 Players에서 하는 게 자연스럽지 않나?
  - 뭐가 문제가 되지 그러면?
    - Position 값을 wrapping하는 클래스 하나 구현
    - Player 클래스 속성값으로 position값 추가
    - 그렇게 했을 떄 swap 기능은 어떻게 할건데?
    - 각 Player가 갖고 있는 position 값을 확인한 후 해당 플레이어끼리 position 교체
    - 에휴... 이러고 구현 들어가는 게 TDD가 맞아??

- Weapping 클래스에 대해서도 출력을 위한 getter를 지양하고 메세지를 던지려 노력하는 것이 맞는 것인지?
  - 맞다고 판단하고 출력을 제외한 비즈니스 로직 쪽에서는 최대한 wrapper 클래스에게 메세지를 던져 해결하는 것으로 결론내림
  - 왜냐하면 그냥 getter로 원시값을 내 줘 버리면 wrapping한 의미가 없어지기 때문에
  - 불가피한 경우는 출력을 위함 밖에 없다...고 생각하자.

- Ladder 클래스가 Players 클래스에게 던져줘야 하는 메세지는 무엇인가?
- 실질적으로 따져보면 List<Boolean> 컬렉션이 필요하다.
- 그러나 현재 Players 클래스가 필요한 List<Boolean>은 Ladder 내부의 Line 객체로 Wrapping 되어 있다.
- 그러면 Ladder 클래스에서 Line을 그대로 넘겨줄 것이 아니라 내부의 List<Boolean> 값을 꺼내서 넘겨줘야 하나?
- 아니면 Line을 그대로 넘겨줘서 Players 클래스에서 List<Boolean> 을 직접 꺼내도록 해야하나?
- 디미터의 법칙은 내가 다루는 객체의 속사정을 몰라야 한다.
- 그런데 Line을 그대로 전달하면 결국 Line 내부의 속성값을 Players가 알아야만 하기 때문에 getter를 사용한 이후 List<Boolean>을 사용하게 된다.
- 이 경우 Players 클래스의 메서드 인자로 넘겨받은 매개변수의 메서드만 사용 가능하다. 그러나 위의 경우는 디미터의 법칙을 깨뜨린다.
- 그렇기 때문에 Line을 그대로 넣어줄 것이 아니라 Line 내 List<Boolean>을 꺼내서 넘겨줘야 한다.

- TDD를 진행하면서 가장 머리 아팠던 문제 : 이렇게 테스트 코드를 구현하면 나중에 안쓸것 같은 메서드 혹은 getter를 사용해 테스트해야 될 것 같은데...? 어떻게 해야하지...?
  - 일단 테스트코드를 짜자. 그리고 리팩토링하자
  - 이후 메서드 접근제어자가 private화 된다면 해당 테스트 코드는 Disabled 처리하면 되지 않을까?
  - 그리고 해당 메서드를 사용하는 다른 public 메서드를 테스트 함으로써 넘어갈 수 있도록 하자.

- 결국 도메인/모델 쪽에서는 VO/Wrapping클래스를 사용하여 로직을 수행하도록 하고 모든 원시값 getter는 view에서 도메인에게 의존하는 것으로 변경

- 왜 equals와 hashcode를 바로 구현하면 안될까?
- 


# 23.02.22

- 교육을 슬기롭게 소화하기 위한 몇 가지 이야기
- 프로그래머로 취업하기 위해 몇 가지 과정을 거치게 될텐데 어떻게 하면 프로그래밍을 즐기면서 살아갈 수 있는지 제시해보고자 한다.
- 교육이라는 것은 생겨난지 100년도 채 안된 학문이다.
- 그래서 당연시 알고있던 것들이 사실이 아닐 수도 있다는 것이다.
- 권위있는 사람들이 하는말을 맹목적으로 믿어서는 안된다.
- 자신감이 바닥으로 다시 떨어져서 유지되는 기간을 슬기롭게 잘 이겨내는 것이 중요하다.
- 자신감 그래프가 이렇게 그려지는 이유는 초보자들을 위한 자료는 엄청나게 많다.
- 전문가들을 위한 글도 생각보다 많다.
- 하지만 이 사이 구간에 해당하는 학습자료는 많지 않다.
- 또한 학습할 지식의 범위 또한 이 구간에서 급격히 늘어나게 되어있다.
- 내가 잘하고 있나? 잘못된 방향으로 가고 있는 것 아닌가? 생각하기 쉽다.
- 우리는 이 구간은 슬기롭게 이겨내고 자신감이 다시 차오르는 그 구간에서 취업하게 될 것이다.
- 만약 우리가 모든것을 완벽하게 끝내고 취업하고자 한다면 취업하기는 힘들다는 것을 반드시 기억하자.
- 잘하는 크루들만 보기 때문에 힘들어지는 것.
- 항상 과거의 내 모습보다 더 나아졌는가만 생각하자.
- 경쟁의식을 버리는 것을 꾸준히 의식하자.
- 힘들 때, 자존감이 떨어질 때 데일리 미팅 얘기, 코치들 면담 신청하기
- 남들이 스터디를 많이한다... CS 공부한다... 이렇게 휘둘러지게 되면 더 힘들어진다.
- 자신만의 학습법과 방향을 흔들리지 않고 꾸준하게 준비하는 것이 중요하다.
- 팀 프로젝트에서 팀원들과의 관계를 유지하는 소프트스킬 역량에도 관심을 가져야한다.
- 무언가를 버릴 수 있는 용기를 갖기가 굉장히 어렵다.
- 모든 것을 다 하는 것은 어렵지 않다 그냥 다 하면 된다.
- 하지만 내가 아직 그것을 할 준비가 안되었는데 그 다음 단계를 끌어다 미리 하려고 한다면 오히려 더 힘들어지고 느려진다.
- 반드시 현재 위치에서 할 수 있는 것들을 하자.
- 포비가 네이버에서 일할 때 챗 지피티 나오면서 프로그래머를 대체할 것이다. 이런말이 나왔었다.
- 15년 전 네이버에서도 웹 페이지를 만드는데 들어가는 개발자 비용을 줄이기 위해 단순 컴포넌트를 끌어다 쓰는 툴을 개발해 비용을 줄여보려고 했다.
- 하지만 사용자의 요구가 다양한데 이걸 컴포넌트 베이스로 만드는게 적합할까? 라는 생각을 했다.
- 그 때 팀장이었는데 뜻이 맞는 사람들을 모아서 규탄하는 메일을 보낸 적이 있다.
- 서비스를 개발하는 개발자인 우리가 곧 전문가이고 잘못된 것이라는 생각이 든 부분에 대해서는 반드시 목소리를 낼 줄 알아야 한다.
- 현장을 떠나게 되면 좋은 것만 보려고 하고 시야가 좁아질 수 있다.
- 위에서 시키니까 맹목적으로 따르는게 항상 옳은 것은 아니다.
- 만약 그랬다고 잘린다면 그냥 다른 회사 가는게 더 낫겠다는 마인드로 던져야 한다.
- 용기를 가지고 행동하다보면 남들의 인정을 받을 기회는 반드시 오게된다.
- 코로나로 인해 수요가 폭발적으로 늘었다가 줄어드는 것처럼 보이지만 여전히 많은 것은 사실이다.
- 상당기간 수요는 유지될 전망이다.
- SI 진행하던 기업들이 핵심 업무에 대해 인하우스 개발이 늘어나면서 수요는 더 증가하고 있다.
- 공공서비스 이런거 사용해보면 엄청 구리고 불편하지 않나. 사설 서비스와 비교해봤을때 격차가 엄청 벌어지고 있다.
- 금융권,제조업, 공공 등 여러 분야에서 기존과 다른 혁신적 시도를 해보려하지만 좋은 개발자 구하기가 어려워지고 있다.
- 네카라쿠배 가는 것만이 성공인가? 내가 잘하는 부분 좋아하는 부분과 맞는 회사를 들어가 즐겁게 잘 일할 수 있는게 중요항 것 아닐까?
- 모두가 뜯어 말리는 방향이 자신에게는 맞을 수 있다.
- 무엇인가에 도전할 때 스스로 할 수 있는 가장 작은 일부터 시작하자.
- 남들이 당연시 생각하는 것에 의문을 던지고 다르게 행동할 수 있는,
- 편한 바운더리를 벗어나 위험한 곳으로 뛰쳐나갈 수 있는,
- 권위에 도전할 수 있는 용기가 필요하다.
- 나는 어떤 사람인지 한 문장으로 정의해보자.
  - 성장을 공유하는 사람이 되고 싶다.
- 권위에 도전하는 게 어려울 때는 어떻게 시작해보면 좋을까요?
  - 책을 읽을 때 처음부터 끝까지 읽는 것이 기존 방식이라면
  - 이번에는 미션을 진행하면서 모르는 부분이 나오면 찾아보는 방식을 취해보자
  - 이렇게 해보다가 잘 안된다면 주변 사람들에게 물어보자
  - 그러다 안되면 때려치고 나중을 기약하자. 뭔가를 시도하고 실패하는 것에 의미를 크게 두지 말자.
  - 경험을 통해 배움을 얻어가려고 하면 좋을 것 같다.
  - 평소처럼 살다가 동의되지 않는 어떤 것을 맞닥뜨리는 순간이 오면 그 때 도전하면 된다.
- 기존 교육에 묻혀버린 개성을 발견하거나 본인만의 세계관을 찾기 위한 좋은 노력이 있을까요?
  - 인문학, 철학과 관련된 내용이다.
  - 프로그래밍이 일정 정도 학습이 되었다면 내가 왜 프로그래밍을하는지, 어떤 프로그래머가 되려고 하는 것인지 생각해볼 필요가 있다.
  - 스스로를 성찰해보는 시간을 가져보자.
- 모난 돌이 정을 맞게 되는데 이럴 때 느낀 패배감, 좌절감을 같이 공유할 수 있는 사람들을 찾는 것이 중요하다.
  - 이런 감정을 얘기하는 것이 프로답지 못하다고 생각하는 사람들이 많다.
  - 기존의 강인한 성공모델 즉 기존 사회의 권위주의적인 모습이다.
  - 오히려 이런 감정들을 주변과 얘기하면서 다시 도전할 용기를 얻는 것이 더 프로답지 않을까?
- 우리 사람은 환경에 대해 영향을 많이 받는다.
- 그렇기 때문에 주변 환경을 정리하는 것이 중요하다.
- 부족한 것을 최대한 빠르게 드러내자.
- 모르는 것을 모른다고 얘기하자
- 아무래도 성적과 같은 명확한 지표가 없다 보니 현재 자신의 수준이 어느 정도인지 판가름하기가 힘듭니다. 자신의 수준을 파악할 수 있는 좋은 팁이 있을까요?
  - 모르는 것을 그냥 넘어가지 말고 의견을 제시하고 질문을 던져야 한다.
- 모르는 것을 얘기했을 때 부끄럽지 않고 자연스러운 모임을 만들어보자.
- 

































