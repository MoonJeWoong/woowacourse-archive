# 레벨 1 - 3주차 (23.02.20 ~ 23.02.26)

---

# 23.02.20

## 2단계 미션 진행
- TDD를 진행하면서 일급 컬렉션에 대한 테스트 코드를 구현할 때는 요소 값 클래스에 대한 테스트도 같이 진행해줘야 한다.
  - Results 클래스에 대해 TDD를 진행하다보니 Results 내부 컬렉션 요소 값이 Result가 아니라 String으로 구현되었음에도 틀린부분을 생각해내기 힘들었다.
  - 따라서 Results 클래스에 Result 클래스에서 예외 처리되는 테스트를 한 번 더 진행하는 것으로 해결.

- 입력 값이 형식에 맞게 들어왔는지 확인하고 Wrapper 객체들을 만들어서 반환해주는 역할을 하는 클래스가 일급 컬렉션일까?
- 단지 클래스 속성 값으로 컬렉션 하나만 존재한다고 일급컬렉션이라고 생각하지 말자...
- Names : 일급 컬렉션이 아닌데 일급 컬렉션처럼 취급하려고 하니까 값 반환 문제로 골머리를 썩었다.
~~~ java
public class Names {
    private static final String NAMES_DELIMITER = ",";

    private final List<Name> names = new ArrayList<>();

    public Names(String inputNames) {
        splitInputNames(inputNames).stream()
                .map(String::strip)
                .forEach(name -> names.add(new Name(name)));
    }

    public Name getName(int index) {
        return names.get(index);
    }

    public List<String> getValues() {
        return names.stream()
                .map(Name::getValue)
                .collect(Collectors.toList());
    }

    public int size() {
        return names.size();
    }

    private List<String> splitInputNames(String inputNames) {
        return Arrays.asList(inputNames.split(NAMES_DELIMITER));
    }
}
~~~

- Results : Results 클래스도 마찬가지. 입력값을 받아 Result 들을 생성해서 넘겨주는 역할.
~~~ java
public class Results {
    private static final String WRONG_SIZE_RESULTS_ERROR = "[ERROR] 사다리 게임 결과 값의 개수는 전체 사람의 수와 동일해야 합니다.";
    private static final String RESULTS_DELIMITER = ",";

    private final List<Result> results;

    public Results(int playersSize, String inputResults) {
        List<String> results = splitInputResults(inputResults);
        validateRightResultsSize(playersSize, results);
        this.results = results.stream()
                .map(Result::new)
                .collect(Collectors.toList());
    }

    public List<String> getValues() {
        return results.stream()
                .map(Result::getValue)
                .collect(Collectors.toList());
    }

    private void validateRightResultsSize(int playersSize, List<String> results) {
        if(results.size() != playersSize) {
            throw new IllegalArgumentException(WRONG_SIZE_RESULTS_ERROR);
        }
    }

    private List<String> splitInputResults(String inputResults) {
        return Arrays.stream(inputResults.split(RESULTS_DELIMITER))
                .map(String::trim)
                .collect(Collectors.toList());
    }
}
~~~

- 그러면 이 두 클래스의 공통점은 입력값을 받아 검증을 거친 후 Wrapper 객체를 만들어준다.
- 팩토리 패턴이라는 것을 사용해야 할 것 같은데 정확한 개념이 맞는지 물어보자...!
- 팩토리 패턴을 사용한 클래스에서 검증 로직을 수행해도 괜찮은가...?
- 현재 사용한 Names, Results 팩토리 클래스를 그냥 InputView에게 책임을 위임하는 것이 옳을까?
  - 그런 경우라면 입력되는 Result 개수는 플레이어의 수와 동일해야 함을 검증하는 로직도 inputView로 같이 넘어가는데 괜찮을까?


# 23.02.21

## 예외처리
- 자바 Exception
- Exception도 상속 구조를 가지고 있다.
- 각 단계는 무슨 차이가 있는지 고민해보자
- checked unchecked 차이는 컴파일 타임에 에러 발생 여부를 체크 하는지의 차이이다.
- RuntimeException은 unchecked이다 즉 런타임에 체트된다.
- 왜 이렇게 checked, unchecked 로 나눠놨을까? 선택방법이 정리된 것은 매우 애매하다...
- 런타임에 생길 수 있는 문제를 해결하기 위함이 아닐까?
- 컴파일 타임에 미리 알수 있는 예외를 해결하기 위함이 checked이지 않을까?
- 언어가 개발되면서 사람의 생각들은 계속 바뀌고 있다. 대다수의 언어에서 checked exception은 사라지고 있다. 오히려 코드가 지저분해지는 문제가 있을 수 있다. 코틀린에는 없다...
- 런타임 익셉션은 컴파일 시점에 예외가 발생할 지 알 수 없다.
- 둘 다 기능은 같은데 시점만 다른 것
- 어떤 메소드 내에서 이런 에러가 발생할 수 있다는 것을 어떻게 전달할 수 있을까?
  - checked Exception이 어떤 문서나 코드를 직접 읽지 않고도 제일 의도를 잘 전달할 수 있는 방법이 아닐까?
  - throws를 메서드에 붙여서 외부로 넘겨도 결국 처리하는쪽에 달려있다. -> 이게 핵심 포인트
  - 허브 : Checked exception을 사용한다면 코드를 안정적이게 작성할 수 있지만, 네오의 코드를 가져다 사용하는 입장에서는 불편함이 증가할 것 같아요. (스트림 사용 불가, 예외 전환과 같은 throws 처리)
  - 누누 : 대부분의 코드에서 throws 가 붙었을 경우에, 어느 한사람이라도 귀찮아서 throws Exception 을 하게 되면 상위계층에서 이를 제대로 확인하는 의미가 없어지기에, 지저분해지기만 할 수도 있을 것 같아요
  - 후추 : Checked Exception이 안정성을 완벽히 보장하는 것도 아닌 것 같습니다. 결국 사용하는 쪽에서 예외처리를 어떻게 하느냐에 달려 있기 때문입니다.
  - 로이스 : checked Exception으로 메서드 작성자의 의도를 전달하며 강제할 수 있는데, 과연 외부에서 해당 예외를 작성자의 의도대로 처리하는 가에 대한 의문이 있을 것 같습니다.
- 문법적인 내용은 나중에 간단하게 보고 넘길 수 있도록 하자.
- 예외처리를 어떻게 잘 활용할 수 있을까?
  - 복구 : 작성하는 코드에 문제가 생겼을 때 정상 상태로 돌려놓는다. 논리적인 사용 방법
  - 회피 : 예외 처리의 책임을 다른 곳으로 돌리는 것. 회피를 할때는 많은 고민 후 결정한다.
  - 무시 : 무시를 하는 경우는 더 많은 고민이 필요하다. 무시를 의도에 맞게 사용하는 경우도 생각보다 많다.
  - 전환 : checked -> unchecked exception으로 전환할 수 있다. 예제처럼 DBException이 해당계층에서 처리되는게 아니라 도메인까지 넘어가버리면 안되기 때문에 적절한 선에서 끊어주는 역할도 있다.
  - 추상화계층?
    - 뷰가 있고 도메인이 있는데 도메인에서 뷰를 사용하지 말라고 한다.
    - 그 이유가 뭘까?
    - 도메인은 우리의 밥벌이이다. 즉 잘 지켜줘야 하는 부분이다. 잘 숨겨줘야 하는데 뷰는 변화가 굉장히 많은 곳이기 떄문에 뷰의 영향을 도메인이 받으면 안된다.
    - 블루컬러 관점에서 봤을 떄 도메인이 더 중요하다.
    - 뷰가 있고 도메인이 있으면 계층이 존재할 것이다. 뷰,도메인,데이터저장영역 등을 나눠서 사용하게 될텐데...
    - 뷰 영역이 도메인, 데이터 영역에 침범하지 않도록 해줘야 한다. 그 반대로 다른 영역들도 마찬가지이다.
    - 그래서 각 부분에 대해 추상화계층을 만들어서 잘 분리하는 것이 좋다.
    - 코드에서 목적에 맞게 분리하는 것이다.
    - 계층이 나눠지면 소통할 때는 어쨋든 왔다갔다 해야하는데 그런 부분을 잘 생각하고 설계해줘야 하는 부분이 추상화 계층이다. (어려운 개념이다..)
    - 어떠한 부분까지 알게할 것인가... 
    - (내가 내린 결론) 서로 다른 두 계층 간 의존성을 분리하기 위해 두 계층 사이에서 오고가는 메세지를 중개할 수 있도록 하는 역할의 계층을 추상화 계층이라고 한다.
      - 즉 두 계층이 서로 메세지를 주고받기 위해 해야하는 일을 정확하게 명시해주는 계층을 추상화 계층이라고 할 수 있을 것 같다.

## 리스트 이해하기
- 꼭 그림으로 그려가보면서 진행해보자.
- 낯선 개념을 학습할 때 어떻게 동작하는지 이해하기 편한 방법이다.

## 사다리 미션 2단계
- 출력을 위한 getter를 구현해두고 해당 객체의 속성값이 일치하는지 판단하는 메서드는 따로 만드는 것이 옳은가?
  - 예를 들어 주어진 Name 값이 Player의 Name인지 확인하는 isPlayerName() 메서드를 구현해 참/거짓 값을 반환한다.
  - 위 경우처럼 구현하면 객체에 메세지를 던지는 좋은 케이스가 되겠지만... 출력을 위한 getter가 있어서 다른 개발자는 getter를 사용해버린다면...?
  - 처음 의도했던 대로 메서드들이 사용되지 못할 것 같은데 이런 경우는 어떻게 하는 것이 좋은지?
  - => 뷰가 도메인에 의존하면 된다. 뷰에서 VO / Wrapping 객체를 벗겨내주자...(맞나?)

- 이름에 대한 String 원시 값을 포장한 Name 객체간의 비교에서 equals와 hashCode 메서드를 오버라이딩 했다가 리뷰를 받고 삭제했었습니다.
- 그런데 레벨2를 진행하다 보니 Name간 객체 비교를 해야하는 경우가 생겼습니다.
- 일단은 동일한 타입 객체를 인자로 받아 내부 속성값들을 비교하여 참 거짓을 반환하는 메서드를 정의하여 해당 기능을 수행하도록 했습니다.
- 그렇다면 예전에 한 것처럼 equals와 hashCode를 재정의하는 방법이 아니라 객체 내부에서 직접 값을 비교해주는 메서드를 구현해주는 것이 더 나은 방법인지...
- equals와 hashCode를 재정의해야 하는 상황이 따로 존재하는 것인지 궁금하다.
  - 현재 알고있는 것으로는 HashMap 등 사용자 정의 객체를 자료구조를 통해 관리하려고 할 때 재정의해줘야 한다는 것 정도로만 알고있다.

- 단순 Wrapper 클래스와 VO의 차이 
  - [레퍼런스](https://livenow14.tistory.com/37) 
  - [equals와 Hashcode는 언제 재정의 해야 하나](https://wisdom-and-record.tistory.com/114)

- 사다리 라인을 따라 플레이어의 위치를 바꾸는 역할은 누가 수행해야 할까?
  - 당연히 Player 객체들을 요소값으로 갖고 있는 Players에서 하는 게 자연스럽지 않나?
  - 뭐가 문제가 되지 그러면?
    - Position 값을 wrapping하는 클래스 하나 구현
    - Player 클래스 속성값으로 position값 추가
    - 그렇게 했을 떄 swap 기능은 어떻게 할건데?
    - 각 Player가 갖고 있는 position 값을 확인한 후 해당 플레이어끼리 position 교체
    - 에휴... 이러고 구현 들어가는 게 TDD가 맞아??

- Weapping 클래스에 대해서도 출력을 위한 getter를 지양하고 메세지를 던지려 노력하는 것이 맞는 것인지?
  - 맞다고 판단하고 출력을 제외한 비즈니스 로직 쪽에서는 최대한 wrapper 클래스에게 메세지를 던져 해결하는 것으로 결론내림
  - 왜냐하면 그냥 getter로 원시값을 내 줘 버리면 wrapping한 의미가 없어지기 때문에
  - 불가피한 경우는 출력을 위함 밖에 없다...고 생각하자.

- Ladder 클래스가 Players 클래스에게 던져줘야 하는 메세지는 무엇인가?
- 실질적으로 따져보면 List<Boolean> 컬렉션이 필요하다.
- 그러나 현재 Players 클래스가 필요한 List<Boolean>은 Ladder 내부의 Line 객체로 Wrapping 되어 있다.
- 그러면 Ladder 클래스에서 Line을 그대로 넘겨줄 것이 아니라 내부의 List<Boolean> 값을 꺼내서 넘겨줘야 하나?
- 아니면 Line을 그대로 넘겨줘서 Players 클래스에서 List<Boolean> 을 직접 꺼내도록 해야하나?
- 디미터의 법칙은 내가 다루는 객체의 속사정을 몰라야 한다.
- 그런데 Line을 그대로 전달하면 결국 Line 내부의 속성값을 Players가 알아야만 하기 때문에 getter를 사용한 이후 List<Boolean>을 사용하게 된다.
- 이 경우 Players 클래스의 메서드 인자로 넘겨받은 매개변수의 메서드만 사용 가능하다. 그러나 위의 경우는 디미터의 법칙을 깨뜨린다.
- 그렇기 때문에 Line을 그대로 넣어줄 것이 아니라 Line 내 List<Boolean>을 꺼내서 넘겨줘야 한다.

- TDD를 진행하면서 가장 머리 아팠던 문제 : 이렇게 테스트 코드를 구현하면 나중에 안쓸것 같은 메서드 혹은 getter를 사용해 테스트해야 될 것 같은데...? 어떻게 해야하지...?
  - 일단 테스트코드를 짜자. 그리고 리팩토링하자
  - 이후 메서드 접근제어자가 private화 된다면 해당 테스트 코드는 Disabled 처리하면 되지 않을까?
  - 그리고 해당 메서드를 사용하는 다른 public 메서드를 테스트 함으로써 넘어갈 수 있도록 하자.

- 결국 도메인/모델 쪽에서는 VO/Wrapping 클래스를 사용하여 로직을 수행하도록 하고 모든 원시값 getter는 view에서 도메인에게 의존하는 것으로 변경

- 왜 equals와 hashcode를 바로 구현하면 안될까?
- 


# 23.02.22

- 교육을 슬기롭게 소화하기 위한 몇 가지 이야기
- 프로그래머로 취업하기 위해 몇 가지 과정을 거치게 될텐데 어떻게 하면 프로그래밍을 즐기면서 살아갈 수 있는지 제시해보고자 한다.
- 교육이라는 것은 생겨난지 100년도 채 안된 학문이다.
- 그래서 당연시 알고있던 것들이 사실이 아닐 수도 있다는 것이다.
- 권위있는 사람들이 하는말을 맹목적으로 믿어서는 안된다.
- 자신감이 바닥으로 다시 떨어져서 유지되는 기간을 슬기롭게 잘 이겨내는 것이 중요하다.
- 자신감 그래프가 이렇게 그려지는 이유는 초보자들을 위한 자료는 엄청나게 많다.
- 전문가들을 위한 글도 생각보다 많다.
- 하지만 이 사이 구간에 해당하는 학습자료는 많지 않다.
- 또한 학습할 지식의 범위 또한 이 구간에서 급격히 늘어나게 되어있다.
- 내가 잘하고 있나? 잘못된 방향으로 가고 있는 것 아닌가? 생각하기 쉽다.
- 우리는 이 구간은 슬기롭게 이겨내고 자신감이 다시 차오르는 그 구간에서 취업하게 될 것이다.
- 만약 우리가 모든것을 완벽하게 끝내고 취업하고자 한다면 취업하기는 힘들다는 것을 반드시 기억하자.
- 잘하는 크루들만 보기 때문에 힘들어지는 것.
- 항상 과거의 내 모습보다 더 나아졌는가만 생각하자.
- 경쟁의식을 버리는 것을 꾸준히 의식하자.
- 힘들 때, 자존감이 떨어질 때 데일리 미팅 얘기, 코치들 면담 신청하기
- 남들이 스터디를 많이한다... CS 공부한다... 이렇게 휘둘러지게 되면 더 힘들어진다.
- 자신만의 학습법과 방향을 흔들리지 않고 꾸준하게 준비하는 것이 중요하다.
- 팀 프로젝트에서 팀원들과의 관계를 유지하는 소프트스킬 역량에도 관심을 가져야한다.
- 무언가를 버릴 수 있는 용기를 갖기가 굉장히 어렵다.
- 모든 것을 다 하는 것은 어렵지 않다 그냥 다 하면 된다.
- 하지만 내가 아직 그것을 할 준비가 안되었는데 그 다음 단계를 끌어다 미리 하려고 한다면 오히려 더 힘들어지고 느려진다.
- 반드시 현재 위치에서 할 수 있는 것들을 하자.
- 포비가 네이버에서 일할 때 챗 지피티 나오면서 프로그래머를 대체할 것이다. 이런말이 나왔었다.
- 15년 전 네이버에서도 웹 페이지를 만드는데 들어가는 개발자 비용을 줄이기 위해 단순 컴포넌트를 끌어다 쓰는 툴을 개발해 비용을 줄여보려고 했다.
- 하지만 사용자의 요구가 다양한데 이걸 컴포넌트 베이스로 만드는게 적합할까? 라는 생각을 했다.
- 그 때 팀장이었는데 뜻이 맞는 사람들을 모아서 규탄하는 메일을 보낸 적이 있다.
- 서비스를 개발하는 개발자인 우리가 곧 전문가이고 잘못된 것이라는 생각이 든 부분에 대해서는 반드시 목소리를 낼 줄 알아야 한다.
- 현장을 떠나게 되면 좋은 것만 보려고 하고 시야가 좁아질 수 있다.
- 위에서 시키니까 맹목적으로 따르는게 항상 옳은 것은 아니다.
- 만약 그랬다고 잘린다면 그냥 다른 회사 가는게 더 낫겠다는 마인드로 던져야 한다.
- 용기를 가지고 행동하다보면 남들의 인정을 받을 기회는 반드시 오게된다.
- 코로나로 인해 수요가 폭발적으로 늘었다가 줄어드는 것처럼 보이지만 여전히 많은 것은 사실이다.
- 상당기간 수요는 유지될 전망이다.
- SI 진행하던 기업들이 핵심 업무에 대해 인하우스 개발이 늘어나면서 수요는 더 증가하고 있다.
- 공공서비스 이런거 사용해보면 엄청 구리고 불편하지 않나. 사설 서비스와 비교해봤을때 격차가 엄청 벌어지고 있다.
- 금융권,제조업, 공공 등 여러 분야에서 기존과 다른 혁신적 시도를 해보려하지만 좋은 개발자 구하기가 어려워지고 있다.
- 네카라쿠배 가는 것만이 성공인가? 내가 잘하는 부분 좋아하는 부분과 맞는 회사를 들어가 즐겁게 잘 일할 수 있는게 중요항 것 아닐까?
- 모두가 뜯어 말리는 방향이 자신에게는 맞을 수 있다.
- 무엇인가에 도전할 때 스스로 할 수 있는 가장 작은 일부터 시작하자.
- 남들이 당연시 생각하는 것에 의문을 던지고 다르게 행동할 수 있는,
- 편한 바운더리를 벗어나 위험한 곳으로 뛰쳐나갈 수 있는,
- 권위에 도전할 수 있는 용기가 필요하다.
- 나는 어떤 사람인지 한 문장으로 정의해보자.
  - 성장을 공유하는 사람이 되고 싶다.
- 권위에 도전하는 게 어려울 때는 어떻게 시작해보면 좋을까요?
  - 책을 읽을 때 처음부터 끝까지 읽는 것이 기존 방식이라면
  - 이번에는 미션을 진행하면서 모르는 부분이 나오면 찾아보는 방식을 취해보자
  - 이렇게 해보다가 잘 안된다면 주변 사람들에게 물어보자
  - 그러다 안되면 때려치고 나중을 기약하자. 뭔가를 시도하고 실패하는 것에 의미를 크게 두지 말자.
  - 경험을 통해 배움을 얻어가려고 하면 좋을 것 같다.
  - 평소처럼 살다가 동의되지 않는 어떤 것을 맞닥뜨리는 순간이 오면 그 때 도전하면 된다.
- 기존 교육에 묻혀버린 개성을 발견하거나 본인만의 세계관을 찾기 위한 좋은 노력이 있을까요?
  - 인문학, 철학과 관련된 내용이다.
  - 프로그래밍이 일정 정도 학습이 되었다면 내가 왜 프로그래밍을하는지, 어떤 프로그래머가 되려고 하는 것인지 생각해볼 필요가 있다.
  - 스스로를 성찰해보는 시간을 가져보자.
- 모난 돌이 정을 맞게 되는데 이럴 때 느낀 패배감, 좌절감을 같이 공유할 수 있는 사람들을 찾는 것이 중요하다.
  - 이런 감정을 얘기하는 것이 프로답지 못하다고 생각하는 사람들이 많다.
  - 기존의 강인한 성공모델 즉 기존 사회의 권위주의적인 모습이다.
  - 오히려 이런 감정들을 주변과 얘기하면서 다시 도전할 용기를 얻는 것이 더 프로답지 않을까?
- 우리 사람은 환경에 대해 영향을 많이 받는다.
- 그렇기 때문에 주변 환경을 정리하는 것이 중요하다.
- 부족한 것을 최대한 빠르게 드러내자.
- 모르는 것을 모른다고 얘기하자
- 아무래도 성적과 같은 명확한 지표가 없다 보니 현재 자신의 수준이 어느 정도인지 판가름하기가 힘듭니다. 자신의 수준을 파악할 수 있는 좋은 팁이 있을까요?
  - 모르는 것을 그냥 넘어가지 말고 의견을 제시하고 질문을 던져야 한다.
- 모르는 것을 얘기했을 때 부끄럽지 않고 자연스러운 모임을 만들어보자.

# 23.02.23

안녕하세요 코다! 히이로입니다.
이번 2차 미션을 진행하면서 집중했던 부분은 다음과 같습니다.

- VO 객체들간 필요한 연산은 내부 원시값을 외부로 반환하여 처리하는 것이 아니라 VO 객체 간 협력을 통해 수행할 수 있도록 한다.
- VO 객체들은 도메인 / 비즈니스 로직 측면에서 사용될 때 내부 Wrapping 값을 반환하지 않는다.
- VO 객체의 Wrapping 값은 View에서 출력을 위한 목적으로만 unWrap 할 수 있다.
  - 즉 VO 객체들의 unWrap 책임은 view에서 담당한다.

이외에 미션을 진행하며 궁금증이 들었던 부분들은 코드에 직접 명시하였습니다.

별개로 코드에 직접 달기 애매한 질문이 있어 따로 남깁니다.

TDD 방식으로 이번 미션을 진행하다보니 기능이 구현되지 않은 상태에서 해당 기능을 어떻게 검증해야 할지가 굉장히 궁금했습니다.
특히 객체 내부 상태 값을 조작하는 기능을 테스트하고자 할 때 많이 고민되었던 것 같습니다.
단순하게만 생각한다면 getter 메서드를 사용하고 assertThat 구문을 사용하면 간단합니다.
그런데 만약 해당 객체가 출력을 위한 getter 구현 의무가 없다고 한다면 해당 getter 메서드는 오로지 테스트만을 위해 존재하게 된다고 생각이 들었습니다.
하지만 TDD는 최대한 빠르게 실패하는 테스트를 만들고 이를 통과시키기 위한 코드를 작성하는 것이 핵심인데 이런 부분은 어떻게 생각하며 진행하는 것이 좋을지 의견을 구하고 싶습니다!

# 23.02.24

## 사다리 게임 피드백
- 어떠한 방식으로 접근할 것인가?
- 인아웃, 아웃인 접근 방식
  - 처음 요구사항을 받았을 때 아무 지식이 없다. 그래서 큰 그림으로 볼 수 밖에 없다.
  - 맨처음 도메인 지식이 없어 작은 단계를 뽑아낼 수 없으므로 아웃인을 채택하는 경우가 크다.
  - 하지만 도메인 설계하고 파악하는 능력이 뛰어난 사람들은 어떤 부분을 객체로 분리할 지 아는 사람들도 있다.
- TDD로 하다보면 아웃인방식이 굉장히 어렵다.
- 하지만 인아웃방식을 채택하더라도 가장 작은 단위의 객체를 찾는 것이 쉽지 않다.
- 아웃인 방식으로 일단 할 수 있는 만큼 그냥 설계를 해본다.
  - 요구사항을 분석한다.
  - 의존성이 없는 객체부터 설계를 시작하는 것이 테스트하기도 쉽다는 것을 기억하자.
  - 의존성이 없는 객체가 곧 가장 작은 단위의 객체가 될 가능성이 높지 않을까? 개인적인 생각
- 래더게임 클래스를 만든다.
- 어떤 기능을 먼저 만들어야 하지?
- 라인을 먼저 만들어야 할 것 같다.
  - line클래스 생성
  - 테스트 클래스 작성
  - line을 생성하는데 line은 무엇으로 이뤄져 있지?
  - line이라는 객체 테스트를 작성하다가 point라는 더 작은 객체를 찾아낸다.
  - 기존 작성하던 Line 테스트 코드가 깨졌는데 그걸 그냥 놔두고 point를 구현하러 가는 경우가 많다.
  - 그러면 나중에 할게 더 많아지기 때문에 아예 깨진 테스트 코드를 지우고 작은 객체에 대한 테스트를 작성 완료하고 다시 작성하는 것이 좋다!
  - 한 번 작성해봤기 때문에 더 쉽게 작성할 수 있기 때문이다.
  - laddergame -> line -> point 이런식으로 연쇄적으로 부채가 쌓이게 된다.
    - 이렇게 하면 큰 틀이 잡힌 상태로 작은 것을 구현하게 되고 실시간으로 레거시를 만드는 것과 동일한 것이다.
    - 작은 단위부터 시작하는 것은 하나의 개념으로 독립적으로 생각할 수 있기 때문에 그렇게 시작하는 것인데
    - 위처럼 하면 포인트를 구현하며 라인, 레더게임 클래스를 계속 생각하게 된다. 
    - 포인트를 설계할 때는 포인트 하나만 봤을 때 완벽하게 존재하는 것이 맞다.
    - 설계하고나니 Line 객체만 가져다 쓸 수 있게 맞춰진 객체를 설계하게 된다면 그것은 잘못 설계되는것이다.
    - 그래서 처음에 바깥에서 안으로 개념을 찾아가며 구현하다가 안쪽의 가장 작은 개념을 찾으면 다시 거기부터 인아웃으로 개발을 시작하면 된다.
    - (바깥) 레더게임 - 라인 - 포인트 (내부)
    - 상위의 개념은 그저 작은 단위를 찾기 위한 과정에 불과한것이다.
    - 상위의 개념을 작은 단위에 맞게 다시 수정해도 되지 않나요?
      - 막 만드는 중에는 리팩토링 하는 것보다 오히려 삭제하고 나중에 다시 만드는 것이 쉬울때가 많다.
    - 중요한 것은 상위개념이 하위개념으로 인해 바뀌는 것에 거부감을 느끼지 않고 수정할 수 있는 것이 중요하다.
    - 상위개념이 하위개념 구현의 발목을 잡으면 안된다!!
- 테스트 코드를 리팩토링 할 때 기존 테스트 코드가 돌아가지 않는 상태에서 리팩토링 하면 안된다!

## 포수타
- 발표 연습
  - 10명 초반대 모아서 소통하며 편해지고 나니 내가 실수하는 것을 보여줘도 된다는 편안함이 생겼다.
  - 너무 크게 시작하려고 하지 말고 작게 시작해서 점점 키워가보는 방식으로 해보는 것이 어떠한가

## 자바의 Pass By Value / Pass By Reference ??
- [레퍼런스](https://mangkyu.tistory.com/106)
- [C++ 레퍼런스](https://boycoding.tistory.com/217) : 변수에 대한 참조는 변수 자체와 똑같이 취급되므로 참조에 대한 모든 변경사항은 인수에도 적용된다.
- 함수의 파라미터로 변수를 넘겨주어야 하는 상황 (파라미터 전달 방식)
- 각 언어마다 변수를 넘겨주는 방법이 다르다.
  - 크게 Pass By Value와 Pass By Reference로 나뉘어진다.
- 변수를 선언한다는 것은 메모리를 할당한다는 것을 의미한다. (특정 메모리 주소에 이름을 붙인다.)
- 변수 선언을 위해 할당되는 메모리로는 크게 스택과 힙이 있다.
  - 스택에는 지역변수(메서드 내에 선언된 변수) / 매개변수 등이 할당
  - 힙에는 인스턴스 변수 또는 객체등이 할당
- 지역변수 : 원시타입
  - 스택 영역에 실제 값들이 저장되는 것
- 지역변수 : 참조타입
  - heap 영역에 실제 값 할당
  - heap 영역에 할당된 메모리 주소가 Stack영역에 저장
  - 레퍼런스에서 나온 예시는 배열임
    - stack 영역에 배열의 시작 주소가 저장되고 배열은 각 주소 값이 연속적으로 할당된다.
    - 연속적으로 할당된 공간마다 배열 요소 타입 인스턴스를 가리키는 메모리 주소 값이 저장된다.
    - 이 때 실제 저장되는 인스턴스 메모리 주소 값은 무작위로 할당된다.
    - 배열의 요소값을 저장하기 위해 연속적으로 할당되는 배열 메모리 주소 값과
    - 그 안에 값으로서 저장되는 인스턴스의 메모리 주소 값은 다른 것임을 명심하고 헷갈리지 말자.

- Pass By Value / Pass By Reference 차이가 뭔데 그래서 도대체?
- pass By Value 방식은 객체를 매개변수로 넘길 때 저장된 주소 값을 복사해서 넘겨준다.
  - 그러면 넘겨받은 새로운 변수명은 기존 변수와 별개로 복사된 주소 값을 저장한다.
  - 이후 새로운 변수를 통해 복사된 주소 값을 참조하여 객체에 대한 작업을 수행할 수 있다.
  - 그러나 새로운 변수에 new 를 통해 새로운 인스턴스를 생성하여 저장하려고 하면 기존 인스턴스는 바뀌지 않는다.
  - 그저 새로운 변수에 새롭게 생성된 객체의 새로운 주소가 저장되어 기존 인스턴스와 완전히 별개의 것이 될 뿐이다.
- pass By Reference 방식은 객체를 매개변수로 넘길 때 새로운 변수가 기존 변수와 똑같은 역할을 수행할 수 있도록 만든다.
  - 즉 pass By Value 처럼 주소 값을 복사해서 넘겨주는 과정이 전혀 없다.
  - 또한 새로운 변수는 기존 변수와 완전히 동일한 상태가 된다.
  - 그래서 새로운 변수를 통해 기존 객체에 대한 작업을 수행할 수 있다.
  - 그리고 새로운 변수를 통해 새로운 인스턴스를 생성하여 저장한다면 기존 변수도 새로운 인스턴스를 가리키게 된다.

- 사실 pass By Reference는 자바에는 존재하지 않는 개념이다.
- 그렇기 때문에 자바라는 언어의 관점에서 Pass By Reference를 이해하려고 하는 것은 없는 상황을 그려보는 것이기 때문에 굉장히 어렵다.
- 위에서 언급한 Pass By Reference의 개념또한 C++의 관점에서 작성한 것이다.
- 그러므로 자바가 Pass By Value 방식으로 값을 넘겨준다는 것을 이해하는 것이 중요하다.


# 23.02.25

## 사다리 게임 2차 미션 피드백
- Name, Result 객체를 생성하는 책임을 갖는 클래스
  - 처음에는 Names, Results 클래스들로 일급 컬렉션으로 구현했었다. 하지만 입력 값이 형식에 맞게 들어왔는지 확인하고 Wrapper 객체들을 만들어서 반환해주는 역할을 하는 클래스가 일급 컬렉션일까? 라는 의문이 들었다.
  - 그래서 VO 객체들을 생성하여 반환하는 Factory 클래스로 리팩토링하였다.
  - 이에 대해 리뷰어 코다는 아래와 같이 질문을 줬다.
    - 팩토리 클래스는 어떤 역할을 담당하며 왜 사용하는 건가요?
    - 지금 구현하신 팩토리 클래스의 역할은 model과 view 중 무엇에 더 가까운가요?
    - 팩토리 클래스에 대한 정의는 무엇이고 그에 따른 팩토리 클래스의 역할은 무엇일까요?
  - 참고한 레퍼런스
    - https://bcp0109.tistory.com/367
    - https://dev-youngjun.tistory.com/195
  - 팩토리 클래스는 어떤 역할을 담당하며 왜 사용하는 건가요?
    - 팩토리 클래스는 객체를 생성하는 책임을 담당하는 클래스를 의미합니다.
    - 팩토리 패턴을 사용하는 방식에는 팩토리 메서드 패턴과 추상 팩토리 패턴이 존재합니다.
      - 팩토리 메서드 패턴은 어떤 객체를 생성하는 책임을 수행하는 팩토리 클래스를 추상화하고 해당 팩토리 클래스(슈퍼클래스)에서 어떤 타입의 객체를 생성하는지는 하위 팩토리 클래스(서브클래스)가 결정하도록 위임하는 방식을 말합니다.
      - 추상팩토리 패턴은 생성하는 객체들 중 연관되는 객체들을 모아서 생성할 수 있도록 추상화된 팩토리 클래스(슈퍼클래스)에 이를 명시하고 연관된 객체들의 타입을 결정하여 실제 생성하는 책임은 하위 팩토리 클래스(서브클래스)가 결정하도록 위임하는 방식을 말합니다.
      - 즉 추상팩토리 패턴은 팩토리 메서드 패턴을 사용하는 방식입니다.
    - 단순하게 팩토리 클래스가 어떤 객체를 생성하는 책임을 가지는 클래스라는 관점에서 봤을 떄는 지금 구현한 방식이 맞습니다.
    - 하지만 팩토리 패턴이라는 것을 학습한 결과 생성하고자 하는 객체의 생성부를 캡슐화하여 결합도를 느슨하게 하고 구체적인 객체 타입에 의존하지 않도록 하는 것임을 알았습니다.
    - 이런 관점에서 봤을 때 클래스 명이 Factory임에도 불구하고 단순 객체 생성의 책임을 수행할 뿐 위와 같은 책임을 수행하는 것은 아니라는 생각이 들었습니다.
  - 지금 구현하신 팩토리 클래스의 역할은 model과 view 중 무엇에 더 가까운가요?
    - 현재 구현한 팩토리 클래스의 역할은 사용자의 입력값을 받아서 파싱 및 검증과정을 거친 후 VO 객체들을 생성하는 책임을 갖고 있습니다.
    - 여기에서 사용자의 입력값을 받아서 파싱 및 검증과정을 거친 후 VO 객체들을 생성하는 책임은 충분히 view에서 수행할 수 있다고 생각이 들었습니다.
    - 오히려 팩토리 패턴을 사용하는 이유에 대해서 학습하고 다시 생각해보니 특별한 이유 없이 view의 책임을 도메인이 과도하게 지게 된 것 같다는 생각이 듭니다.
  - 해당 부분은 view에서 처리하여 도메인으로 넘겨주는 것으로 수정하겠습니다!

- vo와 다른 domain과의 차이?
  - 저는 vo가 내부 인스턴스 변수 값으로 단일 원시타입 혹은 문자열을 가지는 일종의 wrapper 클래스라고 생각을 합니다.
  - 그래서 내부에 저장하는 원시타입 및 문자열 값에 대한 검증 및 작업은 vo에서 이뤄져야 한다고 생각했습니다.
  - 또한 domain에서는 vo를 이용해 여러 책임들을 수행할 수 있지만 실질적으로 vo내 원시타입 및 문자열을 외부로 반환받는 경우는 없도록 했습니다.
  - 원시타입 및 문자열을 포장하는 vo의 개수가 많아지다 보니 패키지를 정리할 때 일반적인 비즈니스 로직을 수행하는 domain과 분리시키면 좋을 것 같아 이렇게 진행했습니다.

- 출력을 위한 getter를 다른 개발자가 비즈니스 로직 개발 시 사용해버린다면 어떡하나...?
  - 아무리 잘 구현해 놓는다 하더라도 다른 개발자는 의도와 다르게 사용할 수 있다. 이것은 현업에서도 여전히 숙제인 부분이다.
  - 그래서 페어로 구현하고, 지속적으로 커뮤니케이션하고, 컨벤션을 논의했으면 그것을 잘 지키는 것이 무엇보다 중요한 것 같아요. 
  - 타 개발자와 너무 달라 맞추기 힘들면 클린코드, 리팩토링과 같은 주제로 함께 스터디를 하면서 싱크를 맞출수도 있구요 ㅎㅎ 사소해 보여도 대단한 기술을 쓰는 것보다 훨씬 중요한 부분이라고 생각해요.
  - 또한 책임을 굉장히 잘 나누어서 단일 클래스 단위가 작고, 해당 클래스에 있는 메서드가 몇가지 없다면 한눈에 어떤 기능들이 있는지 확인하기 편하겠죠. 
  - 그러면 대부분 의도에 맞는 메서드를 쉽게 찾아서 쓸 것이라고 생각해요. 
  - 반대로 클래스의 크기가 너무 크고 메서드가 10개 이상 된다면 찾지 못하고 getter를 가져다 쓸 수도 있겠죠.
  - 이처럼 비개발적인 자세가 더 중요하다고 피드백 주심.

- equals & hashCode를 구현해야 하는 상황?
  - 언제 equals와 hashCode를 사용해야 하는지 정확하게 정해져 있는 것은 없다.
  - 알고 있던 대로 자료구조를 사용할 떄 구현할 수도 있고, 또 해당 도메인의 성격을 잘 고민해보고 필요하다면 구현하면 된다.
  - 구현 코드 기준으로 Name 객체는 동명이인인 경우 이름이 같다면 같은 사람으로 분류하는지 다른 사람으로 분류하는지 고려해보고 필요하다면 구현하면 된다.
  - 나의 답변
    - 제가 구현한 사다리 게임에서는 Name 객체가 저장하고 있는 이름 문자열의 값이 동일하면 같은 사람이라고 판단하고 있습니다.
    - 그 이유는 동일한 이름이 입력되었을 때 결과를 출력하기 불가능해지는 문제가 발생하기 때문입니다.
    - 그리고 Name 객체를 현재 hashMap등과 같은 자료구조로 관리하는 것도 아니기에 equals와 hashCode를 지금 구현할 필요는 없어 보입니다.

- 동일 타입의 두 객체를 비교하는 메서드에서 내부 객체를 통해 비교해주는 것이 NPE를 방어할 수 있다.
  - 우리는 외부에서 어떤 값이 들어올지 확신하기 어렵다!
~~~ java
// 외부 주입 값에 대한 NPE 방어 불가능!
public boolean isPlayerName(Name other) {
        return other.isSame(this.name);
    }

// 외부 주입 값에 대한 NPE 방어 가능!
public boolean isPlayerName(Name other) {
    return this.name.isSame(other);
}
~~~



















