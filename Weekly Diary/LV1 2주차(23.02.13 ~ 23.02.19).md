# 레벨 1 - 1주차 (23.02.13 ~ 23.02.19)

---

# 23.02.13 월요일
## 자동차 경주 미션 리팩토링 회고
[블로그 정리 포스팅](https://makemepositive.tistory.com/21)

# 23.02.14 화요일
개발자는 언제나 시간에 쫒기기 마련이다.
정해진 데드라인에 맞춰서 우선순위를 정하고 거기에 맞춰서 태스크를 처리하는 연습이 반드시 필요하다.

## TDD 리팩토링 강의
자동차 경주와는 다르게 이번 미션의 핵심은 TDD이다.

프로덕션 코드 / 테스트 코드로 코드를 나눌 수 있다.
TDD는 프로덕션 코드보다 테스트 코드를 먼저 작성하는 방식이다.
TDD = TFD(Test First Development) + 리팩토링
그냥 테스트 하는 것과 TDD는 다르다.

TDD란 프로그래밍 의사결정과 피드백 사이의 간극을 의식하고 이를 제어하는 기술이다.

이게 무슨말이냐?? -> 코드를 보며 이해해보자
로또게임에서 최소 1 최대 45까지 가지는 숫자를 받는다는 요구사항이 있을 때 이에 대한 테스트 코드부터 작성한다.
ex) 0, 46 입력은 실패, 1,45는 성공하는 테스트 코드를 작성해본다.

TDD의 핵심은 실패하는 테스트 코드를 작성하고 이를 성공하기 위해 노력하는 것이 제일 1순위 작업이다.

하나의 기능에 대해 모든 것을 고려해서 테스트코드를 완성하고 프로덕션으로 넘어가는게 아니라
최대한 빠르게 실패하는 코드를 만들고 이를 기반으로 성공하는 프로덕션코드를 만드는 프로세스로 이루어져야만 한다.
핵심은 가장 빠르게 문제를 실패를 성공으로 바꿔서 해결한다는 것이다. 

도메인이 익숙하기 떄문에 몰랐을 수도 있는데 어떤 구체적인 기능을 구현할 지 정확하게 항상 떠오르는 것은 아니다.
그래서 익숙하지 않으면 베이베 스텝으로 테스트 코드를 통과시켜나가는 과정으로 진행하면 된다.
도메인이 충분히 이해됐다고 생각한 경우까지
이제 좀 더 빠르게 가능할 것 같다는 생각이 들면 그때부터 조금씩 구현 속도를 올려가면 된다.
그래서 TDD는 프로그래밍적으로 어떻게 구현할 것인지 분석하고 의사결정 하는 것과 실제로 테스트 코드(피드백)을 작성하는 것 사이에 간격을 좁혀가는 과정이다.
조금씩 조금씩 테스트하려는 범위를 넓혀나가는 것이 중요하다. 한번에 구현하지는 말자!
페어가 너무 큰 작업을 한번에 진행하려고 한다면 잘 얘기해주는 것이 중요하다.

테오 : tdd 시 커밋 단위는 한 사이클인가요?

TDD를 하는 이유
디버깅 시간을 줄여준다.
동작하는 문서의 역할을 한다.
변화에 대한 두려움을 줄여준다.

내가 구현하지 않은 코드에 대해 검증하는 코드를 작성한다는 것이 기존 방식과 가장 큰 차이이다.
구현을 한 다음에 테스트 코드를 추가하면 내가 그 로직을 알고 있는 상태이기 때문에 단순히 커버리지만 높은 테스트 코드가 나올 가능성이 높다.
또 구현을 먼저하고 테스트 코드를 만드려고 하면 어렵고 꾸역꾸역 추가하게 되는 문제도 발생한다.
구현에 대한 테스트가 아니라 설계에 대한 테스트로 수행할 수 있게 된다.

TDD는 스스로만의 사용 판단 기준을 세워 사용하도록 하는 것이 좋다.

네오는 구현 코드에 대해 한번에 머릿속에 그려지지않을때 TDD를 사용한다.
머릿속에 큰 그림이 그려진다 하더라도 프로젝트에서 많이 중요한 기능의 경우도 TDD로 작성한다.
반면 구현 혹은 돌아가는 코드가 중요한 경우 그냥 구현한다.

테스트 작성(실패) -> 가장 빠르게 성공시킨다 -> 리팩토링

리팩토링 시 단위테스트가 깨지는데 어떡하냐 -> 리팩토링이 아닐 수도 있다. 기능 자체에 변화가 있으면 TDD에서 말하는 리팩토링은 아닐 수 있다고 생각할 수 있어야 한다.

TDD 원칙 3가지
(LMS 참고)

나는 왜 TDD에 집착하는가?
1. 나는 사람이다. -> 요구사항 추가, 변경 때문에 소스코드를 수정하고 불안감에 살고 싶지 않다. 사람답게 살고 싶다.
2. 나는 평범하다. -> 한 번에 한가지만 집중할 수 있다.
3. 나는 프로그래밍을 좋아한다.

테스트를 실패하게 하고 성공하게끔 하는 과정으
입력 출력에 집중
로직을 구현하는 것에 집중
테스트 
심리적으로 안정감을 얻을 수 있다.

처음부터 완벽한 설께를 하는게 아니라
점진적으로 설계를 개선해 나갈 수 있다.
변화에 빠르게 대응할 수 있는 소스 코드와 연습
과도한 설계에 따른 추가 비용을 해소 -> 좀 더 필요한 기능에 집중할 수 있다.

어떤 설계에 대해 단점을 느껴보지 못한 상태에서 사용하는 것보다 직접 느끼고 사용하는 것이 더 좋을 수 있다.


빠른 피드백을 통한 개발 효율 향상
버그를 찾는 시점이 빨라진다.
일정 리듬을 가져가면서 일함으로써 프로그래밍에 재미를 느낌
더 많은 삽질을 할 수 있다. 삽질은 더 많은 배움으로 이어진다.

서비스 안정성이 높아진다.

개발자들의 역량이 강화된다.

수동 테스트에 대한 부담을 내려놓고 비즈니스 로직에 더 집중할 수 있는 환경이 마련된다.

지금 필요한 것은 새로운 접근 방식에 접근할 수 있는 용기이다.

문제가 생길 수 있는 불안함을 천천히 테스트 코드를 짜고 프로덕션으로 넘나드는 지루함으로 바꿔주는 마법이다. (네오)

답해보기 질문 정리하기!



체인저 : TDD로 개발하기 전, 기능목록은 어느 깊이로 작성해야하는 게 좋을까요?
자동차경주미션 정도 기능목록은 정리하고 진행하자.

인자가 객체이고, 해당 객체가 아직 구현이 안되었다면 테스트는 어떻게 진행되나요?
필요한 객체를 먼저 구현하러 간다.

구구 : 나중에 단위 테스트 짜려고 하면 숙제가 쌓인 느낌이라 하기 싫은데 미리 테스트 짜두면 테스트 몰아서 짤 필요가 없어서 좋죠 ㅋㅋㅋㅋ


자바에 대한 이해

라이언 고슬링(초대 자바 챔피언)
자바는 연구를 위한 언어가 아니라 일을 하기 위한 언어이다.

개발자는 화이트 칼라 노동자다.
하지만 자바 개발자는 블루칼라 노동자를 위한 언어다.

코드 작성시 가장 중요한 것은?
정답은 가장 비용적으로 효율적인 것이다.

그렇다면 테스트 코드는 비용적으로 효율적일까?
테오 : 프로그램 라이프 사이클은 유지보수가 주라서 미래를 생각하면 프로덕션 코드를 만드는 것보다는 테스트 코드가 중요할 것  같습니다
콩하나 : 요구사항이 언제든지 변할 수 있기에 장기적으로 더 효율적이라 생각합니다

테스트를 하는 것과 안하는 것 사이에 비용을 계산해보는 것이 중요하다.

자바를 잘한다의 기준?
본인만의 기준을 찾아서 실제 비용과 시간소모를 줄이는 개발자가 좋은 개발자다.
실제 비용과 실제 대응속도는 대체로 반비례 관계이다. (항상 그런 것은 아니다.)
어느정도 기술 부채가 발생하는 것은 어쩔 수 없다. 적절한 기술 부채를 쌓는 것이 중요하다. 그리고 적절한 시점에 기술부채를 정리해야 한다.
소프트웨어 라이프 사이클에 맞는 설계를 해야한다. 초반에는 기술부채가 많이 없어도 될 수 있지만 후반에는 어느정도 기술부채를 허용하는 것이 전체적인 관점에서 더 좋을 수도 있다.


## 브라운의 메타인지 & 프롤로그 소개

메타인지란?
자신의 생각에 대해 판단하는 능력

메타인지의 단계
모니터링 -> 컨트롤
내가 무엇을 모르는지 지켜보는 단계
모니터링 결과를 바탕으로 어떻게 할지 방향을 설정하고 실천하는 것

학습 기록을 그리고 로드맵을 그려본다.
학습 로그 작성
학습 로그 말하기
프롤로그의 로드맵에 키워드들이 작성되어 있는데 이를 적극적으로 활용하자!
내가 글을 남길 수 있고 다른 사람들이 어떻게 의견을 남겼는지도 볼 수 있다.

## 준의 페어 프로그래밍 강의

짝 프로그래밍 메타인지
- 왜 네비게이터 드라이버 타이머를 이용해 교대하면서 진행할까?
  - 문제를 다른 시각으로
  - 소심한 사람들도 기회를
  - 한 명이 멍 때리면 안되니까
- 주니어도 역할을 부여받을 수 있다.

짝 프로그래밍은 어떻게 시작했는지?
- 짝 프로그래밍은 1990년대  XP 방법론의 일부로 도입되었다.
- XP(Extreme Programming)는 1990년대에 켄트 벡이 도입한 소프트웨어 개발 방법론
- 예전에는 뭔가를 개발할 때 요구사항이 딱 정해져 있고 요구사항을 구현하면 되는데 
- 현재에 이르러서는 옛날 방식이 점차 동작이 잘 안되었던 것.
- 현실 세계는 불확실성이 너무 높기 때문
- 피드백 사이틀이 예전에는 너무 길었다.
- 어떻게 하면 불확실성이 높은 현실 세계의 요구사항을 빠르게 반영하고, 유연하게 반응하고 더 빠르게 더 일찍 고객에게 가치를 전달할 수 있을까
- 그 과정에서 더빠르게 더 자주 더 꾸준하게 피드백을 받기 위한 방법 중에 하나로 짝 프로그래밍을 시작하게 된것
- 불확실한 불확실성이 높은 문제를 잘 해결하기 위한 피드백을 더 자주 더 빨리 더 꾸준하게 받는다는 관점에서 시작했다.

짝프로그래밍의 장점
- 중복을 허용한다.
  - 사람이 중복됨으로써 and가 아니라 or조건으로 만들어준다.
  - and 조건으로 하면 숫자가 많을수록 기하급수적으로 줄어들고 or조건은 숫자가 많을 수록 기하 급수적으로 늘어난다.
  - 버그 발생확률이 기하급수적으로 낮아진다.
- 디버깅이 잘된다.
- 전문가의 암묵지를 효과적으로 배울 수 있는 장점이 있다.

짝 프로그래밍 선언문
우리는 함께 자라기 위해 짝 프로그래밍을 하면서 다음의 원칙들을 가치있게 여긴다.
- 짝 프로그래밍의 장점은 '빈번한 교대'를 통한 발견이다.
- 코드의 소유와 책임은 개인이 아닌 팀이다. 실수에 대해 개인을 비난하지 않는다.
- 코드에 대한 지적이 내 인격에 대한 지적이 아니란 걸 잊지 않는다.
- 우리는 서로 비교하지 않고 배우기 위해 짝프로그래밍을 한다.
- 다른 것은 틀린 것이 아니다
- 둘다 알지 못한다면 둘다 모르는 것이다
- 절대 옳은 생각은 존재하지 않는다
- 소통을 두려워하지 않는다
- 받아들이려는 자세를 가장 우선으로 두자
- 페어는 서로 수평적인 관계이다
- 내가 힘들다고 남도 힘든게 아니고 내가 쉽다고 남도 쉽지 않다!
- 침묵은 금이 아니다
- 말투도 실력이다


# 23.02.15 수요일

## 제이슨의 웹 기초 강의

Dto와 service가 현재 미션 수준에서 튀어 나온다면 뭔가 잘못된 것이라고 생각하는 것이 좋다.
닭 잡는데 소칼을 쓰면 안된다.

우버, 페이스북, 에어비엔비의 성공비결? 공통점?
인터넷이라는 세상 위에서 서비스를 하고 있다는 공통점이 있다.

하이퍼 텍스트
- 하이퍼 링크를 통해 독자가 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트
- 사람들이 바로바로 원하는 문서에 접근할 수 있게 되면서 사람의 뇌 구조 또한 바뀌게 된다.

웹의 기능
- URL(Uniform Resouce Locator)
- HTTP
- HTML

인터넷과 웹의 차이?
인터넷은 컴퓨터 네트워크, 광섬유 케이블, 무선 네트워크 등으로 구성된 하드웨어 시스템이다.
반면 웹은 다양한 장치에 저장된 파일, 폴더, 및 문서로 구성되어 소프트웨어다.

인터넷 위에서 제공되는 많은 서비스 중 하나가 웹인 것이다.

https://www.naver.com
https://www.naver.com/index.html

둘의 차이는 엄밀히 말하면 
naver.com은 서버에 대한 주소이고 index.html은 거기에서 해당 파일을 찾겠다는 의미이다.

HTTP는 웹 상에서 정보를 주고받을 수 있는 프로토콜이다.
주로 HTML 문서를 주고 받는데이 쓰인다.

### 웹 서비스의 3대요소?
html 자바스크립트 css 는 웹 페이지를 구성하는 기본 3대 요소이다.
집을 만드는데 뼈대를 만드는 것이 HTML이다.
전기가 들어오게 하고 수도를 들이는 작업은 자바스크립트가 담당한다.
인테리어를 담당하는 것은 css이다.

<br> 강제 개행 태그는 어떤 화면에서도 개행을 수행하려 하기 때문에 줄바꿈을 화면에 따라 다르게 수행하려면
따로 설정해주는 것이 좋다.

절대경로는 내 컴퓨터의 경로를 기준으로 사용하는 것이기 때문에 상대방의 컴퓨터에서도 똑같으리란 보장이 없다.
따라서 어떤 환경에서도 같은 주소로 접근 가능하도록 상대경로를 사용한다.

input 에서 타입을 radio로 하했을 때 name이 같으면 같은 변수로 취급된고 복수 선택이 불가능해진다.
name이 다르다면 복수 선택이 가능하다.


### 자바스크립트
자바와 자바스크립트 차이?
완전히 다르다.

자바스크립트는 let const var 를 변수 선언시 사용한다.


## 사다리 생성 미션

자바의 기본 Wrapper 클래스들은 모두 불변을 보장한다!



# 23.02.16
- 일급 컬렉션에서 전체를 넘겨줘야 할 때는 stream을 넘겨줘도 될까?
- 원시타입 wrapping 클래스를 구현할 때 어떤 사항들을 고려해야 하나?
  - equals, hashCode  [레퍼런스](https://ksjm0720.tistory.com/28)

안녕하세요 코다! 히이로입니다.

이번 미션에서는 제가 진행 도중에 코로나 확진이 되어 페어프로그래밍이 아닌 개인 과제로 제출하게 되었습니다.
개인적으로 이번 미션을 진행하며 궁금했던 사항들은 다음과 같습니다.

## 일급 컬렉션의 값 반환
이번 미션에서는 일급 컬렉션을 구현할 일이 많았습니다. 저는 일반적으로 일급 컬렉션에서 저장하고 있는 요소 값들을 외부로 반환해줘야 할 경우 index를 통해 하나의 요소 값씩 따로 반환하는 식으로 구현했습니다.
하지만 객체에 메세지를 던져야 한다는 기준에는 잘 맞지 않는다는 느낌이 계속 들어왔습니다. 일급컬렉션에서 내부 요소들의 정보를 외부로 반환해야 할 때 일급 컬렉션 내부에서 처리해서 던져주는 것이 맞을까요?
아니라면 요소 값들의 불변을 보장한 뒤 요소 객체를 던져주는 것이 맞을까요?

## 원시타입 Wrapping 클래스
요구사항 중 원시타입과 문자열은 반드시 Wrapping 한다는 것이 있었습니다. 미션을 진행하며 느꼈던 부분은 원시타입을 Wrapping 했을 때 내부에 저장하고 있는 원시타입 값을 외부에
리턴할 수 있도록 하는 것이 옳은지, 아니면 메서드를 추가하여 어떻게든 클래스 내부의 원시타입 값을 은닉화하는 것이 좋을까요?
저는 최대한 은닉화를 하되 출력 혹은 값 자체가 필요한 계산이 요구된다면 getter를 구현하는 주의였는데 코다의 의견도 궁금합니다.

## Enum
개인적으로 시간이 부족해서 많이 신경쓰지 못한 부분이라 아쉽습니다. 사다리의 step을 출력하는데 필요한 문자열들을 모아서 Enum으로 관리하려고 했어요.
도메인 로직 차원에서 step의 유무는 Boolean 값으로 관리하고 있어서 Enum의 key 값으로 Boolean을 둬서 true / false 값으로 Step 문자열들을 관리하고자 했습니다.
하지만 출력 예시사항을 보면 사다리 한 라인의 시작 Step과 이후 Step들의 출력 공백 길이가 달랐습니다. 그래서 첫번재 Step을 따로 추가해 관리해줘야 했고 Boolean 값을 key로 사용하려던 아래 코드를 지금의 코드로 수정할 수 밖에 없었어요.
~~~java
public enum LadderStep {
    FIRST_STEP("first", String.format("%5s","    |")),
    EMPTY_STEP("empty", String.format("%6s","     |")),
    EXIST_STEP("exist", String.format("%6s","-----|"));

    //private final Boolean key;
    private final String key;
    private final String step;

    LadderStep(String key, String step) {
        this.key = key;
        this.step = step;
    }

    public String getStep() {
        return step;
    }

    public static LadderStep of(String key) {
        return Arrays.stream(values())
                .filter(ladderStep -> ladderStep.key.equals(key))
                .findFirst()
                .orElseThrow(()-> new IllegalArgumentException("[ERROR] 존재하지 않는 LadderStep 입니다."));
    }
}
~~~

이후에 도메인 로직에서 key값을 사용하지 않고 바로 LadderStep.FirstStep.getStep()과 같은 식으로 사용하게 되어 key값을 아예 삭제했어요.
하지만 사용하는 모양을 보면 메서드 체이닝이 길어지는 것 같아 아쉬운데 이런 부분은 Enum을 사용할 때 어떤식으로 관리하는 것이 좋을까요?

시간에 쫒겨 좀 급하게 마무리하고 낸 감이 없지않아 있는데 혹 놓친 부분이 있다면 얘기해주세요! 감사합니다!


# 23.02.17

## 좋은 코드, 예외 처리

- 객체지향에 대한 개념
- 가독성 높은 코드
  - 코드를 통해 의도를 전달하라
    - 포지션을 예로 드는 경우 int로 선언 시 우리가 원하는 대로 음수값이 아닌 것을 보장하긴 코드 자체로 힘들다
    - 이것을 보장하기 위해 원시값을 포장하는 것이다.
  - 일관된 코드 스타일을 가지자
  - 하나의 역할만을 담당하자
    - 번호를 비교하는 것과 상금을 얻는 책임 2가지를 수행하는 메서드이다.
    - 하나의 함수가 너무 많은 일을 하고 있다면 테스트 코드 작성이 힘들어진다.
    - 테스트 코드 작성이 힘들다면 너무 큰 단위의 기능을 한번에 구현하고 있는게 아닌가를 생각해보자
    - 추상화 계층이 나빠진다...?
      - 추상화가 어려운 이유? 사람마다 추상적이라고 생각하는 기준이 달라서 판단에 따라 달라질 수 있는 부분이 많기 때문이다.
      - 자판기 예시
        - 예전에는 콜라가 있는 위치의 버튼을 누르면 음료수가 나오는 동작 수행
        - 지금은 제품들이 많아져서 각각 버튼을 만들기 힘들다 => 기술의 발전으로 옳다고 생각하는 기준과 바라보는 시각이 달라졌다.
      - 경험을 쌓아가며 나의 추상화, 남의 추상화를 어떻게 잘 드러내고 이해할 수 있을 지 생각해보자.
  - 매개변수를 명확하게 하자.
    - 매개변수가 많아질수록 메서드 사용할 때마다 어려움이 커진다.
    - 자바는 네임드 파라미터를 지원하지 않는다.
    - 해결방법 일부
      - 변수로 추출하기
        - 예제에서 입맛과 관련된 변수들을 추출하여 따로 선언해준다.
        - 명확하지 않은것도 문제가 되지만 과한 설계도 독이 된다. 정답은 없으니 상황에 맞게 판단한다.
        - var을 사용하는 이유...??
      - 빌더패턴 사용
        - 의미는 잘 전달되지만 데이터가 추가될 수록 이해하기 어려운 문제는 아직 남아있다.
  - API를 적절하게 사용하라
    - 우리가 이런 코드 없나? 생각하는 유틸성 코드들은 대부분 만들어져 있다.
    - 적절한 자료구조를 사용하는 것도 좋다. (set, map 등)
  - api를 위한 코드는 작성말자.
    - 기능구현이 주가 되야지 api를 위한 구현이 되어선 안된다.
    - 스트림 지옥에 빠지지 말자 ㅋㅋㅋ...

- 예측가능한 코드
  - 의미있는 값을 반환하라
    - -1과 같은 매직넘버를 리턴하면 어떤의미를 가지는지 알기가 매우 힘들어진다.
    - 예시에서는 게임 참여자가 없다는 의미로 -1을 리턴하고 있다.
    - 값이 올바르지 않을 경우 외부에서 처리하도록 위임할수 있게 optional 타입을 반환할 수 있다.
    - 혹은 예외를 발생시켜 명시적으로 처리할 수 있다.
    - 준팍 : 메서드를 사용하는 사람이 예외 유무를 알아야만 한다면 외부에서 처리하도록 하는 것도 좋은 방법이다.
    - 우르 : 해당 메서드의 시그니처만 봐도 이 메서드는 nullable할 수 있구나 라고 생각할 수 있을 것 같아요
      - 모든 메서드에서 null체크를 해주는 것은 현실적으로 불가능하다.
      - 그래서 메서드 시그니처로 의도를 전달하는 것이 중요하다.
    - 컬렉션에서 아이디어를 얻어보자
      - 응답값이 컬렉션인데 리턴 null을 하고 있다면 의심해봐야한다.
      - 컬렉션은 일반적으로 값이 없다면 빈 컬렉션을 반환한다.
        - 그렇다면 우리도 optional이나 null이 아니라 다른 방법을 사용할 수는 없을까?
        - 객체도 동일하게 Null Object를 사용하면 된다. 
        - 시작되지 않은 위치일 때 상황도 하나의 객체로 바라보자.
  - 부수효과를 제거하라
    - 포지션 값을 리턴하고 값을 증가시키고 있다.
    - 또한 값의 조회와 변경을 한 메서드를 통해서 수행하고 있다. 즉 2가지 역할을 동시에 하고 있다.
    - getter를 사용하지 말라고 하니 값의 변경 이후 값을 반환하는, 예제같이 작성하는 경우가 있는데 주의해야 한다.
    - 명령과 조회를 분리하는데 집중하자!
    - 게터를 왜 사용하지 말라고 할까
      - 게터를 써서 값을 가지고 온다음에 비즈니스 로직을 사용하지 말라는 것이지 아예 사용하지 말라고 하는 것이 아니다.
    - CQS에 대해 공부해보자.
  - 중요 입력에 대해 무시하지 말자.
    - 예시는 추천을 받았지만 받지 않은 상태가 발생하는 버그가 생기게 된다.
    - 즉 서비스가 동작하지 않은 건지 동작을 했지만 결과가 없는지 체크가 불가하다
    - 추천할 수 없는 메뉴가 발생했을 시 확실하게 처리해줘야 한다.
    - 개발 과정에서 중요도를 선정하는 과정도 주관이 들어가서 사람마다 다를 수 있을것같기도 하네요
      - 그래서 실제로 일할때는 개인의 주관으로만 판단하지 않습니다! 🙂 수많은 협업자들과 ‘정책’이라는 걸 정합니다
      - Public 메서드를 여러 개 제공하면서, 내가 의도한 생각대로 사용할 거라고 가정하지 마세요. 메서드 사용자는 메서드를 구현한 사람의 의도를 모릅니다~
  - 열것값을 암묵적으로 처리하지 마라
    - 우리는 run 메서드가 enum 수정 시 함께 수정되길 바라지만 세상은 원하는대로 흘러가지 않는다.
      - run 메서드를 enum 필드 안으로 넣어주는 방법
      - enum을 사용하는 부분에 대해 테스트 코드를 작성함으로써 해결할 수 있다.
      - 컴파일 타임에 경고를 받을 수 있다면 더욱 베스트다. (switch를 사용하여 컴파일 타임 시 경고 발생)
      - enum 내에 로직이 필요할까...?
  - 실수를 방지하는 코드
    - 원시값을 포장하라
      - 원시 값 자체를 불변으로 선언한다면 상태의 변화에서도 자유로울 수 있다
    - 변경 가능성을 최소화하자
      - 매개변수로 넘어온 리스트에 대해서도 불변을 보장해줘야 한다.
      - 내부에서 리스트에 가한 변경이 외부 리스트에 영향을 줄수도 있다.
        - 매개변수로 받은 리스트를 final로 선언해준다.
        - 저문 : 방금 전에 궁금한게 있었는데 position을 불변으로 만들었는데 객체가 계속해서 생성되면 메모리에 대한 문제도 생길 수 있나요?
          - 에코 : 사용하지 않는 객체가 많아질 것 같습니다.
        - 허브 : 메모리에 대한 문제가 걱정되신다면, position의 최대값을 제한하고 캐싱하는 방법이 있을 것 같습니다.
      - GC에 대한 신뢰성? 내부적으로 값을 복사하는 비용으로 인해 성능적 이슈는 발생하지 않을까? 고민해보자
      - 개발자의 인건비, 노력, 시간 과 컴퓨팅 리소스 어느것이 더 중한지 우선시 할지 생각해봐야 한다.
      - 외부에서 누군가가 실수하지 않도록 주의해야 한다.
  - 추상화 레벨을 잘 유지하면서 개발하고 있는지 스스로 체크해보자...

## 첫 번째 코수타 진행
- 본과정에서는 어떻게 하는 것이 좋을까
- 혼자 문제를 해결해보는 힘을 길러보라는 의미
- 2단계에서 꼭 혼자하지 않아도 된다. 내가 더 많이 성장할 수 있는 부분이 있는 방법을 선택해서 진행해라.
- 한 번 만났던 리뷰어는 해당 레벨에서 다시 못 만나게끔 되어있다.

스터디 / 커뮤니티가 잘 유지될 수 있는 비결
- 1순위는 관계형성과 친목 도모이다.
- 지식 습득은 그 이후이다.
- 스터디 커뮤니티를 오래 유지하는 것이 목적일 때는 친목과 관계형성이 가장 중요하다.
- 내가 부족한 것을 먼저 드러내고 그것을 채우기 위해 도움을 받아보자.

- 4기 취업현황?
- 학교로 돌아간 친구들을 제외하면 65% 이상 취업

## 리사의 피드백 강의
- 좋은 피드백이란?
- 우리 스스로에게 좋은 피드백을 주려고 하는 것은 매우 어렵다.
- 좋았던 점, 아쉬웠던 점을 회고로 남긴 글 예시 -> 초리의 피드백
- 기술적인 내용과 그렇지 않은 내용이 분리되면 다시 읽기 좋을 것 같아요
- 미션이의 피드백
- 기술적인 공부 / 스스로의 성장 / 페어에 대해 / 나 스스로 아쉬웠던 점 / 추가로 회고하고 싶은 카테고리 추가...
  - 회고의 종류에 따른 분류가 되어있는게 좋은 것 같았어요
  - 두루뭉술한 표현이 명확해졌으면 좋겠어요
  - 기술적인 부분에 대해 좋았다고만 설명해 너무 추상적인 것 같습니다. 이 부분에서 어떤 점이 좋았는지 구체적으로 적으면 좋을 것 같습니다.
  - 좀 더 구체적이거나 사례를 하나씩 들어주면 더 이해하기 쉬울 것 같습니다
- 테코의 피드백
  - 어떤 부분을 어떻게 왜 그렇게 느꼈는지 명확하게 기술했던 것 같다.
  - 상대방이 가장 스스로의 장단점을 발견하는데 의미있는 피드백이 될 것 같다.

## 회고
- 회고가 왜 중요할까?
- 데일리 미팅, 지속적 배포, 짝 프로그래밍 등 여러 활동을 했을 때 가장 도움되는 활동이 무엇이었냐 물어보면 회고라 다들 답한다.
- 짝 프로그래밍 후 회고할 때 짝에게 어떤 피드백을 받고 싶은가? => 나도 상대방에게 이런 피드백을 해줘야 한다.
- 함께 학습하는 크루들에게 어떤 피드백을 받고 싶은가?
- 상대방에게 나의 약점같아 보이는 것을 드러내기 힘들어하는데 우테코에서 이런 부분을 깨보면 좋겠다.

- 회고의 목적 : 학습을 통해 개선하기 위함이다
  - 구체적인 액션 플랜을 찾는다.

- 감정적으로 소통하는 것 : 감정회고
  - 회고를 통해 꼭 구체적인 액션 플랜이 없어도 된다.
  - 감정 공유만으로도 가치가 있다.
  - 옆에서 듣다보면 닭살 돋고 뭐하는 것인가 싶을 때도 있다.
  - 하지만 관계가 악화되는 것은 사소한 것들이 쌓이다가 그렇게 되는 경우가 많다.

- 좋은 이야기만 할 경우
  - 학습 개선도 행복도 얻기 힘들다.
  - 좋았던 점, 개선할 부분, 감정회고가 적절히 섞여야 한다.

- 감정적인 소통을 해야 행복감을 느낄 수 있다.

- 감정회고를 어떻게 하면 잘할 수 있을까
  - 감정 표현 시 상대방이 주어가 되기 보다 '나'를 주어로 하는 문장을 쓴다.
  - 구체적인 행동과 상황을 공유하고 그 순간 느낀 감정에 대해 언급을 하는 것이 중요하다.
  - 어떤 행동에 대해 어떻게 왜 그렇게 느꼈는지 얘기할 수 있는 것이 중요하다.

- 회고를 작성하고나서 나중에 어떻게 잘 활용할 수 있을까
  - 회고가 쌓여가면서 개선해야할 것들도 계속 쌓여만 가는데 어떻게 하는 것이 좋을까
    - 작은 시도, 변화라도 괜찮다. 내게 가장 의미있는 것들부터 시작해 나가는 것이 중요하다. 작은 것 부터 시작해보자.


