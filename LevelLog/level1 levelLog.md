## 레벨로그 작성
### 일급 컬렉션을 사용하는 이유
- 동일 타입 객체들에 대한 상태와 행위를 한 곳에서 관리하기 위함이다.
- 일급 컬렉션을 사용하면 얻을 수 있는 장점
    - 리스트 요소 객체들에 대한 검증 및 기능 로직들을 스스로 관리할 수 있게 된다. (객체간 중복 여부, 객체 개수 검증 등...)
- 일급 컬렉션을 사용하지 않는다면...?
    - 객체 요소 컬렉션을 사용하는 모든 클래스마다 리스트 요소 객체들에 대한 검증 및 기능 로직들을 구현해줘야 한다.

### 객체의 불변성 유지
- final 키워드
    - 선언된 변수가 초기화 될 때를 제외하고 값이 재할당 되는 것을 막아주는 키워드이다.
    - 객체의 참조 타입 상태 값에 대해 단순하게 final 선언만 해준다고 불변을 보장할 수 없다.
    - 참조 타입 변수에 담기는 객체 내부적으로도 스스로의 상태 값에 대한 불변을 보장해야 한다.
- 방어적 복사
    - 클래스 내부에 저장된 객체 데이터를 보호하기 위해 주로 사용된다. 주된 사용 경우는 아래와 같다.
        - 생성자의 매개변수로 객체를 받아서 클래스 내부 필드를 초기화해야 하는 경우.
        - getter 메서드로 클래스 내부에 저장된 객체를 외부로 반환해야 하는 경우.
- unmodifiable List
    - List를 수정할 수 있는 연산 (add, remove) 등을 막아둔 List 구현체를 unmodifiable 리스트라고 한다.
    - 객체 내부 상태값 리스트를 getter를 통해 외부로 반환할 때 사용하기도 한다.
        - 단 동료 개발자 입장에서 unmodifiable 리스트가 반환된다는 것을 알아차릴 수 있도록 메서드 명 등을 통해서 알릴 수 있어야 한다.
    - unmodifiable 리스트는 원본 리스트 자체에 대한 불변은 보장하지 않는다.
        - 즉 원본 리스트가 변경되면 unmodifiable 리스트도 변경된다.

### 디미터의 법칙
- 디미터의 법칙은 최소한의 지식 원칙(The Principle Of Least Knowledge)을 강조하며, 모듈은 사용하는 객체의 속사정을 몰라야 된다는 원칙이다.
- 디미터의 기본 법칙 요약 : 어떤 클래스 C의 메서드 f 내부에서는 다음과 같은 객체의 메서드만 호출해야 한다.
    - 클래스 C가 갖고 있는 다른 메서드
    - 클래스 C가 저장하고 있는 인스턴스 객체의 메서드
    - 메서드 f의 매개변수로 전달받은 객체의 메서드
    - 메서드 f의 내부에서 생성된 객체의 메서드
- 위와 같은 원칙들을 지켜서 객체를 사용할 때 객체간 결합도를 낮추고 자율성을 높여 객체 간 올바른 협력관계를 구축할 수 있다.

### 객체 간 동등성과 동일성 비교
- 동일성 비교는 객체가 할당된 메모리 주소가 동일한지 비교한다.
- 동등성 비교는 객체가 내부적으로 같은 상태값을 가지는지 비교한다.
    - 단 객체 내부적으로 equals 메서드를 재정의해줘야 한다.
- Enum간 비교는 equals가 아니라 ==(동일성) 비교를 해야한다.
    - 성능적으로 차이는 없다. 기본적으로 equals도 내부에서 동일성 비교를 해준다.
    - 다만 객체 타입이 다른 경우라도 equals 는 컴파일 에러를 내지 않고 ==은 컴파일 에러를 발생시켜준다.
        - 그래서 타입 오류를 개발하는 시점에서 알 수 있게 된다는 장점이 있다.
    - equals는 NPE 발생의 위험이 존재하지만, ==은 NPE가 발생하지 않는다는 장점도 있다.

### 인터페이스와 추상클래스

- 인터페이스 : 모든 메서드가 추상 메서드로 선언된다.
    - 미리 사용할 메서드를 인터페이스에 선언해두고 구현 시 선언된 메서드들을 구현하면 된다.
    - 즉 자식 클래스에게 구현을 강제시켜 구현 객체의 동일 동작을 보장한다.
    - 상속보다는 다형성의 개념에 더 가깝다.
    - 다형성은 하나의 타입에 대입되는 객체에 따라서 실행 결과가 다르게 나오는 성질을 말한다.
    - 인터페이스는 다형성을 제공하기 위해 반드시 구현해야하는 메소드를 포함한 틀이라고 얘기할 수 있다.

- 추상클래스 : 클래스 내 추상 메서드가 하나 이상 포함되거나 abstract로 정의된 경우
    - 여러 메서드가 존재하므로 다음의 방법들 중 선택해서 사용한다.
        - 메서드가 구현된 그대로 가져다 쓴다.
        - 오버라이드해서 기존 메서드를 재구현해 사용한다.
        - abstract로 선언된 메서드를 구현해서 사용한다.
    - 부모가 가진 기능을 재사용 혹은 확장 할 수 있는 상속을 위한 틀

- 공통적으로 둘 다 상속받은 자식에게 메서드 구현을 위임하도록 한다.
- 추상 클래스가 모든 메서드를 추상 메서드로 가지면 인터페이스와 같아지나?
    - 추상클래스는 인터페이스와 다르게 다중 상속이 불가능하다.
